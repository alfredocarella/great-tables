[
  {
    "objectID": "reference/vals.fmt_percent.html",
    "href": "reference/vals.fmt_percent.html",
    "title": "vals.fmt_percent",
    "section": "",
    "text": "vals.fmt_percent(x, decimals=2, drop_trailing_zeros=False, drop_trailing_dec_mark=True, scale_values=True, use_seps=True, pattern='{x}', sep_mark=',', dec_mark='.', force_sign=False, placement='right', incl_space=False, locale=None)\nFormat values as a percentage.\nWith numeric values in a list, we can perform percentage-based formatting. It is assumed the input numeric values are proportional values and, in this case, the values will be automatically multiplied by 100 before decorating with a percent sign (the other case is accommodated though setting scale_values to False). For more control over percentage formatting, we can use the following options:\n\npercent sign placement: the percent sign can be placed after or before the values and a space can be inserted between the symbol and the value.\ndecimals: choice of the number of decimal places, option to drop trailing zeros, and a choice of the decimal symbol\ndigit grouping separators: options to enable/disable digit separators and provide a choice of separator symbol\nvalue scaling toggle: choose to disable automatic value scaling in the situation that values are already scaled coming in (and just require the percent symbol)\npattern: option to use a text pattern for decoration of the formatted values\nlocale-based formatting: providing a locale ID will result in number formatting specific to the chosen locale\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\ndecimals\nint\nThe decimals values corresponds to the exact number of decimal places to use. A value such as 2.34 can, for example, be formatted with 0 decimal places and it would result in \"2\". With 4 decimal places, the formatted value becomes \"2.3400\". The trailing zeros can be removed with drop_trailing_zeros=True.\n2\n\n\ndrop_trailing_zeros\nbool\nA boolean value that allows for removal of trailing zeros (those redundant zeros after the decimal mark).\nFalse\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nscale_values\nbool\nShould the values be scaled through multiplication by 100? By default this scaling is performed since the expectation is that incoming values are usually proportional. Setting to False signifies that the values are already scaled and require only the percent sign when formatted.\nTrue\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nplacement\nstr\nThis option governs the placement of the percent sign. This can be either be \"right\" (the default) or \"left\".\n'right'\n\n\nincl_space\nbool\nAn option for whether to include a space between the value and the percent sign. The default is to not introduce a space character.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/vals.fmt_percent.html#parameters",
    "href": "reference/vals.fmt_percent.html#parameters",
    "title": "vals.fmt_percent",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\ndecimals\nint\nThe decimals values corresponds to the exact number of decimal places to use. A value such as 2.34 can, for example, be formatted with 0 decimal places and it would result in \"2\". With 4 decimal places, the formatted value becomes \"2.3400\". The trailing zeros can be removed with drop_trailing_zeros=True.\n2\n\n\ndrop_trailing_zeros\nbool\nA boolean value that allows for removal of trailing zeros (those redundant zeros after the decimal mark).\nFalse\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nscale_values\nbool\nShould the values be scaled through multiplication by 100? By default this scaling is performed since the expectation is that incoming values are usually proportional. Setting to False signifies that the values are already scaled and require only the percent sign when formatted.\nTrue\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nplacement\nstr\nThis option governs the placement of the percent sign. This can be either be \"right\" (the default) or \"left\".\n'right'\n\n\nincl_space\nbool\nAn option for whether to include a space between the value and the percent sign. The default is to not introduce a space character.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/vals.fmt_percent.html#returns",
    "href": "reference/vals.fmt_percent.html#returns",
    "title": "vals.fmt_percent",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/vals.fmt_roman.html",
    "href": "reference/vals.fmt_roman.html",
    "title": "vals.fmt_roman",
    "section": "",
    "text": "vals.fmt_roman(x, case='upper', pattern='{x}')\nFormat values as Roman numerals.\nWith numeric values we can transform those to Roman numerals, rounding values as necessary.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\ncase\nstr\nShould Roman numerals should be rendered as uppercase (\"upper\") or lowercase (\"lower\") letters? By default, this is set to \"upper\".\n'upper'\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/vals.fmt_roman.html#parameters",
    "href": "reference/vals.fmt_roman.html#parameters",
    "title": "vals.fmt_roman",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\ncase\nstr\nShould Roman numerals should be rendered as uppercase (\"upper\") or lowercase (\"lower\") letters? By default, this is set to \"upper\".\n'upper'\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'"
  },
  {
    "objectID": "reference/vals.fmt_roman.html#returns",
    "href": "reference/vals.fmt_roman.html#returns",
    "title": "vals.fmt_roman",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/vals.fmt_currency.html",
    "href": "reference/vals.fmt_currency.html",
    "title": "vals.fmt_currency",
    "section": "",
    "text": "vals.fmt_currency(x, currency=None, use_subunits=True, decimals=None, drop_trailing_dec_mark=True, use_seps=True, scale_by=1, pattern='{x}', sep_mark=',', dec_mark='.', force_sign=False, placement='left', incl_space=False, locale=None)\nFormat values as currencies.\nWith numeric values, we can perform currency-based formatting with the val_fmt_currency() function. This supports both automatic formatting with a three-letter currency code. We have fine control over the conversion from numeric values to currency values, where we could take advantage of the following options:\n\nthe currency: providing a currency code or common currency name will procure the correct currency symbol and number of currency subunits\ncurrency symbol placement: the currency symbol can be placed before or after the values\ndecimals/subunits: choice of the number of decimal places, and a choice of the decimal symbol, and an option on whether to include or exclude the currency subunits (the decimal portion)\ndigit grouping separators: options to enable/disable digit separators and provide a choice of separator symbol\nscaling: we can choose to scale targeted values by a multiplier value\npattern: option to use a text pattern for decoration of the formatted currency values\nlocale-based formatting: providing a locale ID will result in currency formatting specific to the chosen locale; it will also retrieve the locale’s currency if none is explicitly given\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\ncurrency\nOptional[str]\nThe currency to use for the numeric value. This input can be supplied as a 3-letter currency code (e.g., \"USD\" for U.S. Dollars, \"EUR\" for the Euro currency).\nNone\n\n\nuse_subunits\nbool\nAn option for whether the subunits portion of a currency value should be displayed. For example, with an input value of 273.81, the default formatting will produce \"$273.81\". Removing the subunits (with use_subunits = False) will give us \"$273\".\nTrue\n\n\ndecimals\nOptional[int]\nThe decimals values corresponds to the exact number of decimal places to use. This value is optional as a currency has an intrinsic number of decimal places (i.e., the subunits). A value such as 2.34 can, for example, be formatted with 0 decimal places and if the currency used is \"USD\" it would result in \"$2\". With 4 decimal places, the formatted value becomes \"$2.3400\".\nNone\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\nscale_by\nfloat\nAll numeric values will be multiplied by the scale_by value before undergoing formatting. Since the default value is 1, no values will be changed unless a different multiplier value is supplied.\n1\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nplacement\nstr\nThe placement of the currency symbol. This can be either be \"left\" (as in \"$450\") or \"right\" (which yields \"450$\").\n'left'\n\n\nincl_space\nbool\nAn option for whether to include a space between the value and the currency symbol. The default is to not introduce a space character.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/vals.fmt_currency.html#parameters",
    "href": "reference/vals.fmt_currency.html#parameters",
    "title": "vals.fmt_currency",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\ncurrency\nOptional[str]\nThe currency to use for the numeric value. This input can be supplied as a 3-letter currency code (e.g., \"USD\" for U.S. Dollars, \"EUR\" for the Euro currency).\nNone\n\n\nuse_subunits\nbool\nAn option for whether the subunits portion of a currency value should be displayed. For example, with an input value of 273.81, the default formatting will produce \"$273.81\". Removing the subunits (with use_subunits = False) will give us \"$273\".\nTrue\n\n\ndecimals\nOptional[int]\nThe decimals values corresponds to the exact number of decimal places to use. This value is optional as a currency has an intrinsic number of decimal places (i.e., the subunits). A value such as 2.34 can, for example, be formatted with 0 decimal places and if the currency used is \"USD\" it would result in \"$2\". With 4 decimal places, the formatted value becomes \"$2.3400\".\nNone\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\nscale_by\nfloat\nAll numeric values will be multiplied by the scale_by value before undergoing formatting. Since the default value is 1, no values will be changed unless a different multiplier value is supplied.\n1\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nplacement\nstr\nThe placement of the currency symbol. This can be either be \"left\" (as in \"$450\") or \"right\" (which yields \"450$\").\n'left'\n\n\nincl_space\nbool\nAn option for whether to include a space between the value and the currency symbol. The default is to not introduce a space character.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/vals.fmt_currency.html#returns",
    "href": "reference/vals.fmt_currency.html#returns",
    "title": "vals.fmt_currency",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/GT.save.html",
    "href": "reference/GT.save.html",
    "title": "GT.save",
    "section": "",
    "text": "GT.save(self, file, selector='table', scale=1.0, expand=5, web_driver='chrome', window_size=(6000, 6000))\nSave a table as an image file or a PDF document.\nThe save() method makes it easy to save a table object as an image file. The function produces a high-resolution image file or PDF of the table. The output file is create by first taking a screenshot of the table using a headless Chrome browser (other browser options are possible if Chrome isn’t present). The screenshot is then cropped to only include the table element, with some additional pixels added around the table (controlled by the expand= parameter). Finally, the resulting image is saved to the specified file path in the format specified (via the file extension).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfile\nstr\nThe name of the file to save the image to. Accepts names ending with .png, .bmp, and other image extensions. Also accepts the extension .pdf.\nrequired\n\n\nselector\nstr\nThe HTML element selector to use to select the table. By default, this is set to “table”, which selects the first table element in the HTML content.\n'table'\n\n\nscale\nfloat\nThe scaling factor that will be used when generating the image. By default, this is set to a value of 1.0. Lowering this will result in a smaller image, whereas increasing it will result in a much higher-resolution image. This can be considered a quality setting, yet it also affects the file size. The default value of 1.0 is a good balance between file size and quality.\n1.0\n\n\nexpand\nint\nThe number of pixels to expand the screenshot by. By default, this is set to 5. This can be increased to capture more of the surrounding area, or decreased to capture less.\n5\n\n\nweb_driver\nWebDrivers\nThe webdriver to use when taking the screenshot. By default, this is set to \"chrome\" which uses Google Chrome in headless mode. If that browser isn’t available on the host system, there are other options available: \"firefox\" (Mozilla Firefox), \"safari\" (Apple Safari), and \"edge\" (Microsoft Edge). Ensure that at least one of these browsers is installed on the system and choose the appropriate option based on that.\n'chrome'\n\n\nwindow_size\ntuple[int, int]\nThe size of the window to use when taking the screenshot. This is a tuple of two integers, representing the width and height of the window. By default, this is set to (6000, 6000), a large size that should be sufficient for most tables. If the table is larger than this (and this will be obvious once inspecting the image file) you can increase the appropriate values of the tuple. If the table is very small, then a reduction in these these values will result in a speed gain during image capture. Please note that the window size is not the same as the final image size. The table will be captured at the same size as it is displayed in the headless browser, and the window size is used to ensure that the entire table is visible in the screen capture before the cropping process occurs.\n(6000, 6000)\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nNone\nThis function does not return anything; it simply saves the image to the specified file path.\n\n\n\n\n\n\nWe create the output file based on the HTML version of the table.\nThis process is facilitated by two libraries:\n\nselenium, which is used to control the Chrome browser and take a screenshot of the table.\nPIL, which is used to crop the screenshot to only include the table element of the page.\n\nBoth of these packages needs to be installed before attempting to save any table as an image file. The selenium package also requires the Chrome browser to be installed on the system.\nA pip-based reinstallation of Great Tables through the following command will install these required packages:\npip install great_tables[extra]"
  },
  {
    "objectID": "reference/GT.save.html#parameters",
    "href": "reference/GT.save.html#parameters",
    "title": "GT.save",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nfile\nstr\nThe name of the file to save the image to. Accepts names ending with .png, .bmp, and other image extensions. Also accepts the extension .pdf.\nrequired\n\n\nselector\nstr\nThe HTML element selector to use to select the table. By default, this is set to “table”, which selects the first table element in the HTML content.\n'table'\n\n\nscale\nfloat\nThe scaling factor that will be used when generating the image. By default, this is set to a value of 1.0. Lowering this will result in a smaller image, whereas increasing it will result in a much higher-resolution image. This can be considered a quality setting, yet it also affects the file size. The default value of 1.0 is a good balance between file size and quality.\n1.0\n\n\nexpand\nint\nThe number of pixels to expand the screenshot by. By default, this is set to 5. This can be increased to capture more of the surrounding area, or decreased to capture less.\n5\n\n\nweb_driver\nWebDrivers\nThe webdriver to use when taking the screenshot. By default, this is set to \"chrome\" which uses Google Chrome in headless mode. If that browser isn’t available on the host system, there are other options available: \"firefox\" (Mozilla Firefox), \"safari\" (Apple Safari), and \"edge\" (Microsoft Edge). Ensure that at least one of these browsers is installed on the system and choose the appropriate option based on that.\n'chrome'\n\n\nwindow_size\ntuple[int, int]\nThe size of the window to use when taking the screenshot. This is a tuple of two integers, representing the width and height of the window. By default, this is set to (6000, 6000), a large size that should be sufficient for most tables. If the table is larger than this (and this will be obvious once inspecting the image file) you can increase the appropriate values of the tuple. If the table is very small, then a reduction in these these values will result in a speed gain during image capture. Please note that the window size is not the same as the final image size. The table will be captured at the same size as it is displayed in the headless browser, and the window size is used to ensure that the entire table is visible in the screen capture before the cropping process occurs.\n(6000, 6000)"
  },
  {
    "objectID": "reference/GT.save.html#returns",
    "href": "reference/GT.save.html#returns",
    "title": "GT.save",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nNone\nThis function does not return anything; it simply saves the image to the specified file path."
  },
  {
    "objectID": "reference/GT.save.html#details",
    "href": "reference/GT.save.html#details",
    "title": "GT.save",
    "section": "",
    "text": "We create the output file based on the HTML version of the table.\nThis process is facilitated by two libraries:\n\nselenium, which is used to control the Chrome browser and take a screenshot of the table.\nPIL, which is used to crop the screenshot to only include the table element of the page.\n\nBoth of these packages needs to be installed before attempting to save any table as an image file. The selenium package also requires the Chrome browser to be installed on the system.\nA pip-based reinstallation of Great Tables through the following command will install these required packages:\npip install great_tables[extra]"
  },
  {
    "objectID": "reference/GT.cols_align.html",
    "href": "reference/GT.cols_align.html",
    "title": "GT.cols_align",
    "section": "",
    "text": "GT.cols_align(self, align='left', columns=None)\nSet the alignment of one or more columns.\nThe cols_align() method sets the alignment of one or more columns. The align argument can be set to one of \"left\", \"center\", or \"right\" and the columns argument can be used to specify which columns to apply the alignment to. If columns is not specified, the alignment is applied to all columns."
  },
  {
    "objectID": "reference/GT.cols_align.html#parameters",
    "href": "reference/GT.cols_align.html#parameters",
    "title": "GT.cols_align",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nalign\nstr\nThe alignment to apply. Must be one of \"left\", \"center\", or \"right\".\n'left'\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list. If None, the alignment is applied to all columns.\nNone"
  },
  {
    "objectID": "reference/GT.cols_align.html#returns",
    "href": "reference/GT.cols_align.html#returns",
    "title": "GT.cols_align",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.cols_align.html#examples",
    "href": "reference/GT.cols_align.html#examples",
    "title": "GT.cols_align",
    "section": "Examples",
    "text": "Examples\nLet’s use the countrypops to create a small table. We can change the alignment of the population column with cols_align(). In this example, the column label and body cells of population will be aligned to the left.\n\nfrom great_tables import GT\nfrom great_tables.data import countrypops\n\ncountrypops_mini = countrypops.loc[countrypops[\"country_name\"] == \"San Marino\"][\n    [\"country_name\", \"year\", \"population\"]\n].tail(5)\n\n(\n    GT(countrypops_mini, rowname_col=\"year\", groupname_col=\"country_name\")\n    .cols_align(align=\"left\", columns=\"population\")\n)\n\n\n\n\n\n\n  \n  population\n\n\n  \n    San Marino\n  \n  \n    2018\n    34156\n  \n  \n    2019\n    34178\n  \n  \n    2020\n    34007\n  \n  \n    2021\n    33745\n  \n  \n    2022\n    33660"
  },
  {
    "objectID": "reference/GT.cols_width.html",
    "href": "reference/GT.cols_width.html",
    "title": "GT.cols_width",
    "section": "",
    "text": "GT.cols_width(data, cases)\nSet the widths of columns.\nManual specifications of column widths can be performed using the cols_width() method. We choose which columns get specific widths. This can be in units of pixels or as percentages. Width assignments are supplied inside of a dictionary where columns are the keys and the corresponding width is the value."
  },
  {
    "objectID": "reference/GT.cols_width.html#parameters",
    "href": "reference/GT.cols_width.html#parameters",
    "title": "GT.cols_width",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncases\nDict[str, str]\nA dictionary where the keys are column names and the values are the widths. Widths can be specified in pixels (e.g., \"50px\") or as percentages (e.g., \"20%\").\nrequired"
  },
  {
    "objectID": "reference/GT.cols_width.html#returns",
    "href": "reference/GT.cols_width.html#returns",
    "title": "GT.cols_width",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.cols_width.html#examples",
    "href": "reference/GT.cols_width.html#examples",
    "title": "GT.cols_width",
    "section": "Examples",
    "text": "Examples\nLet’s use select columns from the exibble dataset to create a new table. We can specify the widths of columns with cols_width(). This is done by specifying the exact widths for table columns in a dictionary. In this example, we’ll set the width of the num column to \"150px\", the char column to \"100px\", the date column to \"300px\". All other columns won’t be affected (their widths will be automatically set by their content).\n\nfrom great_tables import GT, exibble\n\nexibble_mini = exibble[[\"num\", \"char\", \"date\", \"datetime\", \"row\"]].head(5)\n\n(\n    GT(exibble_mini)\n    .cols_width(\n        cases={\n            \"num\": \"150px\",\n            \"char\": \"100px\",\n            \"date\": \"300px\"\n        }\n    )\n)\n\n\n\n\n\n  \n  \n  \n  \n  \n\n\n\n\n  num\n  char\n  date\n  datetime\n  row\n\n\n  \n    0.1111\n    apricot\n    2015-01-15\n    2018-01-01 02:22\n    row_1\n  \n  \n    2.222\n    banana\n    2015-02-15\n    2018-02-02 14:33\n    row_2\n  \n  \n    33.33\n    coconut\n    2015-03-15\n    2018-03-03 03:44\n    row_3\n  \n  \n    444.4\n    durian\n    2015-04-15\n    2018-04-04 15:55\n    row_4\n  \n  \n    5550.0\n    \n    2015-05-15\n    2018-05-05 04:00\n    row_5\n  \n\n\n\n\n\n\n        \n\n\nWe can also specify the widths of columns as percentages. In this example, we’ll set the width of the num column to \"20%\", the char column to \"10%\", and the date column to \"30%\". Note that the percentages are relative and don’t need to sum to 100%.\n\n(\n    GT(exibble_mini)\n    .cols_width(\n        cases={\n            \"num\": \"20%\",\n            \"char\": \"10%\",\n            \"date\": \"30%\"\n        }\n    )\n)\n\n\n\n\n\n  \n  \n  \n  \n  \n\n\n\n\n  num\n  char\n  date\n  datetime\n  row\n\n\n  \n    0.1111\n    apricot\n    2015-01-15\n    2018-01-01 02:22\n    row_1\n  \n  \n    2.222\n    banana\n    2015-02-15\n    2018-02-02 14:33\n    row_2\n  \n  \n    33.33\n    coconut\n    2015-03-15\n    2018-03-03 03:44\n    row_3\n  \n  \n    444.4\n    durian\n    2015-04-15\n    2018-04-04 15:55\n    row_4\n  \n  \n    5550.0\n    \n    2015-05-15\n    2018-05-05 04:00\n    row_5\n  \n\n\n\n\n\n\n        \n\n\nWe can also mix and match pixel and percentage widths. In this example, we’ll set the width of the num column to \"150px\", the char column to \"10%\", and the date column to \"30%\".\n\n(\n    GT(exibble_mini)\n    .cols_width(\n        cases={\n            \"num\": \"150px\",\n            \"char\": \"10%\",\n            \"date\": \"30%\"\n        }\n    )\n)\n\n\n\n\n\n  \n  \n  \n  \n  \n\n\n\n\n  num\n  char\n  date\n  datetime\n  row\n\n\n  \n    0.1111\n    apricot\n    2015-01-15\n    2018-01-01 02:22\n    row_1\n  \n  \n    2.222\n    banana\n    2015-02-15\n    2018-02-02 14:33\n    row_2\n  \n  \n    33.33\n    coconut\n    2015-03-15\n    2018-03-03 03:44\n    row_3\n  \n  \n    444.4\n    durian\n    2015-04-15\n    2018-04-04 15:55\n    row_4\n  \n  \n    5550.0\n    \n    2015-05-15\n    2018-05-05 04:00\n    row_5\n  \n\n\n\n\n\n\n        \n\n\nIf we set the width of all columns, the table will be forced to use the specified widths (i.e., a column width less than the content width will be honored). In this next example, we’ll set widths for all columns. This is a good way to ensure that the widths you specify are fully respected (and not overridden by automatic width calculations).\n\n(\n    GT(exibble_mini)\n    .cols_width(\n        cases={\n            \"num\": \"30px\",\n            \"char\": \"100px\",\n            \"date\": \"100px\",\n            \"datetime\": \"200px\",\n            \"row\": \"50px\"\n        }\n    )\n)\n\n\n\n\n\n  \n  \n  \n  \n  \n\n\n\n\n  num\n  char\n  date\n  datetime\n  row\n\n\n  \n    0.1111\n    apricot\n    2015-01-15\n    2018-01-01 02:22\n    row_1\n  \n  \n    2.222\n    banana\n    2015-02-15\n    2018-02-02 14:33\n    row_2\n  \n  \n    33.33\n    coconut\n    2015-03-15\n    2018-03-03 03:44\n    row_3\n  \n  \n    444.4\n    durian\n    2015-04-15\n    2018-04-04 15:55\n    row_4\n  \n  \n    5550.0\n    \n    2015-05-15\n    2018-05-05 04:00\n    row_5\n  \n\n\n\n\n\n\n        \n\n\nNotice that in the above example, the num column is very small (only 30px) and the content overflows. When not specifying the width of all columns, the table will automatically adjust the column widths based on the content (and you wouldn’t get the overflowing behavior seen in the previous example)."
  },
  {
    "objectID": "reference/GT.fmt.html",
    "href": "reference/GT.fmt.html",
    "title": "GT.fmt",
    "section": "",
    "text": "GT.fmt(self, fns, columns=None, rows=None, is_substitution=False)\nSet a column format with a formatter function.\nThe fmt() method provides a way to execute custom formatting functionality with raw data values in a way that can consider all output contexts.\nAlong with the columns and rows arguments that provide some precision in targeting data cells, the fns argument allows you to define one or more functions for manipulating the raw data.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nfns\nUnion[FormatFn, FormatFns]\nEither a single formatting function or a named list of functions.\nrequired\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\nis_substitution\n\nWhether the formatter is a substitution. Substitutions are run last, after other formatters.\nFalse\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.fmt.html#parameters",
    "href": "reference/GT.fmt.html#parameters",
    "title": "GT.fmt",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nfns\nUnion[FormatFn, FormatFns]\nEither a single formatting function or a named list of functions.\nrequired\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\nis_substitution\n\nWhether the formatter is a substitution. Substitutions are run last, after other formatters.\nFalse"
  },
  {
    "objectID": "reference/GT.fmt.html#returns",
    "href": "reference/GT.fmt.html#returns",
    "title": "GT.fmt",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/style.borders.html",
    "href": "reference/style.borders.html",
    "title": "style.borders",
    "section": "",
    "text": "style.borders(sides='all', color='#000000', style='solid', weight='1px')\nA style specification for cell borders.\nThe styles.borders() class is to be used with the tab_style() method, which itself allows for the setting of custom styles to one or more cells. The sides argument is where we define which borders should be modified (e.g., \"left\", \"right\", etc.). With that selection, the color, style, and weight of the selected borders can then be modified.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsides\nLiteral[‘all’, ‘top’, ‘bottom’, ‘left’, ‘right’] | List[Literal[‘all’, ‘top’, ‘bottom’, ‘left’, ‘right’]] | ColumnExpr\nThe border sides to be modified. Options include \"left\", \"right\", \"top\", and \"bottom\". For all borders surrounding the selected cells, we can use the \"all\" option.\n'all'\n\n\ncolor\nstr | ColumnExpr\nThe border color can be defined with any valid CSS color value, such as a hex code, a named color, or an RGB value. The default color value is \"#000000\" (black).\n'#000000'\n\n\nstyle\nstr | ColumnExpr\nThe border style can be one of either \"solid\" (the default), \"dashed\", \"dotted\", \"hidden\", or \"double\".\n'solid'\n\n\nweight\nstr | ColumnExpr\nThe default value for weight is \"1px\" and higher values will become more visually prominent.\n'1px'\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nCellStyleBorders\nA CellStyleBorders object, which is used for a styles argument if specifying cell borders."
  },
  {
    "objectID": "reference/style.borders.html#parameters",
    "href": "reference/style.borders.html#parameters",
    "title": "style.borders",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nsides\nLiteral[‘all’, ‘top’, ‘bottom’, ‘left’, ‘right’] | List[Literal[‘all’, ‘top’, ‘bottom’, ‘left’, ‘right’]] | ColumnExpr\nThe border sides to be modified. Options include \"left\", \"right\", \"top\", and \"bottom\". For all borders surrounding the selected cells, we can use the \"all\" option.\n'all'\n\n\ncolor\nstr | ColumnExpr\nThe border color can be defined with any valid CSS color value, such as a hex code, a named color, or an RGB value. The default color value is \"#000000\" (black).\n'#000000'\n\n\nstyle\nstr | ColumnExpr\nThe border style can be one of either \"solid\" (the default), \"dashed\", \"dotted\", \"hidden\", or \"double\".\n'solid'\n\n\nweight\nstr | ColumnExpr\nThe default value for weight is \"1px\" and higher values will become more visually prominent.\n'1px'"
  },
  {
    "objectID": "reference/style.borders.html#returns",
    "href": "reference/style.borders.html#returns",
    "title": "style.borders",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nCellStyleBorders\nA CellStyleBorders object, which is used for a styles argument if specifying cell borders."
  },
  {
    "objectID": "reference/GT.as_raw_html.html",
    "href": "reference/GT.as_raw_html.html",
    "title": "GT.as_raw_html",
    "section": "",
    "text": "GT.as_raw_html(self, make_page=False, all_important=False)\nGet the HTML content of a GT object.\nGet the HTML content from a GT object as a string. This function is useful for obtaining the HTML content of a GT object for use in other contexts.\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ngt\n\nA GT object.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nstr\nAn HTML fragment containing a table."
  },
  {
    "objectID": "reference/GT.as_raw_html.html#parameters",
    "href": "reference/GT.as_raw_html.html#parameters",
    "title": "GT.as_raw_html",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ngt\n\nA GT object.\nrequired"
  },
  {
    "objectID": "reference/GT.as_raw_html.html#returns",
    "href": "reference/GT.as_raw_html.html#returns",
    "title": "GT.as_raw_html",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nstr\nAn HTML fragment containing a table."
  },
  {
    "objectID": "reference/GT.fmt_image.html",
    "href": "reference/GT.fmt_image.html",
    "title": "GT.fmt_image",
    "section": "",
    "text": "GT.fmt_image(self, columns=None, rows=None, height=None, width=None, sep=' ', path=None, file_pattern='{}', encode=True)\nFormat image paths to generate images in cells.\nTo more easily insert graphics into body cells, we can use the fmt_image() method. This allows for one or more images to be placed in the targeted cells. The cells need to contain some reference to an image file, either: (1) complete http/https or local paths to the files; (2) the file names, where a common path can be provided via path=; or (3) a fragment of the file name, where the file_pattern= argument helps to compose the entire file name and path= provides the path information. This should be expressly used on columns that contain only references to image files (i.e., no image references as part of a larger block of text). Multiple images can be included per cell by separating image references by commas. The sep= argument allows for a common separator to be applied between images."
  },
  {
    "objectID": "reference/GT.fmt_image.html#parameters",
    "href": "reference/GT.fmt_image.html#parameters",
    "title": "GT.fmt_image",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in targeted columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\nheight\nstr | int | None\nThe height of the rendered images.\nNone\n\n\nwidth\nstr | int | None\nThe width of the rendered images.\nNone\n\n\nsep\nstr\nIn the output of images within a body cell, sep= provides the separator between each image.\n' '\n\n\npath\nstr | Path | None\nAn optional path to local image files (this is combined with all filenames).\nNone\n\n\nfile_pattern\nstr\nThe pattern to use for mapping input values in the body cells to the names of the graphics files. The string supplied should use \"{}\" in the pattern to map filename fragments to input strings.\n'{}'\n\n\nencode\nbool\nThe option to always use Base64 encoding for image paths that are determined to be local. By default, this is True.\nTrue"
  },
  {
    "objectID": "reference/GT.fmt_image.html#examples",
    "href": "reference/GT.fmt_image.html#examples",
    "title": "GT.fmt_image",
    "section": "Examples",
    "text": "Examples\nUsing a small portion of [metro] dataset, let’s create a gt table. We will only include a few columns and rows from that table. The lines column has comma-separated listings of numbers corresponding to lines served at each station. We have a directory of SVG graphics for all of these lines in the package (the path for the image directory can be accessed via files(\"great_tables\") / \"data/metro_images\", using the importlib_resources package). The filenames roughly corresponds to the data in the lines column. The fmt_image() function can be used with these inputs since the path= and file_pattern= arguments allow us to compose complete and valid file locations. What you get from this are sequences of images in the table cells, taken from the referenced graphics files on disk.\n\nfrom great_tables import GT\nfrom great_tables.data import metro\nfrom importlib_resources import files\n\nimg_paths = files(\"great_tables\") / \"data/metro_images\"\n\nmetro_mini = metro[[\"name\", \"lines\", \"passengers\"]].head(5)\n\n(\n    GT(metro_mini)\n    .fmt_image(\n        columns=\"lines\",\n        path=img_paths,\n        file_pattern=\"metro_{}.svg\"\n    )\n    .fmt_integer(columns=\"passengers\")\n)\n\n\n\n\n\n\n  name\n  lines\n  passengers\n\n\n  \n    Argentine\n    \n    2,079,212\n  \n  \n    Bastille\n      \n    8,069,243\n  \n  \n    Bérault\n    \n    2,106,827\n  \n  \n    Champs-Élysées—Clemenceau\n     \n    1,909,005\n  \n  \n    Charles de Gaulle—Étoile\n      \n    4,291,663"
  },
  {
    "objectID": "reference/GT.tab_spanner.html",
    "href": "reference/GT.tab_spanner.html",
    "title": "GT.tab_spanner",
    "section": "",
    "text": "GT.tab_spanner(data, label, columns=None, spanners=None, level=None, id=None, gather=True, replace=False)\nInsert a spanner above a selection of column headings.\nThis part of the table contains, at a minimum, column labels and, optionally, an unlimited number of levels for spanners. A spanner will occupy space over any number of contiguous column labels and it will have an associated label and ID value. This method allows for mapping to be defined by column names, existing spanner ID values, or a mixture of both.\nThe spanners are placed in the order of calling tab_spanner() so if a later call uses the same columns in its definition (or even a subset) as the first invocation, the second spanner will be overlaid atop the first. Options exist for forcibly inserting a spanner underneath others (with level as space permits) and with replace, which allows for full or partial spanner replacement."
  },
  {
    "objectID": "reference/GT.tab_spanner.html#parameters",
    "href": "reference/GT.tab_spanner.html#parameters",
    "title": "GT.tab_spanner",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel\nstr\nThe text to use for the spanner label. We can optionally use the md() and html() helper functions to style the text as Markdown or to retain HTML elements in the text.\nrequired\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nspanners\nUnion[list[str], str, None]\nThe spanners that should be spanned over, should they already be defined. One or more spanner ID values (in quotes) can be supplied here. This argument works in tandem with the columns argument.\nNone\n\n\nlevel\nOptional[int]\nAn explicit level to which the spanner should be placed. If not provided, Great Tables will choose the level based on the inputs provided within columns and spanners, placing the spanner label where it will fit. The first spanner level (right above the column labels) is 0.\nNone\n\n\nid\nOptional[str]\nThe ID for the spanner. When accessing a spanner through the spanners argument of tab_spanner() the id value is used as the reference (and not the label). If an id is not explicitly provided here, it will be taken from the label value. It is advisable to set an explicit id value if you plan to access this cell in a later call and the label text is complicated (e.g., contains markup, is lengthy, or both). Finally, when providing an id value you must ensure that it is unique across all ID values set for spanner labels (the method will throw an error if id isn’t unique).\nNone\n\n\ngather\nbool\nAn option to move the specified columns such that they are unified under the spanner. Ordering of the moved-into-place columns will be preserved in all cases. By default, this is set to True.\nTrue\n\n\nreplace\nbool\nShould new spanners be allowed to partially or fully replace existing spanners? (This is a possibility if setting spanners at an already populated level.) By default, this is set to False and an error will occur if some replacement is attempted.\nFalse"
  },
  {
    "objectID": "reference/GT.tab_spanner.html#returns",
    "href": "reference/GT.tab_spanner.html#returns",
    "title": "GT.tab_spanner",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.tab_spanner.html#examples",
    "href": "reference/GT.tab_spanner.html#examples",
    "title": "GT.tab_spanner",
    "section": "Examples",
    "text": "Examples\nLet’s create a table using a small portion of the gtcars dataset. Over several columns (hp, hp_rpm, trq, trq_rpm, mpg_c, mpg_h) we’ll use tab_spanner() to add a spanner with the label \"performance\". This effectively groups together several columns related to car performance under a unifying label.\n\nfrom great_tables import GT\nfrom great_tables.data import gtcars\n\ncolnames = [\"model\", \"hp\", \"hp_rpm\", \"trq\", \"trq_rpm\", \"mpg_c\", \"mpg_h\"]\ngtcars_mini = gtcars[colnames].head(10)\n\n(\n    GT(gtcars_mini)\n    .tab_spanner(\n        label=\"performance\",\n        columns=[\"hp\", \"hp_rpm\", \"trq\", \"trq_rpm\", \"mpg_c\", \"mpg_h\"]\n    )\n)\n\n\n\n\n\n\n  model\n  \n    performance\n  \n\n\n  hp\n  hp_rpm\n  trq\n  trq_rpm\n  mpg_c\n  mpg_h\n\n\n  \n    GT\n    647.0\n    6250.0\n    550.0\n    5900.0\n    11.0\n    18.0\n  \n  \n    458 Speciale\n    597.0\n    9000.0\n    398.0\n    6000.0\n    13.0\n    17.0\n  \n  \n    458 Spider\n    562.0\n    9000.0\n    398.0\n    6000.0\n    13.0\n    17.0\n  \n  \n    458 Italia\n    562.0\n    9000.0\n    398.0\n    6000.0\n    13.0\n    17.0\n  \n  \n    488 GTB\n    661.0\n    8000.0\n    561.0\n    3000.0\n    15.0\n    22.0\n  \n  \n    California\n    553.0\n    7500.0\n    557.0\n    4750.0\n    16.0\n    23.0\n  \n  \n    GTC4Lusso\n    680.0\n    8250.0\n    514.0\n    5750.0\n    12.0\n    17.0\n  \n  \n    FF\n    652.0\n    8000.0\n    504.0\n    6000.0\n    11.0\n    16.0\n  \n  \n    F12Berlinetta\n    731.0\n    8250.0\n    509.0\n    6000.0\n    11.0\n    16.0\n  \n  \n    LaFerrari\n    949.0\n    9000.0\n    664.0\n    6750.0\n    12.0\n    16.0\n  \n\n\n\n\n\n\n        \n\n\nWe can also use Markdown formatting for the spanner label. In this example, we’ll use gt.md(\"*Performance*\") to make the label italicized.\n\nfrom great_tables import GT, md\nfrom great_tables.data import gtcars\n\ncolnames = [\"model\", \"hp\", \"hp_rpm\", \"trq\", \"trq_rpm\", \"mpg_c\", \"mpg_h\"]\ngtcars_mini = gtcars[colnames].head(10)\n\n(\n    GT(gtcars_mini)\n    .tab_spanner(\n        label=md(\"*Performance*\"),\n        columns=[\"hp\", \"hp_rpm\", \"trq\", \"trq_rpm\", \"mpg_c\", \"mpg_h\"]\n    )\n)\n\n\n\n\n\n\n  model\n  \n    Performance\n  \n\n\n  hp\n  hp_rpm\n  trq\n  trq_rpm\n  mpg_c\n  mpg_h\n\n\n  \n    GT\n    647.0\n    6250.0\n    550.0\n    5900.0\n    11.0\n    18.0\n  \n  \n    458 Speciale\n    597.0\n    9000.0\n    398.0\n    6000.0\n    13.0\n    17.0\n  \n  \n    458 Spider\n    562.0\n    9000.0\n    398.0\n    6000.0\n    13.0\n    17.0\n  \n  \n    458 Italia\n    562.0\n    9000.0\n    398.0\n    6000.0\n    13.0\n    17.0\n  \n  \n    488 GTB\n    661.0\n    8000.0\n    561.0\n    3000.0\n    15.0\n    22.0\n  \n  \n    California\n    553.0\n    7500.0\n    557.0\n    4750.0\n    16.0\n    23.0\n  \n  \n    GTC4Lusso\n    680.0\n    8250.0\n    514.0\n    5750.0\n    12.0\n    17.0\n  \n  \n    FF\n    652.0\n    8000.0\n    504.0\n    6000.0\n    11.0\n    16.0\n  \n  \n    F12Berlinetta\n    731.0\n    8250.0\n    509.0\n    6000.0\n    11.0\n    16.0\n  \n  \n    LaFerrari\n    949.0\n    9000.0\n    664.0\n    6750.0\n    12.0\n    16.0"
  },
  {
    "objectID": "reference/GT.cols_move.html",
    "href": "reference/GT.cols_move.html",
    "title": "GT.cols_move",
    "section": "",
    "text": "GT.cols_move(data, columns, after)\nMove one or more columns.\nOn those occasions where you need to move columns this way or that way, we can make use of the cols_move() method. While it’s true that the movement of columns can be done upstream of Great Tables, it is much easier and less error prone to use the method provided here. The movement procedure here takes one or more specified columns (in the columns argument) and places them to the right of a different column (the after argument). The ordering of the columns to be moved is preserved, as is the ordering of all other columns in the table.\nThe columns supplied in columns must all exist in the table and none of them can be in the after argument. The after column must also exist and only one column should be provided here. If you need to place one more or columns at the beginning of the column series, the cols_move_to_start() method should be used. Similarly, if those columns to move should be placed at the end of the column series then use cols_move_to_end()."
  },
  {
    "objectID": "reference/GT.cols_move.html#parameters",
    "href": "reference/GT.cols_move.html#parameters",
    "title": "GT.cols_move",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nrequired\n\n\nafter\nstr\nThe column after which the columns should be placed. This can be any column name that exists in the table.\nrequired"
  },
  {
    "objectID": "reference/GT.cols_move.html#returns",
    "href": "reference/GT.cols_move.html#returns",
    "title": "GT.cols_move",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.cols_move.html#examples",
    "href": "reference/GT.cols_move.html#examples",
    "title": "GT.cols_move",
    "section": "Examples",
    "text": "Examples\nLet’s use the countrypops dataset to create a table. We’ll choose to position the population column after the country_name column by using the cols_move() method.\n\nfrom great_tables import GT\nfrom great_tables.data import countrypops\n\ncountrypops_mini = countrypops.loc[countrypops[\"country_name\"] == \"Japan\"][\n    [\"country_name\", \"year\", \"population\"]\n].tail(5)\n\n(\n    GT(countrypops_mini)\n    .cols_move(\n        columns=\"population\",\n        after=\"country_name\"\n    )\n)\n\n\n\n\n\n\n  country_name\n  population\n  year\n\n\n  \n    Japan\n    126811000\n    2018\n  \n  \n    Japan\n    126633000\n    2019\n  \n  \n    Japan\n    126261000\n    2020\n  \n  \n    Japan\n    125681593\n    2021\n  \n  \n    Japan\n    125124989\n    2022"
  },
  {
    "objectID": "reference/GT.tab_style.html",
    "href": "reference/GT.tab_style.html",
    "title": "GT.tab_style",
    "section": "",
    "text": "GT.tab_style(self, style, locations)\nAdd custom style to one or more cells\nWith the tab_style() method we can target specific cells and apply styles to them. We do this with the combination of the style and location arguments. The style argument requires use of styling classes (e.g., style.fill(color=\"red\")) and the location argument needs to be an expression of the cells we want to target using location targeting classes (e.g., loc.body(columns=&lt;column_name&gt;)). With the available suite of styling classes, here are some of the styles we can apply:"
  },
  {
    "objectID": "reference/GT.tab_style.html#parameters",
    "href": "reference/GT.tab_style.html#parameters",
    "title": "GT.tab_style",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstyle\nCellStyle | list[CellStyle]\nThe styles to use for the cells at the targeted locations. The style.text(), style.fill(), and style.borders() classes can be used here to more easily generate valid styles.\nrequired\n\n\nlocations\nLoc | list[Loc]\nThe cell or set of cells to be associated with the style. The loc.body() class can be used here to easily target body cell locations.\nrequired"
  },
  {
    "objectID": "reference/GT.tab_style.html#examples",
    "href": "reference/GT.tab_style.html#examples",
    "title": "GT.tab_style",
    "section": "Examples",
    "text": "Examples\nLet’s use a small subset of the exibble dataset to demonstrate how to use tab_style() to target specific cells and apply styles to them. We’ll start by creating the exibble_sm table (a subset of the exibble table) and then use tab_style() to apply a light cyan background color to the cells in the num column for the first two rows of the table. We’ll then apply a larger font size to the cells in the fctr column for the last four rows of the table.\n\nfrom great_tables import GT, style, loc, exibble\n\nexibble_sm = exibble[[\"num\", \"fctr\", \"row\", \"group\"]]\n\n(\n    GT(exibble_sm, rowname_col=\"row\", groupname_col=\"group\")\n    .tab_style(\n        style=style.fill(color=\"lightcyan\"),\n        locations=loc.body(columns=\"num\", rows=[\"row_1\", \"row_2\"]),\n    )\n    .tab_style(\n        style=style.text(size=\"22px\"),\n        locations=loc.body(columns=[\"fctr\"], rows=[4, 5, 6, 7]),\n    )\n)\n\n\n\n\n\n\n  \n  num\n  fctr\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    one\n  \n  \n    row_2\n    2.222\n    two\n  \n  \n    row_3\n    33.33\n    three\n  \n  \n    row_4\n    444.4\n    four\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    five\n  \n  \n    row_6\n    \n    six\n  \n  \n    row_7\n    777000.0\n    seven\n  \n  \n    row_8\n    8880000.0\n    eight\n  \n\n\n\n\n\n\n        \n\n\nLet’s use exibble once again to create a simple, two-column output table (keeping only the num and currency columns). With the tab_style() method (called twice), we’ll add style to the values already formatted by fmt_number() and fmt_currency(). In the style argument of each tab_style() call, we can define multiple types of styling with the style.fill() and style.text() classes (enclosing these in a list). The cells to be targeted for styling require the use of loc.body(), which is used here with different columns being targeted.\n\nfrom great_tables import GT, style, loc, exibble\n\n(\n    GT(exibble[[\"num\", \"currency\"]])\n    .fmt_number(columns=\"num\", decimals=1)\n    .fmt_currency(columns=\"currency\")\n    .tab_style(\n        style=[\n            style.fill(color=\"lightcyan\"),\n            style.text(weight=\"bold\")\n        ],\n        locations=loc.body(columns=\"num\")\n    )\n    .tab_style(\n        style=[\n            style.fill(color=\"#F9E3D6\"),\n            style.text(style=\"italic\")\n        ],\n        locations=loc.body(columns=\"currency\")\n    )\n)\n\n\n\n\n\n\n  num\n  currency\n\n\n  \n    0.1\n    $49.95\n  \n  \n    2.2\n    $17.95\n  \n  \n    33.3\n    $1.39\n  \n  \n    444.4\n    $65,100.00\n  \n  \n    5,550.0\n    $1,325.81\n  \n  \n    nan\n    $13.26\n  \n  \n    777,000.0\n    \n  \n  \n    8,880,000.0\n    $0.44"
  },
  {
    "objectID": "reference/GT.tab_style.html#returns",
    "href": "reference/GT.tab_style.html#returns",
    "title": "GT.tab_style",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.fmt_markdown.html",
    "href": "reference/GT.fmt_markdown.html",
    "title": "GT.fmt_markdown",
    "section": "",
    "text": "GT.fmt_markdown(self, columns=None, rows=None)\nFormat Markdown text.\nAny Markdown-formatted text in the incoming cells will be transformed during render when using the fmt_markdown() method.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in targeted columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining.\n\n\n\n\n\n\nThe functional version of this method, val_fmt_markdown(), allows you to format a single string value (or a list of them)."
  },
  {
    "objectID": "reference/GT.fmt_markdown.html#parameters",
    "href": "reference/GT.fmt_markdown.html#parameters",
    "title": "GT.fmt_markdown",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in targeted columns being formatted. Alternatively, we can supply a list of row indices.\nNone"
  },
  {
    "objectID": "reference/GT.fmt_markdown.html#returns",
    "href": "reference/GT.fmt_markdown.html#returns",
    "title": "GT.fmt_markdown",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.fmt_markdown.html#see-also",
    "href": "reference/GT.fmt_markdown.html#see-also",
    "title": "GT.fmt_markdown",
    "section": "",
    "text": "The functional version of this method, val_fmt_markdown(), allows you to format a single string value (or a list of them)."
  },
  {
    "objectID": "reference/GT.fmt_nanoplot.html",
    "href": "reference/GT.fmt_nanoplot.html",
    "title": "GT.fmt_nanoplot",
    "section": "",
    "text": "GT.fmt_nanoplot(self, columns=None, rows=None, plot_type='line', plot_height='2em', missing_vals='marker', autoscale=False, reference_line=None, reference_area=None, expand_x=None, expand_y=None, options=None)\nFormat data for nanoplot visualizations.\nThe fmt_nanoplot() method is used to format data for nanoplot visualizations. This method allows for the creation of a variety of different plot types, including line, bar, and scatter plots."
  },
  {
    "objectID": "reference/GT.fmt_nanoplot.html#parameters",
    "href": "reference/GT.fmt_nanoplot.html#parameters",
    "title": "GT.fmt_nanoplot",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nstr | None\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in targeted columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\nplot_type\nPlotType\nNanoplots can either take the form of a line plot (using \"line\") or a bar plot (with \"bar\"). A line plot, by default, contains layers for a data line, data points, and a data area. With a bar plot, the always visible layer is that of the data bars.\n'line'\n\n\nplot_height\nstr\nThe height of the nanoplots. The default here is a sensible value of \"2em\".\n'2em'\n\n\nmissing_vals\nMissingVals\nIf missing values are encountered within the input data, there are three strategies available for their handling: (1) \"gap\" will show data gaps at the sites of missing data, where data lines will have discontinuities and bar plots will have missing bars; (2) \"marker\" will behave like \"gap\" but show prominent visual marks at the missing data locations; (3) \"zero\" will replace missing values with zero values; and (4) \"remove\" will remove any incoming missing values.\n'marker'\n\n\nautoscale\nbool\nUsing autoscale=True will ensure that the bounds of all nanoplots produced are based on the limits of data combined from all input rows. This will result in a shared scale across all of the nanoplots (for y- and x-axis data), which is useful in those cases where the nanoplot data should be compared across rows.\nFalse\n\n\nreference_line\nOptional[Union[str, int, float]]\nA reference line requires a single input to define the line. It could be a numeric value, applied to all nanoplots generated. Or, the input can be one of the following for generating the line from the underlying data: (1) \"mean\", (2) \"median\", (3) \"min\", (4) \"max\", (5) \"q1\", (6) \"q3\", (7) \"first\", or (8) \"last\".\nNone\n\n\nreference_area\nOptional[List[Any]]\nA reference area requires a list of two values for defining bottom and top boundaries (in the y direction) for a rectangular area. The types of values supplied are the same as those expected for reference_line=, which is either a numeric value or one of the following keywords for the generation of the value: (1) \"mean\", (2) \"median\", (3) \"min\", (4) \"max\", (5) \"q1\", (6) \"q3\", (7) \"first\", or (8) \"last\". Input can either be a vector or list with two elements.\nNone\n\n\nexpand_x\nOptional[Union[List[Union[int, float]], List[int], List[float]]]\nShould you need to have plots expand in the x direction, provide one or more values to expand_x=. Any values provided that are outside of the range of x-value data provided to the plot will result in a x-scale expansion.\nNone\n\n\nexpand_y\nOptional[Union[List[Union[int, float]], List[int], List[float]]]\nSimilar to expand_x=, one can have plots expand in the y direction. To make this happen, provide one or more values to expand_y=. If any of the provided values are outside of the range of y-value data provided, the plot will result in a y-scale expansion.\nNone\n\n\noptions\nOptional[Dict[str, Any]]\nBy using the nanoplot_options() helper function here, you can alter the layout and styling of the nanoplots in the new column.\nNone"
  },
  {
    "objectID": "reference/GT.fmt_nanoplot.html#details",
    "href": "reference/GT.fmt_nanoplot.html#details",
    "title": "GT.fmt_nanoplot",
    "section": "Details",
    "text": "Details\nNanoplots try to show individual data with reasonably good visibility. Interactivity is included as a basic feature so one can hover over the data points and vertical guides will display the value ascribed to each data point. Because Great Tables knows all about numeric formatting, values will be compactly formatted so as to not take up valuable real estate.\nWhile basic customization options are present in fmt_nanoplot(), many more opportunities for customizing nanoplots on a more granular level are possible with the aforementioned nanoplot_options() helper function. With that, layers of the nanoplots can be selectively removed and the aesthetics of the remaining plot components can be modified."
  },
  {
    "objectID": "reference/GT.fmt_nanoplot.html#examples",
    "href": "reference/GT.fmt_nanoplot.html#examples",
    "title": "GT.fmt_nanoplot",
    "section": "Examples",
    "text": "Examples\nLet’s create a nanoplot from a Polars DataFrame containing multiple numbers per cell. The numbers are represented here as strings, where spaces separate the values, and the same values are present in two columns: lines and bars. We will use the fmt_nanoplot() method twice to create a line plot and a bar plot from the data in their respective columns.\n\nfrom great_tables import GT\nimport polars as pl\n\nrandom_numbers_df = pl.DataFrame(\n    {\n        \"i\": range(1, 5),\n        \"lines\": [\n            \"20 23 6 7 37 23 21 4 7 16\",\n            \"2.3 6.8 9.2 2.42 3.5 12.1 5.3 3.6 7.2 3.74\",\n            \"-12 -5 6 3.7 0 8 -7.4\",\n            \"2 0 15 7 8 10 1 24 17 13 6\",\n        ],\n    }\n).with_columns(bars=pl.col(\"lines\"))\n\n(\n    GT(random_numbers_df, rowname_col=\"i\")\n    .fmt_nanoplot(columns=\"lines\")\n    .fmt_nanoplot(columns=\"bars\", plot_type=\"bar\")\n)\n\n\n\n\n\n\n  \n  lines\n  bars\n\n\n  \n    1\n    37.04.0020.023.06.007.0037.023.021.04.007.0016.0\n    37.0020.023.06.007.0037.023.021.04.007.0016.0\n  \n  \n    2\n    12.12.302.306.809.202.423.5012.15.303.607.203.74\n    12.102.306.809.202.423.5012.15.303.607.203.74\n  \n  \n    3\n    8.00−12.0−12.0−5.006.003.7008.00−7.40\n    8.00−12.0−12.0−5.006.003.7008.00−7.40\n  \n  \n    4\n    24.002.00015.07.008.0010.01.0024.017.013.06.00\n    24.002.00015.07.008.0010.01.0024.017.013.06.00\n  \n\n\n\n\n\n\n        \n\n\nWe can always represent the input DataFrame in a different way (with list columns) and fmt_nanoplot() will still work. While the input data is the same as in the previous example, we’ll take the opportunity here to add a reference line and a reference area to the line plot and also to the bar plot.\n\nrandom_numbers_df = pl.DataFrame(\n    {\n        \"i\": range(1, 5),\n        \"lines\": [\n            { \"val\": [20.0, 23.0, 6.0, 7.0, 37.0, 23.0, 21.0, 4.0, 7.0, 16.0] },\n            { \"val\": [2.3, 6.8, 9.2, 2.42, 3.5, 12.1, 5.3, 3.6, 7.2, 3.74] },\n            { \"val\": [-12.0, -5.0, 6.0, 3.7, 0.0, 8.0, -7.4] },\n            { \"val\": [2.0, 0.0, 15.0, 7.0, 8.0, 10.0, 1.0, 24.0, 17.0, 13.0, 6.0] },\n        ],\n    }\n).with_columns(bars=pl.col(\"lines\"))\n\n(\n    GT(random_numbers_df, rowname_col=\"i\")\n    .fmt_nanoplot(\n        columns=\"lines\",\n        reference_line=\"mean\",\n        reference_area=[\"min\", \"q1\"]\n    )\n    .fmt_nanoplot(\n        columns=\"bars\",\n        plot_type=\"bar\",\n        reference_line=\"max\",\n        reference_area=[\"max\", \"median\"])\n)\n\n\n\n\n\n\n  \n  lines\n  bars\n\n\n  \n    1\n    16.437.04.0020.023.06.007.0037.023.021.04.007.0016.0\n    37.037.04.0020.023.06.007.0037.023.021.04.007.0016.0\n  \n  \n    2\n    5.6212.12.302.306.809.202.423.5012.15.303.607.203.74\n    12.112.12.302.306.809.202.423.5012.15.303.607.203.74\n  \n  \n    3\n    −0.968.00−12.0−12.0−5.006.003.7008.00−7.40\n    8.008.00−12.0−12.0−5.006.003.7008.00−7.40\n  \n  \n    4\n    9.3624.002.00015.07.008.0010.01.0024.017.013.06.00\n    24.024.002.00015.07.008.0010.01.0024.017.013.06.00\n  \n\n\n\n\n\n\n        \n\n\nSingle-value bar plots and line plots can be made with fmt_nanoplot(). These run in the horizontal direction, which is ideal for tabular presentation. The key thing here is that fmt_nanoplot() expects a column of numeric values. These plots are meant for comparison across rows so the method automatically scales the horizontal bars to facilitate this type of display. The following example shows how fmt_nanoplot() can be used to create single-value bar and line plots.\n\nsingle_vals_df = pl.DataFrame(\n    {\n        \"i\": range(1, 6),\n        \"bars\": [4.1, 1.3, -5.3, 0, 8.2],\n        \"lines\": [12.44, 6.34, 5.2, -8.2, 9.23]\n    }\n)\n(\n    GT(single_vals_df, rowname_col=\"i\")\n    .fmt_nanoplot(columns=\"bars\", plot_type=\"bar\")\n    .fmt_nanoplot(columns=\"lines\", plot_type=\"line\")\n)\n\n\n\n\n\n\n  \n  bars\n  lines\n\n\n  \n    1\n    4.10\n    12.4\n  \n  \n    2\n    1.30\n    6.34\n  \n  \n    3\n    −5.30\n    5.20\n  \n  \n    4\n    0\n    −8.20\n  \n  \n    5\n    8.20\n    9.23"
  },
  {
    "objectID": "reference/GT.sub_zero.html",
    "href": "reference/GT.sub_zero.html",
    "title": "GT.sub_zero",
    "section": "",
    "text": "GT.sub_zero(self, columns=None, rows=None, zero_text='nil')\nSubstitute zero values in the table body.\nWherever there is numerical data that are zero in value, replacement text may be better for explanatory purposes. The sub_zero() function allows for this replacement through its zero_text= argument."
  },
  {
    "objectID": "reference/GT.sub_zero.html#parameters",
    "href": "reference/GT.sub_zero.html#parameters",
    "title": "GT.sub_zero",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should be scanned for zeros. The default is all rows, resulting in all rows in all targeted columns being considered for this substitution. Alternatively, we can supply a list of row indices.\nNone\n\n\nzero_text\nstr\nThe text to be used in place of zero values in the rendered table. We can optionally use the md() or html() functions to style the text as Markdown or to retain HTML elements in the text.\n'nil'"
  },
  {
    "objectID": "reference/GT.sub_zero.html#returns",
    "href": "reference/GT.sub_zero.html#returns",
    "title": "GT.sub_zero",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.sub_zero.html#examples",
    "href": "reference/GT.sub_zero.html#examples",
    "title": "GT.sub_zero",
    "section": "Examples",
    "text": "Examples\nLet’s generate a simple table that contains an assortment of values that could potentially undergo some substitution via the sub_zero() method (i.e., there are two 0 values). The ordering of the fmt_scientific() and sub_zero() calls in the example below doesn’t affect the final result since any sub_*() method won’t interfere with the formatting of the table.\n\nfrom great_tables import GT\nimport polars as pl\n\nsingle_vals_df = pl.DataFrame(\n    {\n        \"i\": range(1, 8),\n        \"numbers\": [2.75, 0, -3.2, 8, 1e-10, 0, 2.6e9]\n    }\n)\n\nGT(single_vals_df).fmt_scientific(columns=\"numbers\").sub_zero()\n\n\n\n\n\n\n  i\n  numbers\n\n\n  \n    1\n    2.75\n  \n  \n    2\n    nil\n  \n  \n    3\n    −3.20\n  \n  \n    4\n    8.00\n  \n  \n    5\n    1.00 × 10−10\n  \n  \n    6\n    nil\n  \n  \n    7\n    2.60 × 109"
  },
  {
    "objectID": "reference/GT.opt_align_table_header.html",
    "href": "reference/GT.opt_align_table_header.html",
    "title": "GT.opt_align_table_header",
    "section": "",
    "text": "GT.opt_align_table_header(self, align='center')\nOption to align the table header.\nBy default, an added table header will have center alignment for both the title and the subtitle elements. This method allows us to easily set the horizontal alignment of the title and subtitle to the left, right, or center by using the \"align\" argument. This method serves as a convenient shortcut for gt.tab_options(heading_align=&lt;align&gt;)."
  },
  {
    "objectID": "reference/GT.opt_align_table_header.html#parameters",
    "href": "reference/GT.opt_align_table_header.html#parameters",
    "title": "GT.opt_align_table_header",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nalign\nstr\nThe alignment of the title and subtitle elements in the table header. Options are \"center\" (the default), \"left\", or \"right\".\n'center'"
  },
  {
    "objectID": "reference/GT.opt_align_table_header.html#returns",
    "href": "reference/GT.opt_align_table_header.html#returns",
    "title": "GT.opt_align_table_header",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.opt_align_table_header.html#examples",
    "href": "reference/GT.opt_align_table_header.html#examples",
    "title": "GT.opt_align_table_header",
    "section": "Examples",
    "text": "Examples\nUsing select columns from the exibble dataset, let’s create a table with a number of components added. Following that, we’ll align the header contents (consisting of the title and the subtitle) to the left with the opt_align_table_header() method.\n\nfrom great_tables import GT, exibble, md\n\n(\n  GT(\n    exibble[[\"num\", \"char\", \"currency\", \"row\", \"group\"]],\n    rowname_col=\"row\",\n    groupname_col=\"group\"\n  )\n  .tab_header(\n    title=md(\"Data listing from **exibble**\"),\n    subtitle=md(\"`exibble` is a **Great Tables** dataset.\")\n  )\n  .fmt_number(columns=\"num\")\n  .fmt_currency(columns=\"currency\")\n  .tab_source_note(source_note=\"This is only a subset of the dataset.\")\n  .opt_align_table_header(align=\"left\")\n)\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset."
  },
  {
    "objectID": "reference/vals.fmt_bytes.html",
    "href": "reference/vals.fmt_bytes.html",
    "title": "vals.fmt_bytes",
    "section": "",
    "text": "vals.fmt_bytes(x, standard='decimal', decimals=1, n_sigfig=None, drop_trailing_zeros=True, drop_trailing_dec_mark=True, use_seps=True, pattern='{x}', sep_mark=',', dec_mark='.', force_sign=False, incl_space=True, locale=None)\nFormat values as bytes.\nWith numeric values in a list, we can transform those to values of bytes with human readable units. The val_fmt_bytes() function allows for the formatting of byte sizes to either of two common representations: (1) with decimal units (powers of 1000, examples being \"kB\" and \"MB\"), and (2) with binary units (powers of 1024, examples being \"KiB\" and \"MiB\"). It is assumed the input numeric values represent the number of bytes and automatic truncation of values will occur. The numeric values will be scaled to be in the range of 1 to &lt;1000 and then decorated with the correct unit symbol according to the standard chosen. For more control over the formatting of byte sizes, we can use the following options:\n\ndecimals: choice of the number of decimal places, option to drop trailing zeros, and a choice of the decimal symbol\ndigit grouping separators: options to enable/disable digit separators and provide a choice of separator symbol\npattern: option to use a text pattern for decoration of the formatted values\nlocale-based formatting: providing a locale ID will result in number formatting specific to the chosen locale\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\nstandard\nstr\nThe form of expressing large byte sizes is divided between: (1) decimal units (powers of 1000; e.g., \"kB\" and \"MB\"), and (2) binary units (powers of 1024; e.g., \"KiB\" and \"MiB\"). The default is to use decimal units with the \"decimal\" option. The alternative is to use binary units with the \"binary\" option.\n'decimal'\n\n\ndecimals\nint\nThis corresponds to the exact number of decimal places to use. A value such as 2.34 can, for example, be formatted with 0 decimal places and it would result in \"2\". With 4 decimal places, the formatted value becomes \"2.3400\". The trailing zeros can be removed with drop_trailing_zeros=True.\n1\n\n\ndrop_trailing_zeros\nbool\nA boolean value that allows for removal of trailing zeros (those redundant zeros after the decimal mark).\nTrue\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nincl_space\nbool\nAn option for whether to include a space between the value and the currency symbol. The default is to not introduce a space character.\nTrue\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/vals.fmt_bytes.html#parameters",
    "href": "reference/vals.fmt_bytes.html#parameters",
    "title": "vals.fmt_bytes",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\nstandard\nstr\nThe form of expressing large byte sizes is divided between: (1) decimal units (powers of 1000; e.g., \"kB\" and \"MB\"), and (2) binary units (powers of 1024; e.g., \"KiB\" and \"MiB\"). The default is to use decimal units with the \"decimal\" option. The alternative is to use binary units with the \"binary\" option.\n'decimal'\n\n\ndecimals\nint\nThis corresponds to the exact number of decimal places to use. A value such as 2.34 can, for example, be formatted with 0 decimal places and it would result in \"2\". With 4 decimal places, the formatted value becomes \"2.3400\". The trailing zeros can be removed with drop_trailing_zeros=True.\n1\n\n\ndrop_trailing_zeros\nbool\nA boolean value that allows for removal of trailing zeros (those redundant zeros after the decimal mark).\nTrue\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nincl_space\nbool\nAn option for whether to include a space between the value and the currency symbol. The default is to not introduce a space character.\nTrue\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/vals.fmt_bytes.html#returns",
    "href": "reference/vals.fmt_bytes.html#returns",
    "title": "vals.fmt_bytes",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/loc.body.html",
    "href": "reference/loc.body.html",
    "title": "loc.body",
    "section": "",
    "text": "loc.body(columns=None, rows=None)\nA location specification for targeting data cells in the table body.\nThe loc.body() class is used to target the data cells in the table body. The class can be used to apply custom styling with the tab_style() method. That method has a locations argument and this class should be used there to perform the targeting.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nRowSelectExpr\nThe rows to target. Can either be a single row name or a series of row names provided in a list.\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nLocBody\nA LocBody object, which is used for a locations argument if specifying the table body."
  },
  {
    "objectID": "reference/loc.body.html#parameters",
    "href": "reference/loc.body.html#parameters",
    "title": "loc.body",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nRowSelectExpr\nThe rows to target. Can either be a single row name or a series of row names provided in a list.\nNone"
  },
  {
    "objectID": "reference/loc.body.html#returns",
    "href": "reference/loc.body.html#returns",
    "title": "loc.body",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nLocBody\nA LocBody object, which is used for a locations argument if specifying the table body."
  },
  {
    "objectID": "reference/GT.cols_hide.html",
    "href": "reference/GT.cols_hide.html",
    "title": "GT.cols_hide",
    "section": "",
    "text": "GT.cols_hide(data, columns)\nHide one or more columns.\nThe cols_hide() method allows us to hide one or more columns from appearing in the final output table. While it’s possible and often desirable to omit columns from the input table data before introduction to the GT() class, there can be cases where the data in certain columns is useful (as a column reference during formatting of other columns) but the final display of those columns is not necessary.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to hide in the output display table. Can either be a single column name or a series of column names provided in a list.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining.\n\n\n\n\n\n\nThe hiding of columns is internally a rendering directive, so, all columns that are ‘hidden’ are still accessible and useful in any expression provided to a rows argument. Furthermore, the cols_hide() method (as with many of the methods available in Great Tables) can be placed anywhere in a chain of calls (acting as a promise to hide columns when the timing is right). However there’s perhaps greater readability when placing this call closer to the end of such a chain. The cols_hide() method quietly changes the visible state of a column and doesn’t yield warnings when changing the state of already-invisible columns."
  },
  {
    "objectID": "reference/GT.cols_hide.html#parameters",
    "href": "reference/GT.cols_hide.html#parameters",
    "title": "GT.cols_hide",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to hide in the output display table. Can either be a single column name or a series of column names provided in a list.\nrequired"
  },
  {
    "objectID": "reference/GT.cols_hide.html#returns",
    "href": "reference/GT.cols_hide.html#returns",
    "title": "GT.cols_hide",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.cols_hide.html#details",
    "href": "reference/GT.cols_hide.html#details",
    "title": "GT.cols_hide",
    "section": "",
    "text": "The hiding of columns is internally a rendering directive, so, all columns that are ‘hidden’ are still accessible and useful in any expression provided to a rows argument. Furthermore, the cols_hide() method (as with many of the methods available in Great Tables) can be placed anywhere in a chain of calls (acting as a promise to hide columns when the timing is right). However there’s perhaps greater readability when placing this call closer to the end of such a chain. The cols_hide() method quietly changes the visible state of a column and doesn’t yield warnings when changing the state of already-invisible columns."
  },
  {
    "objectID": "reference/data.sza.html",
    "href": "reference/data.sza.html",
    "title": "data.sza",
    "section": "",
    "text": "data.sza\nTwice hourly solar zenith angles by month & latitude.\nThis dataset contains solar zenith angles (in degrees, with the range of 0-90) every half hour from 04:00 to 12:00, true solar time. This set of values is calculated on the first of every month for 4 different northern hemisphere latitudes. For determination of afternoon values, the presented tabulated values are symmetric about noon.\nThe solar zenith angle (SZA) is one measure that helps to describe the sun’s path across the sky. It’s defined as the angle of the sun relative to a line perpendicular to the earth’s surface. It is useful to calculate the SZA in relation to the true solar time. True solar time relates to the position of the sun with respect to the observer, which is different depending on the exact longitude. For example, two hours before the sun crosses the meridian (the highest point it would reach that day) corresponds to a true solar time of 10 a.m. The SZA has a strong dependence on the observer’s latitude. For example, at a latitude of 50 degrees N at the start of January, the noontime SZA is 73.0 but a different observer at 20 degrees N would measure the noontime SZA to be 43.0 degrees.\n\n\nThis is a dataset with 816 rows and 4 columns.\n\nlatitude: The latitude in decimal degrees for the observations.\n`month: The measurement month. All calculations where conducted for the first day of each month.\ntst: The true solar time at the givenlatitudeand date (first ofmonth`) for which the solar zenith angle is calculated.\nsza: The solar zenith angle in degrees, whereNAs indicate that sunrise hadn't yet occurred by thetst` value.\n\n\n\n\nCalculated Actinic Fluxes (290 - 700 nm) for Air Pollution Photochemistry Applications (Peterson, 1976), available at: https://nepis.epa.gov/Exe/ZyPURL.cgi?Dockey=9100JA26.txt."
  },
  {
    "objectID": "reference/data.sza.html#details",
    "href": "reference/data.sza.html#details",
    "title": "data.sza",
    "section": "",
    "text": "This is a dataset with 816 rows and 4 columns.\n\nlatitude: The latitude in decimal degrees for the observations.\n`month: The measurement month. All calculations where conducted for the first day of each month.\ntst: The true solar time at the givenlatitudeand date (first ofmonth`) for which the solar zenith angle is calculated.\nsza: The solar zenith angle in degrees, whereNAs indicate that sunrise hadn't yet occurred by thetst` value."
  },
  {
    "objectID": "reference/data.sza.html#source",
    "href": "reference/data.sza.html#source",
    "title": "data.sza",
    "section": "",
    "text": "Calculated Actinic Fluxes (290 - 700 nm) for Air Pollution Photochemistry Applications (Peterson, 1976), available at: https://nepis.epa.gov/Exe/ZyPURL.cgi?Dockey=9100JA26.txt."
  },
  {
    "objectID": "reference/GT.cols_label.html",
    "href": "reference/GT.cols_label.html",
    "title": "GT.cols_label",
    "section": "",
    "text": "GT.cols_label(self, **kwargs)\nRelabel one or more columns.\nColumn labels can be modified from their default values (the names of the columns from the input table data). When you create a table object using GT(), column names effectively become the column labels. While this serves as a good first approximation, column names aren’t often appealing as column labels in an output table. The cols_label() method provides the flexibility to relabel one or more columns and we even have the option to use the md() or html() helpers for rendering column labels from Markdown or using HTML.\nIt’s important to note that while columns can be freely relabeled, we continue to refer to columns by their names for targeting purposes. Column names in the input data table must be unique whereas column labels in Great Tables have no requirement for uniqueness (which is useful for labeling columns as, say, measurement units that may be repeated several times—usually under different spanner labels). Thus, we can still easily distinguish between columns in other method calls (e.g., in all of the fmt*() methods) even though we may lose distinguishability in column labels once they have been relabeled."
  },
  {
    "objectID": "reference/GT.cols_label.html#parameters",
    "href": "reference/GT.cols_label.html#parameters",
    "title": "GT.cols_label",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\n**kwargs\nAny\nThe column names and new labels. The column names are provided as keyword arguments and the new labels are provided as the values for those keyword arguments. For example, cols_label(col1=\"Column 1\", col2=\"Column 2\") would relabel columns col1 and col2 with the labels \"Column 1\" and \"Column 2\", respectively.\n{}"
  },
  {
    "objectID": "reference/GT.cols_label.html#returns",
    "href": "reference/GT.cols_label.html#returns",
    "title": "GT.cols_label",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.cols_label.html#examples",
    "href": "reference/GT.cols_label.html#examples",
    "title": "GT.cols_label",
    "section": "Examples",
    "text": "Examples\nLet’s use a portion of the countrypops dataset to create a table. We can relabel all the table’s columns with the cols_label() method to improve its presentation. In this simple case we are supplying the name of the column as the key, and the label text as the value.\n\nfrom great_tables import GT\nfrom great_tables.data import countrypops\n\ncountrypops_mini = countrypops.loc[countrypops[\"country_name\"] == \"Uganda\"][\n    [\"country_name\", \"year\", \"population\"]\n].tail(5)\n\n(\n    GT(countrypops_mini)\n    .cols_label(\n        country_name=\"Name\",\n        year=\"Year\",\n        population=\"Population\"\n    )\n)\n\n\n\n\n\n\n  Name\n  Year\n  Population\n\n\n  \n    Uganda\n    2018\n    41515395\n  \n  \n    Uganda\n    2019\n    42949080\n  \n  \n    Uganda\n    2020\n    44404611\n  \n  \n    Uganda\n    2021\n    45853778\n  \n  \n    Uganda\n    2022\n    47249585\n  \n\n\n\n\n\n\n        \n\n\nWe can also use Markdown formatting for the column labels. In this example, we’ll use md(\"*Population*\") to make the label italicized.\n\nfrom great_tables import GT, md\nfrom great_tables.data import countrypops\n\n(\n    GT(countrypops_mini)\n    .cols_label(\n        country_name=\"Name\",\n        year=\"Year\",\n        population=md(\"*Population*\")\n    )\n)\n\n\n\n\n\n\n  Name\n  Year\n  Population\n\n\n  \n    Uganda\n    2018\n    41515395\n  \n  \n    Uganda\n    2019\n    42949080\n  \n  \n    Uganda\n    2020\n    44404611\n  \n  \n    Uganda\n    2021\n    45853778\n  \n  \n    Uganda\n    2022\n    47249585"
  },
  {
    "objectID": "reference/data.metro.html",
    "href": "reference/data.metro.html",
    "title": "data.metro",
    "section": "",
    "text": "data.metro\nThe stations of the Paris Metro.\nA dataset with information on all 308 Paris Metro stations as of February 2023. Each record represents a station, describing which Metro lines are serviced by the station, which other connections are available, and annual passenger volumes. Basic location information is provided for each station in terms where they reside on a municipal level, and, through latitude/longitude coordinates.\nThe system has 16 lines (numbered from 1 to 14, with two additional lines: 3bis and 7bis) and covers over 200 kilometers of track. The Metro runs on standard gauge tracks (1,435 mm) and operates using a variety of rolling stock, including rubber-tired trains and steel-wheeled trains (which are far more common).\nThe Metro is operated by the RATP, which also operates other transit systems in the region, including buses, trams, and the RER. The RER is an important component of the region’s transit infrastructure, and several RER stations have connectivity with the Metro. This integration allows passengers to transfer between those two systems seamlessly. The Metro also has connections to the Transilien rail network, tramway stations, several major train stations (e.g., Gare du Nord, Gare de l’Est, etc.), and many bus lines.\n\n\nThis is a dataset with 308 rows and 11 columns.\n\nname: The name of the station.\ncaption: In some cases, a station will have a caption that might describe a nearby place of interest. This is missing if there isn’t a caption for the station name.\nlines: All Metro lines associated with the station. This is a character-based, comma-separated series of line names.\nconnect_rer: Station connections with the RER. The RER system has five lines (A, B, C, D, and E) with 257 stations and several interchanges with the Metro.\nconnect_tram: Connections with tramway lines. This system has twelve lines in operation (T1, T2, T3a, T3b, T4, T5, T6, T7, T8, T9, T11, and T13) with 235 stations.\nconnect_transilien: Connections with Transilien lines. This system has eight lines in operation (H, J, K, L, N, P, R, and U).\nconnect_other: Other connections with transportation infrastructure such as regional, intercity, night, and high-speed trains (typically at railway stations).\nlatitude, longitude: The location of the station, given as latitude and longitude values in decimal degrees.\nlocation: The arrondissement of Paris or municipality in which the station resides. For some stations located at borders, the grouping of locations will be presented as a comma-separated series.\npassengers: The total number of Metro station entries during 2021. Some of the newest stations in the Metro system do not have this data, thus they show as missing values."
  },
  {
    "objectID": "reference/data.metro.html#details",
    "href": "reference/data.metro.html#details",
    "title": "data.metro",
    "section": "",
    "text": "This is a dataset with 308 rows and 11 columns.\n\nname: The name of the station.\ncaption: In some cases, a station will have a caption that might describe a nearby place of interest. This is missing if there isn’t a caption for the station name.\nlines: All Metro lines associated with the station. This is a character-based, comma-separated series of line names.\nconnect_rer: Station connections with the RER. The RER system has five lines (A, B, C, D, and E) with 257 stations and several interchanges with the Metro.\nconnect_tram: Connections with tramway lines. This system has twelve lines in operation (T1, T2, T3a, T3b, T4, T5, T6, T7, T8, T9, T11, and T13) with 235 stations.\nconnect_transilien: Connections with Transilien lines. This system has eight lines in operation (H, J, K, L, N, P, R, and U).\nconnect_other: Other connections with transportation infrastructure such as regional, intercity, night, and high-speed trains (typically at railway stations).\nlatitude, longitude: The location of the station, given as latitude and longitude values in decimal degrees.\nlocation: The arrondissement of Paris or municipality in which the station resides. For some stations located at borders, the grouping of locations will be presented as a comma-separated series.\npassengers: The total number of Metro station entries during 2021. Some of the newest stations in the Metro system do not have this data, thus they show as missing values."
  },
  {
    "objectID": "reference/GT.opt_stylize.html",
    "href": "reference/GT.opt_stylize.html",
    "title": "GT.opt_stylize",
    "section": "",
    "text": "GT.opt_stylize(self, style=1, color='blue')\nStylize your table with a colorful look.\nWith the opt_stylize() method you can quickly style your table with a carefully curated set of background colors, line colors, and line styles. There are six styles to choose from and they largely vary in the extent of coloring applied to different table locations. Some have table borders applied, some apply darker colors to the table stub and summary sections, and, some even have vertical lines. In addition to choosing a style preset, there are six color variations that each use a range of five color tints. Each of the color tints have been fine-tuned to maximize the contrast between text and its background. There are 36 combinations of style and color to choose from."
  },
  {
    "objectID": "reference/GT.opt_stylize.html#parameters",
    "href": "reference/GT.opt_stylize.html#parameters",
    "title": "GT.opt_stylize",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstyle\nint\nSix numbered styles are available. Simply provide a number from 1 (the default) to 6 to choose a distinct look.\n1\n\n\ncolor\nstr\nThe color scheme of the table. The default value is \"blue\". The valid values are \"blue\", \"cyan\", \"pink\", \"green\", \"red\", and \"gray\".\n'blue'"
  },
  {
    "objectID": "reference/GT.opt_stylize.html#returns",
    "href": "reference/GT.opt_stylize.html#returns",
    "title": "GT.opt_stylize",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.opt_stylize.html#examples",
    "href": "reference/GT.opt_stylize.html#examples",
    "title": "GT.opt_stylize",
    "section": "Examples",
    "text": "Examples\nUsing select columns from the exibble dataset, let’s create a table with a number of components added. Following that, we’ll apply a predefined style to the table using the opt_stylize() method.\n\nfrom great_tables import GT, exibble, md\n\ngt_tbl = (\n      GT(\n        exibble[[\"num\", \"char\", \"currency\", \"row\", \"group\"]],\n        rowname_col=\"row\",\n        groupname_col=\"group\"\n      )\n      .tab_header(\n        title=md(\"Data listing from **exibble**\"),\n        subtitle=md(\"`exibble` is a **Great Tables** dataset.\")\n      )\n      .fmt_number(columns=\"num\")\n      .fmt_currency(columns=\"currency\")\n      .tab_source_note(source_note=\"This is only a subset of the dataset.\")\n      .opt_stylize()\n    )\n\ngt_tbl\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nThe table has been stylized with the default style and color. The default style is 1 and the default color is \"blue\". The resulting table style is a combination of color and border settings that are applied to the table.\nWe can modify the overall style and choose a different color theme by providing different values to the style= and color= arguments.\n\ngt_tbl.opt_stylize(style=2, color=\"green\")\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset."
  },
  {
    "objectID": "reference/GT.cols_move_to_start.html",
    "href": "reference/GT.cols_move_to_start.html",
    "title": "GT.cols_move_to_start",
    "section": "",
    "text": "GT.cols_move_to_start(data, columns)\nMove one or more columns to the start.\nWe can easily move set of columns to the beginning of the column series and we only need to specify which columns. It’s possible to do this upstream of Great Tables, however, it is easier with this method and it presents less possibility for error. The ordering of the columns that are moved to the start is preserved (same with the ordering of all other columns in the table).\nThe columns supplied in columns must all exist in the table. If you need to place one or columns at the end of the column series, the cols_move_to_end() method should be used. More control is offered with the cols_move() method, where columns could be placed after a specific column."
  },
  {
    "objectID": "reference/GT.cols_move_to_start.html#parameters",
    "href": "reference/GT.cols_move_to_start.html#parameters",
    "title": "GT.cols_move_to_start",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nrequired"
  },
  {
    "objectID": "reference/GT.cols_move_to_start.html#returns",
    "href": "reference/GT.cols_move_to_start.html#returns",
    "title": "GT.cols_move_to_start",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.cols_move_to_start.html#examples",
    "href": "reference/GT.cols_move_to_start.html#examples",
    "title": "GT.cols_move_to_start",
    "section": "Examples",
    "text": "Examples\nFor this example, we’ll use a portion of the countrypops dataset to create a simple table. Let’s move the year column, which is the middle column, to the start of the column series with the cols_move_to_start() method.\n\nfrom great_tables import GT\nfrom great_tables.data import countrypops\n\ncountrypops_mini = countrypops.loc[countrypops[\"country_name\"] == \"Fiji\"][\n    [\"country_name\", \"year\", \"population\"]\n].tail(5)\n\nGT(countrypops_mini).cols_move_to_start(columns=\"year\")\n\n\n\n\n\n\n  year\n  country_name\n  population\n\n\n  \n    2018\n    Fiji\n    918996\n  \n  \n    2019\n    Fiji\n    918465\n  \n  \n    2020\n    Fiji\n    920422\n  \n  \n    2021\n    Fiji\n    924610\n  \n  \n    2022\n    Fiji\n    929766\n  \n\n\n\n\n\n\n        \n\n\nWe can also move multiple columns at a time. With the same countrypops-based table (countrypops_mini), let’s move both the year and population columns to the start of the column series.\n\nGT(countrypops_mini).cols_move_to_start(columns=[\"year\", \"population\"])\n\n\n\n\n\n\n  year\n  population\n  country_name\n\n\n  \n    2018\n    918996\n    Fiji\n  \n  \n    2019\n    918465\n    Fiji\n  \n  \n    2020\n    920422\n    Fiji\n  \n  \n    2021\n    924610\n    Fiji\n  \n  \n    2022\n    929766\n    Fiji"
  },
  {
    "objectID": "reference/data.exibble.html",
    "href": "reference/data.exibble.html",
    "title": "data.exibble",
    "section": "",
    "text": "data.exibble\nA toy example table for testing with great_tables: exibble.\nThis table contains data of a few different classes, which makes it well-suited for quick experimentation with the functions in this package. It contains only eight rows with numeric and character columns. The last 4 rows contain missing values in the majority of this table’s columns (1 missing value per column). The date, time, and datetime columns are character-based dates/times in the familiar ISO 8601 format. The row and group columns provide for unique rownames and two groups (grp_a and grp_b) for experimenting with the rowname_col and groupname_col arguments.\n\n\nThis is a dataset with 8 rows and 9 columns.\n\nnum: A numeric column ordered with increasingly larger values.\nchar: A character column composed of names of fruits from a to h.\nfctr: A factor column with numbers from 1 to 8, written out.\ndate, time, datetime: Character columns with dates, times, and datetimes.\ncurrency: A numeric column that is useful for testing currency-based formatting.\nrow: A character column in the format row_X which can be useful for testing with row labels in a table stub.\ngroup: A character column with four grp_a values and four grp_b values which can be useful for testing tables that contain row groups."
  },
  {
    "objectID": "reference/data.exibble.html#details",
    "href": "reference/data.exibble.html#details",
    "title": "data.exibble",
    "section": "",
    "text": "This is a dataset with 8 rows and 9 columns.\n\nnum: A numeric column ordered with increasingly larger values.\nchar: A character column composed of names of fruits from a to h.\nfctr: A factor column with numbers from 1 to 8, written out.\ndate, time, datetime: Character columns with dates, times, and datetimes.\ncurrency: A numeric column that is useful for testing currency-based formatting.\nrow: A character column in the format row_X which can be useful for testing with row labels in a table stub.\ngroup: A character column with four grp_a values and four grp_b values which can be useful for testing tables that contain row groups."
  },
  {
    "objectID": "reference/data.countrypops.html",
    "href": "reference/data.countrypops.html",
    "title": "data.countrypops",
    "section": "",
    "text": "data.countrypops\nYearly populations of countries from 1960 to 2022.\nA dataset that presents yearly, total populations of countries. Total population is based on counts of all residents regardless of legal status or citizenship. Country identifiers include the English-language country names, and the 2- and 3-letter ISO 3166-1 country codes. Each row contains a population value for a given year (from 1960 to 2022). Any missing values for populations indicate the non-existence of the entity during that year.\n\n\nThis is a dataset with 13,545 rows and 5 columns.\n\ncountry_name: The name of the country.\ncountry_code_2, country_code_3: The 2- and 3-letter ISO 3166-1 country codes.\nyear: The year for the population estimate.\npopulation: The population estimate, midway through the year.\n\n\n\n\nhttps://data.worldbank.org/indicator/SP.POP.TOTL"
  },
  {
    "objectID": "reference/data.countrypops.html#details",
    "href": "reference/data.countrypops.html#details",
    "title": "data.countrypops",
    "section": "",
    "text": "This is a dataset with 13,545 rows and 5 columns.\n\ncountry_name: The name of the country.\ncountry_code_2, country_code_3: The 2- and 3-letter ISO 3166-1 country codes.\nyear: The year for the population estimate.\npopulation: The population estimate, midway through the year."
  },
  {
    "objectID": "reference/data.countrypops.html#source",
    "href": "reference/data.countrypops.html#source",
    "title": "data.countrypops",
    "section": "",
    "text": "https://data.worldbank.org/indicator/SP.POP.TOTL"
  },
  {
    "objectID": "reference/GT.opt_all_caps.html",
    "href": "reference/GT.opt_all_caps.html",
    "title": "GT.opt_all_caps",
    "section": "",
    "text": "GT.opt_all_caps(self, all_caps=True, locations=['column_labels', 'stub', 'row_group'])\nOption to use all caps in select table locations.\nSometimes an all-capitalized look is suitable for a table. By using opt_all_caps(), we can transform characters in the column labels, the stub, and in all row groups in this way (and there’s control over which of these locations are transformed). This method serves as a convenient shortcut for tab_options(&lt;location&gt;_text_transform=\"uppercase\", &lt;location&gt;_font_size=\"80%\", &lt;location&gt;_font_weight=\"bolder\") (for all locations selected)."
  },
  {
    "objectID": "reference/GT.opt_all_caps.html#parameters",
    "href": "reference/GT.opt_all_caps.html#parameters",
    "title": "GT.opt_all_caps",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nall_caps\nbool\nIndicates whether the text transformation to all caps should be performed (True, the default) or reset to default values (False) for the locations targeted.\nTrue\n\n\nlocations\nUnion[str, List[str]]\nWhich locations should undergo this text transformation? By default it includes all of the \"column_labels\", the \"stub\", and the \"row_group\" locations. However, we could just choose one or two of those.\n['column_labels', 'stub', 'row_group']"
  },
  {
    "objectID": "reference/GT.opt_all_caps.html#returns",
    "href": "reference/GT.opt_all_caps.html#returns",
    "title": "GT.opt_all_caps",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.opt_all_caps.html#examples",
    "href": "reference/GT.opt_all_caps.html#examples",
    "title": "GT.opt_all_caps",
    "section": "Examples",
    "text": "Examples\nUsing select columns from the exibble dataset, let’s create a table with a number of components added. Following that, we’ll ensure that all text in the column labels, the stub, and in all row groups is transformed to all caps using the opt_all_caps() method.\n\nfrom great_tables import GT, exibble, md\n\n(\n  GT(\n    exibble[[\"num\", \"char\", \"currency\", \"row\", \"group\"]],\n    rowname_col=\"row\",\n    groupname_col=\"group\"\n  )\n  .tab_header(\n    title=md(\"Data listing from **exibble**\"),\n    subtitle=md(\"`exibble` is a **Great Tables** dataset.\")\n  )\n  .fmt_number(columns=\"num\")\n  .fmt_currency(columns=\"currency\")\n  .tab_source_note(source_note=\"This is only a subset of the dataset.\")\n  .opt_all_caps()\n)\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset."
  },
  {
    "objectID": "reference/data.constants.html",
    "href": "reference/data.constants.html",
    "title": "data.constants",
    "section": "",
    "text": "data.constants\nThe fundamental physical constants.\nThis dataset contains values for over 300 basic fundamental constants in nature. The values originate from the 2018 adjustment which is based on the latest relevant precision measurements and improvements of theoretical calculations. Such work has been carried out under the authority of the Task Group on Fundamental Constants (TGFC) of the Committee on Data of the International Science Council (CODATA). These updated values became available on May 20, 2019. They are published at http://physics.nist.gov/constants, a website of the Fundamental Constants Data Center of the National Institute of Standards and Technology (NIST), Gaithersburg, Maryland, USA.\n\n\nThis is a dataset with 354 rows and 4 columns.\n\nname: The name of the constant.\nvalue: The value of the constant.\nuncert: The uncertainty associated with the value. If missing then the value is seen as an ‘exact’ value (e.g., an electron volt has the exact value of 1.602 176 634 e-19 J).\nsf_value, sf_uncert: The number of significant figures associated with the value and any uncertainty value.\nunits: The units associated with the constant."
  },
  {
    "objectID": "reference/data.constants.html#details",
    "href": "reference/data.constants.html#details",
    "title": "data.constants",
    "section": "",
    "text": "This is a dataset with 354 rows and 4 columns.\n\nname: The name of the constant.\nvalue: The value of the constant.\nuncert: The uncertainty associated with the value. If missing then the value is seen as an ‘exact’ value (e.g., an electron volt has the exact value of 1.602 176 634 e-19 J).\nsf_value, sf_uncert: The number of significant figures associated with the value and any uncertainty value.\nunits: The units associated with the constant."
  },
  {
    "objectID": "reference/data.gtcars.html",
    "href": "reference/data.gtcars.html",
    "title": "data.gtcars",
    "section": "",
    "text": "data.gtcars\nDeluxe automobiles from the 2014-2017 period.\nExpensive and fast cars. Each row describes a car of a certain make, model, year, and trim. Basic specifications such as horsepower, torque, EPA MPG ratings, type of drivetrain, and transmission characteristics are provided. The country of origin for the car manufacturer is also given.\nAll of the gtcars have something else in common (aside from the high asking prices): they are all grand tourer vehicles. These are proper GT cars that blend pure driving thrills with a level of comfort that is more expected from a fine limousine (e.g., a Rolls-Royce Phantom EWB). You’ll find that, with these cars, comfort is emphasized over all-out performance. Nevertheless, the driving experience should also mean motoring at speed, doing so in style and safety.\n\n\nThis is a dataset with 47 rows and 15 columns.\n\nmfr: `The name of the car manufacturer.\nmodel: The car’s model name.\nyear: The car’s model year.\ntrim: A short description of the car model’s trim.\nbdy_style: An identifier of the car’s body style, which is either \"coupe\", \"convertible\", \"sedan\", or \"hatchback\".\nhp, hp_rpm: The car’s horsepower and the associated RPM level.\ntrq, trq_rpm: The car’s torque and the associated RPM level.\nmpg_c, mpg_h: The miles per gallon fuel efficiency rating for city and highway driving.\ndrivetrain: The car’s drivetrain which, for this dataset, is either \"rwd\" (Rear Wheel Drive) or \"awd\" (All Wheel Drive).\ntrsmn: An encoding of the transmission type, where the number part is the number of gears. The car could have automatic transmission (\"a\"), manual transmission (\"m\"), an option to switch between both types (\"am\"), or, direct drive (\"dd\")\nctry_origin: The country name for where the vehicle manufacturer is headquartered.\nmsrp: Manufacturer’s suggested retail price in U.S. dollars (USD)."
  },
  {
    "objectID": "reference/data.gtcars.html#details",
    "href": "reference/data.gtcars.html#details",
    "title": "data.gtcars",
    "section": "",
    "text": "This is a dataset with 47 rows and 15 columns.\n\nmfr: `The name of the car manufacturer.\nmodel: The car’s model name.\nyear: The car’s model year.\ntrim: A short description of the car model’s trim.\nbdy_style: An identifier of the car’s body style, which is either \"coupe\", \"convertible\", \"sedan\", or \"hatchback\".\nhp, hp_rpm: The car’s horsepower and the associated RPM level.\ntrq, trq_rpm: The car’s torque and the associated RPM level.\nmpg_c, mpg_h: The miles per gallon fuel efficiency rating for city and highway driving.\ndrivetrain: The car’s drivetrain which, for this dataset, is either \"rwd\" (Rear Wheel Drive) or \"awd\" (All Wheel Drive).\ntrsmn: An encoding of the transmission type, where the number part is the number of gears. The car could have automatic transmission (\"a\"), manual transmission (\"m\"), an option to switch between both types (\"am\"), or, direct drive (\"dd\")\nctry_origin: The country name for where the vehicle manufacturer is headquartered.\nmsrp: Manufacturer’s suggested retail price in U.S. dollars (USD)."
  },
  {
    "objectID": "reference/style.fill.html",
    "href": "reference/style.fill.html",
    "title": "style.fill",
    "section": "",
    "text": "style.fill(color)\nA style specification for the background fill of targeted cells.\nThe style.fill() class is to be used with the tab_style() method, which itself allows for the setting of custom styles to one or more cells. Specifically, the call to style.fill() should be bound to the styles argument of tab_style().\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolor\nstr | ColumnExpr\nThe color to use for the cell background fill. This can be any valid CSS color value, such as a hex code, a named color, or an RGB value.\nrequired\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nCellStyleFill\nA CellStyleFill object, which is used for a styles argument if specifying a cell fill value."
  },
  {
    "objectID": "reference/style.fill.html#parameters",
    "href": "reference/style.fill.html#parameters",
    "title": "style.fill",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ncolor\nstr | ColumnExpr\nThe color to use for the cell background fill. This can be any valid CSS color value, such as a hex code, a named color, or an RGB value.\nrequired"
  },
  {
    "objectID": "reference/style.fill.html#returns",
    "href": "reference/style.fill.html#returns",
    "title": "style.fill",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nCellStyleFill\nA CellStyleFill object, which is used for a styles argument if specifying a cell fill value."
  },
  {
    "objectID": "reference/GT.fmt_date.html",
    "href": "reference/GT.fmt_date.html",
    "title": "GT.fmt_date",
    "section": "",
    "text": "GT.fmt_date(self, columns=None, rows=None, date_style='iso', pattern='{x}', locale=None)\nFormat values as dates.\nFormat input values to time values using one of 17 preset date styles. Input can be in the form of date type or as a ISO-8601 string (in the form of YYYY-MM-DD HH:MM:SS or YYYY-MM-DD)."
  },
  {
    "objectID": "reference/GT.fmt_date.html#parameters",
    "href": "reference/GT.fmt_date.html#parameters",
    "title": "GT.fmt_date",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in targeted columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\ndate_style\nDateStyle\nThe date style to use. By default this is the short name \"iso\" which corresponds to ISO 8601 date formatting. There are 41 date styles in total and their short names can be viewed using info_date_style().\n'iso'\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/GT.fmt_date.html#formatting-with-the-date_style-argument",
    "href": "reference/GT.fmt_date.html#formatting-with-the-date_style-argument",
    "title": "GT.fmt_date",
    "section": "Formatting With The Date_Style Argument",
    "text": "Formatting With The Date_Style Argument\nWe need to supply a preset date style to the date_style argument. The date styles are numerous and can handle localization to any supported locale. The following table provides a listing of all date styles and their output values (corresponding to an input date of 2000-02-29).\n\n\n\n\nDate Style\nOutput\n\n\n\n\n1\n\"iso\"\n\"2000-02-29\"\n\n\n2\n\"wday_month_day_year\"\n\"Tuesday, February 29, 2000\"\n\n\n3\n\"wd_m_day_year\"\n\"Tue, Feb 29, 2000\"\n\n\n4\n\"wday_day_month_year\"\n\"Tuesday 29 February 2000\"\n\n\n5\n\"month_day_year\"\n\"February 29, 2000\"\n\n\n6\n\"m_day_year\"\n\"Feb 29, 2000\"\n\n\n7\n\"day_m_year\"\n\"29 Feb 2000\"\n\n\n8\n\"day_month_year\"\n\"29 February 2000\"\n\n\n9\n\"day_month\"\n\"29 February\"\n\n\n10\n\"day_m\"\n\"29 Feb\"\n\n\n11\n\"year\"\n\"2000\"\n\n\n12\n\"month\"\n\"February\"\n\n\n13\n\"day\"\n\"29\"\n\n\n14\n\"year.mn.day\"\n\"2000/02/29\"\n\n\n15\n\"y.mn.day\"\n\"00/02/29\"\n\n\n16\n\"year_week\"\n\"2000-W09\"\n\n\n17\n\"year_quarter\"\n\"2000-Q1\"\n\n\n\nWe can use the info_date_style() function within the console to view a similar table of date styles with example output."
  },
  {
    "objectID": "reference/GT.fmt_date.html#returns",
    "href": "reference/GT.fmt_date.html#returns",
    "title": "GT.fmt_date",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.fmt_date.html#adapting-output-to-a-specific-locale",
    "href": "reference/GT.fmt_date.html#adapting-output-to-a-specific-locale",
    "title": "GT.fmt_date",
    "section": "Adapting Output To A Specific Locale",
    "text": "Adapting Output To A Specific Locale\nThis formatting method can adapt outputs according to a provided locale value. Examples include \"en\" for English (United States) and \"fr\" for French (France). Note that a locale value provided here will override any global locale setting performed in GT()’s own locale argument (it is settable there as a value received by all other methods that have a locale argument)."
  },
  {
    "objectID": "reference/GT.fmt_date.html#examples",
    "href": "reference/GT.fmt_date.html#examples",
    "title": "GT.fmt_date",
    "section": "Examples",
    "text": "Examples\nLet’s use the exibble dataset to create a simple, two-column table (keeping only the date and time columns). With the fmt_date() method, we’ll format the date column to display dates formatted with the \"month_day_year\" date style.\n\nfrom great_tables import GT, exibble\n\nexibble_mini = exibble[[\"date\", \"time\"]]\n\n(\n    GT(exibble_mini)\n    .fmt_date(columns=\"date\", date_style=\"month_day_year\")\n)\n\n\n\n\n\n\n  date\n  time\n\n\n  \n    January 15, 2015\n    13:35\n  \n  \n    February 15, 2015\n    14:40\n  \n  \n    March 15, 2015\n    15:45\n  \n  \n    April 15, 2015\n    16:50\n  \n  \n    May 15, 2015\n    17:55\n  \n  \n    June 15, 2015\n    \n  \n  \n    \n    19:10\n  \n  \n    August 15, 2015\n    20:20"
  },
  {
    "objectID": "reference/GT.fmt_date.html#see-also",
    "href": "reference/GT.fmt_date.html#see-also",
    "title": "GT.fmt_date",
    "section": "See Also",
    "text": "See Also\nThe functional version of this method, val_fmt_date(), allows you to format a single numerical value (or a list of them)."
  },
  {
    "objectID": "reference/data.sp500.html",
    "href": "reference/data.sp500.html",
    "title": "data.sp500",
    "section": "",
    "text": "data.sp500\nDaily S&P 500 Index data from 1950 to 2015.\nThis dataset provides daily price indicators for the S&P 500 index from the beginning of 1950 to the end of 2015. The index includes 500 leading companies and captures about 80 percent coverage of available market capitalization.\n\n\nThis is a dataset with 16,607 rows and 7 columns.\ndate: The date expressed as Date values. open, high, low, close: The day’s opening, high, low, and closing prices in USD. The close price is adjusted for splits. volume: The number of trades for the given date. adj_close: The close price adjusted for both dividends and splits."
  },
  {
    "objectID": "reference/data.sp500.html#details",
    "href": "reference/data.sp500.html#details",
    "title": "data.sp500",
    "section": "",
    "text": "This is a dataset with 16,607 rows and 7 columns.\ndate: The date expressed as Date values. open, high, low, close: The day’s opening, high, low, and closing prices in USD. The close price is adjusted for splits. volume: The number of trades for the given date. adj_close: The close price adjusted for both dividends and splits."
  },
  {
    "objectID": "reference/data.towny.html",
    "href": "reference/data.towny.html",
    "title": "data.towny",
    "section": "",
    "text": "data.towny\nPopulations of all municipalities in Ontario from 1996 to 2021.\nA dataset containing census population data from six census years (1996 to 2021) for all 414 of Ontario’s local municipalities. The Municipal Act of Ontario (2001) defines a local municipality as “a single-tier municipality or a lower-tier municipality”. There are 173 single-tier municipalities and 241 lower-tier municipalities representing 99 percent of Ontario’s population and 17 percent of its land use.\nIn the towny dataset we include information specific to each municipality such as location (in the latitude and longitude columns), their website URLs, their classifications, and land area sizes according to 2021 boundaries. Additionally, there are computed columns containing population density values for each census year and population change values from adjacent census years.\n\n\nThis is a dataset with 414 rows and 25 columns.\n\nname: The name of the municipality.\nwebsite: The website for the municipality. This is missing if there isn’t an official site.\nstatus: The status of the municipality. This is either \"lower-tier\" or \"single-tier\". A single-tier municipality, which takes on all municipal duties outlined in the Municipal Act and other Provincial laws, is independent of an upper-tier municipality. Part of an upper-tier municipality is a lower-tier municipality. The upper-tier and lower-tier municipalities are responsible for carrying out the duties laid out in the Municipal Act and other provincial laws.\ncsd_type: The Census Subdivision Type. This can be one of \"village\", \"town\", \"township\", \"municipality\", or \"city\".\ncensus_div: The Census division, of which there are 49. This is made up of single-tier municipalities, regional municipalities, counties, and districts.\nlatitude, longitude: The location of the municipality, given as latitude and longitude values in decimal degrees.\nland_area_km2: The total area of the local municipality in square kilometers.\npopulation_1996, population_2001, population_2006, population_2011, population_2016, population_2021: Population values for each municipality from the 1996 to 2021 census years.\ndensity_1996, density_2001, density_2006, density_2011, density_2016, density_2021: Population density values, calculated as persons per square kilometer, for each municipality from the 1996 to 2021 census years.\npop_change_1996_2001_pct, pop_change_2001_2006_pct, pop_change_2006_2011_pct, pop_change_2011_2016_pct, pop_change_2016_2021_pct: Population changes between adjacent pairs of census years, from 1996 to 2021."
  },
  {
    "objectID": "reference/data.towny.html#details",
    "href": "reference/data.towny.html#details",
    "title": "data.towny",
    "section": "",
    "text": "This is a dataset with 414 rows and 25 columns.\n\nname: The name of the municipality.\nwebsite: The website for the municipality. This is missing if there isn’t an official site.\nstatus: The status of the municipality. This is either \"lower-tier\" or \"single-tier\". A single-tier municipality, which takes on all municipal duties outlined in the Municipal Act and other Provincial laws, is independent of an upper-tier municipality. Part of an upper-tier municipality is a lower-tier municipality. The upper-tier and lower-tier municipalities are responsible for carrying out the duties laid out in the Municipal Act and other provincial laws.\ncsd_type: The Census Subdivision Type. This can be one of \"village\", \"town\", \"township\", \"municipality\", or \"city\".\ncensus_div: The Census division, of which there are 49. This is made up of single-tier municipalities, regional municipalities, counties, and districts.\nlatitude, longitude: The location of the municipality, given as latitude and longitude values in decimal degrees.\nland_area_km2: The total area of the local municipality in square kilometers.\npopulation_1996, population_2001, population_2006, population_2011, population_2016, population_2021: Population values for each municipality from the 1996 to 2021 census years.\ndensity_1996, density_2001, density_2006, density_2011, density_2016, density_2021: Population density values, calculated as persons per square kilometer, for each municipality from the 1996 to 2021 census years.\npop_change_1996_2001_pct, pop_change_2001_2006_pct, pop_change_2006_2011_pct, pop_change_2011_2016_pct, pop_change_2016_2021_pct: Population changes between adjacent pairs of census years, from 1996 to 2021."
  },
  {
    "objectID": "reference/GT.fmt_percent.html",
    "href": "reference/GT.fmt_percent.html",
    "title": "GT.fmt_percent",
    "section": "",
    "text": "GT.fmt_percent(self, columns=None, rows=None, decimals=2, drop_trailing_zeros=False, drop_trailing_dec_mark=True, scale_values=True, use_seps=True, pattern='{x}', sep_mark=',', dec_mark='.', force_sign=False, placement='right', incl_space=False, locale=None)\nFormat values as a percentage.\nWith numeric values in a gt table, we can perform percentage-based formatting. It is assumed the input numeric values are proportional values and, in this case, the values will be automatically multiplied by 100 before decorating with a percent sign (the other case is accommodated though setting scale_values to False). For more control over percentage formatting, we can use the following options:\n\npercent sign placement: the percent sign can be placed after or before the values and a space can be inserted between the symbol and the value.\ndecimals: choice of the number of decimal places, option to drop trailing zeros, and a choice of the decimal symbol\ndigit grouping separators: options to enable/disable digit separators and provide a choice of separator symbol\nvalue scaling toggle: choose to disable automatic value scaling in the situation that values are already scaled coming in (and just require the percent symbol)\npattern: option to use a text pattern for decoration of the formatted values\nlocale-based formatting: providing a locale ID will result in number formatting specific to the chosen locale\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in targeted columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\ndecimals\nint\nThe decimals values corresponds to the exact number of decimal places to use. A value such as 2.34 can, for example, be formatted with 0 decimal places and it would result in \"2\". With 4 decimal places, the formatted value becomes \"2.3400\". The trailing zeros can be removed with drop_trailing_zeros=True.\n2\n\n\ndrop_trailing_zeros\nbool\nA boolean value that allows for removal of trailing zeros (those redundant zeros after the decimal mark).\nFalse\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nscale_values\nbool\nShould the values be scaled through multiplication by 100? By default this scaling is performed since the expectation is that incoming values are usually proportional. Setting to False signifies that the values are already scaled and require only the percent sign when formatted.\nTrue\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nplacement\nstr\nThis option governs the placement of the percent sign. This can be either be \"right\" (the default) or \"left\".\n'right'\n\n\nincl_space\nbool\nAn option for whether to include a space between the value and the percent sign. The default is to not introduce a space character.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining.\n\n\n\n\n\n\nThis formatting method can adapt outputs according to a provided locale value. Examples include \"en\" for English (United States) and \"fr\" for French (France). The use of a valid locale ID here means separator and decimal marks will be correct for the given locale. Should any values be provided in sep_mark or dec_mark, they will be overridden by the locale’s preferred values.\nNote that a locale value provided here will override any global locale setting performed in GT()’s own locale argument (it is settable there as a value received by all other methods that have a locale argument).\n\n\n\nThe functional version of this method, val_fmt_percent(), allows you to format a single numerical value (or a list of them)."
  },
  {
    "objectID": "reference/GT.fmt_percent.html#parameters",
    "href": "reference/GT.fmt_percent.html#parameters",
    "title": "GT.fmt_percent",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in targeted columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\ndecimals\nint\nThe decimals values corresponds to the exact number of decimal places to use. A value such as 2.34 can, for example, be formatted with 0 decimal places and it would result in \"2\". With 4 decimal places, the formatted value becomes \"2.3400\". The trailing zeros can be removed with drop_trailing_zeros=True.\n2\n\n\ndrop_trailing_zeros\nbool\nA boolean value that allows for removal of trailing zeros (those redundant zeros after the decimal mark).\nFalse\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nscale_values\nbool\nShould the values be scaled through multiplication by 100? By default this scaling is performed since the expectation is that incoming values are usually proportional. Setting to False signifies that the values are already scaled and require only the percent sign when formatted.\nTrue\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nplacement\nstr\nThis option governs the placement of the percent sign. This can be either be \"right\" (the default) or \"left\".\n'right'\n\n\nincl_space\nbool\nAn option for whether to include a space between the value and the percent sign. The default is to not introduce a space character.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/GT.fmt_percent.html#returns",
    "href": "reference/GT.fmt_percent.html#returns",
    "title": "GT.fmt_percent",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.fmt_percent.html#adapting-output-to-a-specific-locale",
    "href": "reference/GT.fmt_percent.html#adapting-output-to-a-specific-locale",
    "title": "GT.fmt_percent",
    "section": "",
    "text": "This formatting method can adapt outputs according to a provided locale value. Examples include \"en\" for English (United States) and \"fr\" for French (France). The use of a valid locale ID here means separator and decimal marks will be correct for the given locale. Should any values be provided in sep_mark or dec_mark, they will be overridden by the locale’s preferred values.\nNote that a locale value provided here will override any global locale setting performed in GT()’s own locale argument (it is settable there as a value received by all other methods that have a locale argument)."
  },
  {
    "objectID": "reference/GT.fmt_percent.html#see-also",
    "href": "reference/GT.fmt_percent.html#see-also",
    "title": "GT.fmt_percent",
    "section": "",
    "text": "The functional version of this method, val_fmt_percent(), allows you to format a single numerical value (or a list of them)."
  },
  {
    "objectID": "blog/introduction_great_tables.html",
    "href": "blog/introduction_great_tables.html",
    "title": "Introducing Great Tables",
    "section": "",
    "text": "We are really excited about developing the Great Tables package because we believe it’ll make great-looking display tables possible in Python. Though it’s still early days for the project/package, you can do good things with it today! The most recent version of Great Tables is in PyPI. You can install it by using:\nIn this short post, we’ll take a look at a few examples that focus on the more common table-making use cases. We’ll show you how to:\nAlright! Let’s get right into it."
  },
  {
    "objectID": "blog/introduction_great_tables.html#a-basic-table",
    "href": "blog/introduction_great_tables.html#a-basic-table",
    "title": "Introducing Great Tables",
    "section": "A Basic Table",
    "text": "A Basic Table\nLet’s get right to making a display table with Great Tables. The package has quite a few datasets and so we’ll start by making use of the very small, but useful, exibble dataset. After importing the GT class and that dataset, we’ll introduce that Pandas table to GT().\n\nfrom great_tables import GT, exibble\n\n# Create a display table with the `exibble` dataset\ngt_tbl = GT(exibble)\n\n# Now, show the gt table\ngt_tbl\n\n\n\n\n\n\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n  row\n  group\n\n\n  \n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n    row_1\n    grp_a\n  \n  \n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n    row_2\n    grp_a\n  \n  \n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n    row_3\n    grp_a\n  \n  \n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n    row_4\n    grp_a\n  \n  \n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n    row_5\n    grp_b\n  \n  \n    \n    fig\n    six\n    2015-06-15\n    \n    2018-06-06 16:11\n    13.255\n    row_6\n    grp_b\n  \n  \n    777000.0\n    grapefruit\n    seven\n    \n    19:10\n    2018-07-07 05:22\n    \n    row_7\n    grp_b\n  \n  \n    8880000.0\n    honeydew\n    eight\n    2015-08-15\n    20:20\n    \n    0.44\n    row_8\n    grp_b\n  \n\n\n\n\n\n\n        \n\n\nThat looks pretty good! Indeed, it is a basic table but we really didn’t really ask for much either. What we did get was an HTML table containing column labels and all of the body cells. You’ll probably be wanting a bit more, so, let’s look at how we can incorporate more table components and perform cell data formatting in the upcoming examples."
  },
  {
    "objectID": "blog/introduction_great_tables.html#more-complex-tables",
    "href": "blog/introduction_great_tables.html#more-complex-tables",
    "title": "Introducing Great Tables",
    "section": "More Complex Tables",
    "text": "More Complex Tables\nLet’s take things a bit further and create a table with the included gtcars dataset. Great Tables provides a large selection of methods and they let you refine the table display. They were designed so that you can easily create a really presentable and beautiful table visualization.\nFor this next table, we’ll incorporate a Stub component and this provides a place for the row labels. Groupings of rows will be generated through categorical values in a particular column (we just have to cite the column name for that to work). We’ll add a table title and subtitle with tab_header(). The numerical values will be formatted with the fmt_integer() and fmt_currency() methods. Column labels will be enhanced via cols_label() and a source note will be included through use of the tab_source_note() method. Here is the table code, followed by the table itself.\n\nfrom great_tables import GT, md, html\nfrom great_tables.data import gtcars\n\ngtcars_mini = gtcars[[\"mfr\", \"model\", \"year\", \"hp\", \"trq\", \"msrp\"]].tail(10)\n\n(\n    GT(gtcars_mini, rowname_col=\"model\", groupname_col=\"mfr\")\n    .tab_spanner(label=md(\"*Performance*\"), columns=[\"hp\", \"trq\"])\n    .tab_header(\n        title=html(\"Data listing from &lt;strong&gt;gtcars&lt;/strong&gt;\"),\n        subtitle=html(\"A &lt;span style='font-size:12px;'&gt;small selection&lt;/span&gt; of great cars.\"),\n    )\n    .cols_label(year=\"Year Produced\", hp=\"HP\", trq=\"Torque\", msrp=\"Price (USD)\")\n    .fmt_integer(columns=[\"year\", \"hp\", \"trq\"], use_seps=False)\n    .fmt_currency(columns=\"msrp\")\n    .tab_source_note(source_note=\"Source: the gtcars dataset within the Great Tables package.\")\n)\n\n\n\n\n\n  \n    Data listing from gtcars\n  \n  \n    A small selection of great cars.\n  \n\n\n  \n  Year Produced\n  \n    Performance\n  \n  Price (USD)\n\n\n  HP\n  Torque\n\n\n  \n    Mercedes-Benz\n  \n  \n    AMG GT\n    2016\n    503\n    479\n    $129,900.00\n  \n  \n    SL-Class\n    2016\n    329\n    354\n    $85,050.00\n  \n  \n    Tesla\n  \n  \n    Model S\n    2017\n    259\n    243\n    $74,500.00\n  \n  \n    Porsche\n  \n  \n    718 Boxster\n    2017\n    300\n    280\n    $56,000.00\n  \n  \n    718 Cayman\n    2017\n    300\n    280\n    $53,900.00\n  \n  \n    911\n    2016\n    350\n    287\n    $84,300.00\n  \n  \n    Panamera\n    2016\n    310\n    295\n    $78,100.00\n  \n  \n    McLaren\n  \n  \n    570\n    2016\n    570\n    443\n    $184,900.00\n  \n  \n    Rolls-Royce\n  \n  \n    Dawn\n    2016\n    563\n    575\n    $335,000.00\n  \n  \n    Wraith\n    2016\n    624\n    590\n    $304,350.00\n  \n\n  \n  \n  \n    Source: the gtcars dataset within the Great Tables package.\n  \n\n\n\n\n\n\n        \n\n\nWith the six different methods applied, the table looks highly presentable! The rendering you’re seeing here has been done through Quarto (this entire site has been generated with quartodoc). If you haven’t yet tried out Quarto, we highly recommend it!\nFor this next example we’ll use the airquality dataset (also included in the package; it’s inside the data submodule). With this table, two spanners will be added with the tab_spanner() method. This method is meant to be easy to use, you only need to provide the text for the spanner label and the columns associated with the spanner. We also make it easy to move columns around. You can use cols_move_to_start() (example of that below) and there are also the cols_move_to_end() and cols_move() methods.\n\nfrom great_tables.data import airquality\n\nairquality_mini = airquality.head(10).assign(Year=1973)\n\n(\n    GT(airquality_mini)\n    .tab_header(\n        title=\"New York Air Quality Measurements\",\n        subtitle=\"Daily measurements in New York City (May 1-10, 1973)\",\n    )\n    .cols_label(\n        Ozone=html(\"Ozone,&lt;br&gt;ppbV\"),\n        Solar_R=html(\"Solar R.,&lt;br&gt;cal/m&lt;sup&gt;2&lt;/sup&gt;\"),\n        Wind=html(\"Wind,&lt;br&gt;mph\"),\n        Temp=html(\"Temp,&lt;br&gt;&deg;F\"),\n    )\n    .tab_spanner(label=\"Date\", columns=[\"Year\", \"Month\", \"Day\"])\n    .tab_spanner(label=\"Measurement\", columns=[\"Ozone\", \"Solar.R\", \"Wind\", \"Temp\"])\n    .cols_move_to_start(columns=[\"Year\", \"Month\", \"Day\"])\n)\n\n\n\n\n\n  \n    New York Air Quality Measurements\n  \n  \n    Daily measurements in New York City (May 1-10, 1973)\n  \n\n\n  \n    Date\n  \n  \n    Measurement\n  \n  Solar R.,cal/m2\n\n\n  Year\n  Month\n  Day\n  Ozone,ppbV\n  Wind,mph\n  Temp,°F\n\n\n  \n    1973\n    5\n    1\n    41.0\n    7.4\n    67\n    190.0\n  \n  \n    1973\n    5\n    2\n    36.0\n    8.0\n    72\n    118.0\n  \n  \n    1973\n    5\n    3\n    12.0\n    12.6\n    74\n    149.0\n  \n  \n    1973\n    5\n    4\n    18.0\n    11.5\n    62\n    313.0\n  \n  \n    1973\n    5\n    5\n    \n    14.3\n    56\n    \n  \n  \n    1973\n    5\n    6\n    28.0\n    14.9\n    66\n    \n  \n  \n    1973\n    5\n    7\n    23.0\n    8.6\n    65\n    299.0\n  \n  \n    1973\n    5\n    8\n    19.0\n    13.8\n    59\n    99.0\n  \n  \n    1973\n    5\n    9\n    8.0\n    20.1\n    61\n    19.0\n  \n  \n    1973\n    5\n    10\n    \n    8.6\n    69\n    194.0\n  \n\n\n\n\n\n\n        \n\n\nThat table looks really good, and the nice thing about all these methods is that they can be used in virtually any order."
  },
  {
    "objectID": "blog/introduction_great_tables.html#formatting-table-cells",
    "href": "blog/introduction_great_tables.html#formatting-table-cells",
    "title": "Introducing Great Tables",
    "section": "Formatting Table Cells",
    "text": "Formatting Table Cells\nWe didn’t want to skimp on formatting methods for table cells with this early release. There are 12 fmt_*() methods available right now:\n\nfmt_number(): format numeric values\nfmt_integer(): format values as integers\nfmt_percent(): format values as percentages\nfmt_scientific(): format values to scientific notation\nfmt_currency(): format values as currencies\nfmt_bytes(): format values as bytes\nfmt_roman(): format values as Roman numerals\nfmt_date(): format values as dates\nfmt_time(): format values as times\nfmt_datetime(): format values as datetimes\nfmt_markdown(): format Markdown text\nfmt(): set a column format with a formatting function\n\nWe strive to make formatting a simple task but we also want to provide the user a lot of power through advanced options and we ensure that varied combinations of options works well. For example, most of the formatting methods have a locale= argument. We want as many users as possible to be able to format numbers, dates, and times in ways that are familiar to them and are adapted to their own regional specifications. Now let’s take a look at an example of this with a smaller version of the exibble dataset:\n\nexibble_smaller = exibble[[\"date\", \"time\"]].head(4)\n\n(\n    GT(exibble_smaller)\n    .fmt_date(columns=\"date\", date_style=\"wday_month_day_year\")\n    .fmt_date(columns=\"date\", rows=[2, 3], date_style=\"day_month_year\", locale=\"de-CH\")\n    .fmt_time(columns=\"time\", time_style=\"h_m_s_p\")\n)\n\n\n\n\n\n\n  date\n  time\n\n\n  \n    Thursday, January 15, 2015\n    1:35:00 PM\n  \n  \n    Sunday, February 15, 2015\n    2:40:00 PM\n  \n  \n    15 März 2015\n    3:45:00 PM\n  \n  \n    15 April 2015\n    4:50:00 PM\n  \n\n\n\n\n\n\n        \n\n\nWe support hundreds of locales, from af to zu! While there are more formatting methods yet to be added, the ones that are available all work exceedingly well."
  },
  {
    "objectID": "blog/introduction_great_tables.html#using-styles-within-a-table",
    "href": "blog/introduction_great_tables.html#using-styles-within-a-table",
    "title": "Introducing Great Tables",
    "section": "Using Styles within a Table",
    "text": "Using Styles within a Table\nWe can use the tab_style() method in combination with loc.body() and various style.*() functions to set styles on cells of data within the table body. For example, the table-making code below applies a yellow background color to the targeted cells.\n\nfrom great_tables import GT, style, loc\nfrom great_tables.data import airquality\n\nairquality_mini = airquality.head()\n\n(\n    GT(airquality_mini)\n    .tab_style(\n        style=style.fill(color=\"yellow\"),\n        locations=loc.body(columns=\"Temp\", rows=[1, 2])\n    )\n)\n\n\n\n\n\n\n  Ozone\n  Solar_R\n  Wind\n  Temp\n  Month\n  Day\n\n\n  \n    41.0\n    190.0\n    7.4\n    67\n    5\n    1\n  \n  \n    36.0\n    118.0\n    8.0\n    72\n    5\n    2\n  \n  \n    12.0\n    149.0\n    12.6\n    74\n    5\n    3\n  \n  \n    18.0\n    313.0\n    11.5\n    62\n    5\n    4\n  \n  \n    \n    \n    14.3\n    56\n    5\n    5\n  \n\n\n\n\n\n\n        \n\n\nAside from style.fill() we can also use style.text() and style.borders() to focus the styling on cell text and borders. Here’s an example where we perform several types of styling on targeted cells (the key is to put the style.*() calls in a list).\n\nfrom great_tables import GT, style, exibble\n\n(\n    GT(exibble[[\"num\", \"currency\"]])\n    .fmt_number(columns = \"num\", decimals=1)\n    .fmt_currency(columns = \"currency\")\n    .tab_style(\n        style=[\n            style.fill(color=\"lightcyan\"),\n            style.text(weight=\"bold\")\n        ],\n        locations=loc.body(columns=\"num\")\n    )\n    .tab_style(\n        style=[\n            style.fill(color = \"#F9E3D6\"),\n            style.text(style = \"italic\")\n        ],\n        locations=loc.body(columns=\"currency\")\n    )\n)\n\n\n\n\n\n\n  num\n  currency\n\n\n  \n    0.1\n    $49.95\n  \n  \n    2.2\n    $17.95\n  \n  \n    33.3\n    $1.39\n  \n  \n    444.4\n    $65,100.00\n  \n  \n    5,550.0\n    $1,325.81\n  \n  \n    nan\n    $13.26\n  \n  \n    777,000.0\n    \n  \n  \n    8,880,000.0\n    $0.44"
  },
  {
    "objectID": "blog/introduction_great_tables.html#column-selection-with-polars-and-how-it-helps-with-styling",
    "href": "blog/introduction_great_tables.html#column-selection-with-polars-and-how-it-helps-with-styling",
    "title": "Introducing Great Tables",
    "section": "Column Selection with Polars (and How It Helps with Styling)",
    "text": "Column Selection with Polars (and How It Helps with Styling)\nStyles can also be specified using Polars expressions. For example, the code below uses the Temp column to set color to \"lightyellow\" or \"lightblue\".\n\nimport polars as pl\n\nfrom great_tables import GT, from_column, style, loc\nfrom great_tables.data import airquality\n\nairquality_mini = pl.from_pandas(airquality.head())\n\n# A Polars expression defines color based on values in `Temp`\nfill_color_temp = (\n    pl.when(pl.col(\"Temp\") &gt; 70)\n    .then(pl.lit(\"lightyellow\"))\n    .otherwise(pl.lit(\"lightblue\"))\n)\n\n# Pass `fill_color_temp` to the `color=` arg of `style.fill()`\n(\n    GT(airquality_mini)\n    .tab_style(\n        style=style.fill(color=fill_color_temp),\n        locations=loc.body(\"Temp\")\n    )\n)\n\n\n\n\n\n\n  Ozone\n  Solar_R\n  Wind\n  Temp\n  Month\n  Day\n\n\n  \n    41.0\n    190.0\n    7.4\n    67\n    5\n    1\n  \n  \n    36.0\n    118.0\n    8.0\n    72\n    5\n    2\n  \n  \n    12.0\n    149.0\n    12.6\n    74\n    5\n    3\n  \n  \n    18.0\n    313.0\n    11.5\n    62\n    5\n    4\n  \n  \n    None\n    None\n    14.3\n    56\n    5\n    5\n  \n\n\n\n\n\n\n        \n\n\nWe can deftly mix and match Polars column selectors and expressions. This gives us great flexibility in selecting specific columns and rows. Here’s an example of doing that again with tab_style():\n\nimport polars.selectors as cs\n\n(\n    GT(airquality_mini)\n    .tab_style(\n        style=style.fill(color=\"yellow\"),\n        locations=loc.body(\n            columns=cs.starts_with(\"Te\"),\n            rows=pl.col(\"Temp\") &gt; 70\n        )\n    )\n)\n\n\n\n\n\n\n  Ozone\n  Solar_R\n  Wind\n  Temp\n  Month\n  Day\n\n\n  \n    41.0\n    190.0\n    7.4\n    67\n    5\n    1\n  \n  \n    36.0\n    118.0\n    8.0\n    72\n    5\n    2\n  \n  \n    12.0\n    149.0\n    12.6\n    74\n    5\n    3\n  \n  \n    18.0\n    313.0\n    11.5\n    62\n    5\n    4\n  \n  \n    None\n    None\n    14.3\n    56\n    5\n    5\n  \n\n\n\n\n\n\n        \n\n\nIt feels great to use the conveniences offered by Polars and we’re excited about how far we can take this!"
  },
  {
    "objectID": "blog/introduction_great_tables.html#where-were-going-with-great-tables",
    "href": "blog/introduction_great_tables.html#where-were-going-with-great-tables",
    "title": "Introducing Great Tables",
    "section": "Where We’re Going with Great Tables",
    "text": "Where We’re Going with Great Tables\nWe’re obviously pretty encouraged about how Great Tables is turning out and so we’ll continue to get useful table-making niceties into the package. We welcome any and all feedback, so get in touch with us:\n\nyou can file a GitHub issue or get a discussion going in GitHub Discussions\nthere’s an X/Twitter account at @gt_package, so check it out for package news and announcements\nthere’s a fun Discord server that lets you more casually ask questions and generally just talk about table things\n\nStay tuned for more on Great Tables in this blog or elsewhere in the Internet!"
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Great Blogposts",
    "section": "",
    "text": "Order By\n       Default\n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Title\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\nDate\n\n\nTitle\n\n\nAuthor\n\n\n\n\n\n\nApr 24, 2024\n\n\nGreat Tables is now BYODF (Bring Your Own DataFrame)\n\n\nMichael Chow\n\n\n\n\nApr 4, 2024\n\n\nThe Design Philosophy of Great Tables\n\n\nRich Iannone and Michael Chow\n\n\n\n\nMar 19, 2024\n\n\nGreat Tables v0.4.0: Nanoplots and More\n\n\nRich Iannone\n\n\n\n\nFeb 16, 2024\n\n\nGreat Tables v0.3.0: So Many Style Options!\n\n\nRich Iannone\n\n\n\n\nFeb 8, 2024\n\n\nUsing Polars to Win at Super Bowl Squares\n\n\nMichael Chow\n\n\n\n\nJan 24, 2024\n\n\nGreat Tables v0.2.0: Easy Data Coloring\n\n\nRich Iannone\n\n\n\n\nJan 8, 2024\n\n\nGreat Tables: The Polars DataFrame Styler of Your Dreams\n\n\nMichael Chow\n\n\n\n\nJan 4, 2024\n\n\nIntroducing Great Tables\n\n\nRich Iannone\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blog/introduction-0.2.0/index.html",
    "href": "blog/introduction-0.2.0/index.html",
    "title": "Great Tables v0.2.0: Easy Data Coloring",
    "section": "",
    "text": "We enjoy working on Great Tables because we want everybody to easily make beautiful tables. Tables don’t have to be boring, they really could be captivating and insightful. With every release we get closer and closer to realizing our mission and, as such, we’re happy to announce the v0.2.0 release that’s now on PyPI.\nThe really big feature that’s available with this release is the data_color() method. It gives you several options for colorizing data cells based on the underlying data. The method automatically scales color values according to the data in order to emphasize differences or reveal trends. The example below emphasizes large currency values with a \"darkgreen\" fill color.\n\nfrom great_tables import GT, exibble\n\n(\n    GT(exibble[[\"currency\", \"date\", \"row\"]].head(4), rowname_col=\"row\")\n    .data_color(\n        columns=\"currency\",\n        palette=[\"lightblue\", \"darkgreen\"]\n    )\n)\n\n\n\n\n\n\n  \n  currency\n  date\n\n\n  \n    row_1\n    49.95\n    2015-01-15\n  \n  \n    row_2\n    17.95\n    2015-02-15\n  \n  \n    row_3\n    1.39\n    2015-03-15\n  \n  \n    row_4\n    65100.0\n    2015-04-15\n  \n\n\n\n\n\n\n        \n\n\nNote that we use columns= to specify which columns get the colorizing treatment (just currency here) and the palette= is given as a list of color values. From this we can see that the 65100.0 value polarizes the data coloring process; it is \"darkgreen\" while all other values are \"lightblue\" (with no interpolated colors in between). Also, isn’t it nice that the text adapts to the background color?\nThe above example is suitable for emphasizing large values, but, maybe you consider the extreme value to be something that’s out of bounds? For that, we can use the domain= and na_value= arguments to gray-out the extreme values. We’ll also nicely format the currency column in this next example.\n\n(\n    GT(exibble[[\"currency\", \"date\", \"row\"]].head(4), rowname_col=\"row\")\n    .data_color(\n        columns=\"currency\",\n        palette=[\"lightblue\", \"darkgreen\"],\n        domain=[0, 50],\n        na_color=\"lightgray\"\n    )\n    .fmt_currency(\n        columns=\"currency\",\n        currency=\"GBP\",\n        use_subunits=False\n    )\n)\n\n\n\n\n\n\n  \n  currency\n  date\n\n\n  \n    row_1\n    £50\n    2015-01-15\n  \n  \n    row_2\n    £18\n    2015-02-15\n  \n  \n    row_3\n    £1\n    2015-03-15\n  \n  \n    row_4\n    £65,100\n    2015-04-15\n  \n\n\n\n\n\n\n        \n\n\nNow the very large value is in \"lightgray\", making all other values easier to compare. We did setting domain=[0, 50] and specifying na_color=\"lightgray\". This caused the out-of-bounds value of 65100 to have a light gray background. Notice that the values are also formatted as currencies, and this is thanks to fmt_currency() which never interferes with styling.\nHere’s a more inspirational example that uses a heavily-manipulated version of the countrypops dataset (thanks again, Polars!) along with a color treatment that’s mediated by data_color(). Here, the population values can be easily compared by the amount of \"purple\" within them.\n\nfrom great_tables.data import countrypops\nimport polars as pl\nimport polars.selectors as cs\n\nwide_pops = (\n    pl.from_pandas(countrypops)\n    .filter(\n        pl.col(\"country_code_2\").is_in([\"FM\", \"GU\", \"KI\", \"MH\", \"MP\", \"NR\", \"PW\"])\n        & pl.col(\"year\").is_in([2000, 2010, 2020])\n    )\n    .pivot(index=\"country_name\", columns=\"year\", values=\"population\")\n    .sort(\"2020\", descending=True)\n)\n\n(\n    GT(wide_pops, rowname_col=\"country_name\")\n    .tab_header(\n        title=\"Populations of Select Countries in Oceania\",\n        subtitle=\"Population values are from 2000, 2010, and 2020.\",\n    )\n    .tab_spanner(label=\"Total Population\", columns=cs.all())\n    .fmt_integer(columns=[\"2000\", \"2010\", \"2020\"])\n    .data_color(palette=[\"white\", \"purple\"], domain=[0, 1.7e5])\n)\n\n\n\n\n\n  \n    Populations of Select Countries in Oceania\n  \n  \n    Population values are from 2000, 2010, and 2020.\n  \n\n\n  \n  \n    Total Population\n  \n\n\n  2000\n  2010\n  2020\n\n\n  \n    Guam\n    160,188\n    164,905\n    169,231\n  \n  \n    Kiribati\n    88,826\n    107,995\n    126,463\n  \n  \n    Micronesia (Federated States)\n    111,709\n    107,588\n    112,106\n  \n  \n    Northern Mariana Islands\n    80,338\n    54,087\n    49,587\n  \n  \n    Marshall Islands\n    54,224\n    53,416\n    43,413\n  \n  \n    Palau\n    19,726\n    18,540\n    17,972\n  \n  \n    Nauru\n    10,377\n    10,241\n    12,315\n  \n\n\n\n\n\n\n        \n\n\nThis was just a sampler of what you can do with the all-new data_color() method. Take a look at these pages for more information:\n\nThe Colorizing with Data page in the Get Started Guide, which provides more details on how to use data_color()\nThe guide on Basic Styling covers general styling (e.g., bold text, underlines, etc.) with tab_style()\nThe reference pages for data_color() and tab_style()\n\nTo conclude, we’re happy that this new functionality is now in the Great Tables package! We hope you find it useful for your table-generation work. And we’ll keep improving upon it so that you’ll have more possibilities to make beautiful, and colorful, tables for presentation."
  },
  {
    "objectID": "blog/polars-styling/index.html",
    "href": "blog/polars-styling/index.html",
    "title": "Great Tables: The Polars DataFrame Styler of Your Dreams",
    "section": "",
    "text": "Analyzing data with polars is a no-brainer in python. It provides an intuitive, expressive interface to data. When it comes to reports, it’s trivial to plug polars into plotting libraries like seaborn, plotly, and plotnine.\nHowever, there are fewer options for styling tables for presentation. You could convert from polars to pandas, and use the built-in pandas DataFrame styler, but this has one major limitation: you can’t use polars expressions.\nAs it turns out, polars expressions make styling tables very straightforward. The same polars code that you would use to select or filter combines with Great Tables to highlight, circle, or bolden text.\nIn this post, I’ll show how Great Tables uses polars expressions to make delightful tables, like the one below.\nCode\nimport polars as pl\nimport polars.selectors as cs\n\nfrom great_tables import GT, md, html, style, loc\nfrom great_tables.data import airquality\n\nairquality_mini = airquality.head(10).assign(Year = 1973)\npl_airquality = pl.DataFrame(airquality_mini).select(\n    \"Year\", \"Month\", \"Day\", \"Ozone\", \"Solar_R\", \"Wind\", \"Temp\"\n)\ngt_air = GT(pl_airquality)\n\n(\n    gt_air\n\n    # Table header ----\n    .tab_header(\n        title = \"New York Air Quality Measurements\",\n        subtitle = \"Daily measurements in New York City (May 1-10, 1973)\"\n    )\n\n    # Table column spanners ----\n    .tab_spanner(\n        label = \"Time\",\n        columns = [\"Year\", \"Month\", \"Day\"]\n    )\n    .tab_spanner(\n        label = \"Measurement\",\n        columns = [\"Ozone\", \"Solar_R\", \"Wind\", \"Temp\"]\n    )\n    .cols_label(\n        Ozone = html(\"Ozone,&lt;br&gt;ppbV\"),\n        Solar_R = html(\"Solar R.,&lt;br&gt;cal/m&lt;sup&gt;2&lt;/sup&gt;\"),\n        Wind = html(\"Wind,&lt;br&gt;mph\"),\n        Temp = html(\"Temp,&lt;br&gt;&deg;F\")\n    )\n\n    # Table styles ----\n    .tab_style(\n        style.fill(\"lightyellow\"),\n        loc.body(\n            columns = cs.all(),\n            rows = pl.col(\"Wind\") == pl.col(\"Wind\").max()\n        )\n    )\n    .tab_style(\n        style.text(weight = \"bold\"),\n        loc.body(\"Wind\", pl.col(\"Wind\") == pl.col(\"Wind\").max())\n    )\n)\n\n\n\n\n\n\n  \n    New York Air Quality Measurements\n  \n  \n    Daily measurements in New York City (May 1-10, 1973)\n  \n\n\n  \n    Time\n  \n  \n    Measurement\n  \n\n\n  Year\n  Month\n  Day\n  Ozone,ppbV\n  Solar R.,cal/m2\n  Wind,mph\n  Temp,°F\n\n\n  \n    1973\n    5\n    1\n    41.0\n    190.0\n    7.4\n    67\n  \n  \n    1973\n    5\n    2\n    36.0\n    118.0\n    8.0\n    72\n  \n  \n    1973\n    5\n    3\n    12.0\n    149.0\n    12.6\n    74\n  \n  \n    1973\n    5\n    4\n    18.0\n    313.0\n    11.5\n    62\n  \n  \n    1973\n    5\n    5\n    None\n    None\n    14.3\n    56\n  \n  \n    1973\n    5\n    6\n    28.0\n    None\n    14.9\n    66\n  \n  \n    1973\n    5\n    7\n    23.0\n    299.0\n    8.6\n    65\n  \n  \n    1973\n    5\n    8\n    19.0\n    99.0\n    13.8\n    59\n  \n  \n    1973\n    5\n    9\n    8.0\n    19.0\n    20.1\n    61\n  \n  \n    1973\n    5\n    10\n    None\n    194.0\n    8.6\n    69"
  },
  {
    "objectID": "blog/polars-styling/index.html#the-parts-of-a-presentation-ready-table",
    "href": "blog/polars-styling/index.html#the-parts-of-a-presentation-ready-table",
    "title": "Great Tables: The Polars DataFrame Styler of Your Dreams",
    "section": "The parts of a presentation-ready table",
    "text": "The parts of a presentation-ready table\nOur example table customized three main parts:\n\nTitle and subtitle: User friendly titles and subtitles, describing the data.\nColumn spanners: Group related columns together with a custom label.\nStyles: Highlight rows, columns, or individual cells of data.\n\nThis is marked below.\n\n\n\n\n\nLet’s walk through each piece in order to produce the table below."
  },
  {
    "objectID": "blog/polars-styling/index.html#creating-gt-object",
    "href": "blog/polars-styling/index.html#creating-gt-object",
    "title": "Great Tables: The Polars DataFrame Styler of Your Dreams",
    "section": "Creating GT object",
    "text": "Creating GT object\nFirst, we’ll import the necessary libraries, and do a tiny bit of data processing.\n\nimport polars as pl\nimport polars.selectors as cs\n\nfrom great_tables import GT\nfrom great_tables.data import airquality\n\n# Note that we'll use the first 5 rows as we build up our code\nairquality_mini = airquality.head(5).assign(Year = 1973)\npl_airquality = pl.DataFrame(airquality_mini).select(\n    \"Year\", \"Month\", \"Day\", \"Ozone\", \"Solar_R\", \"Wind\", \"Temp\"\n)\n\npl_airquality\n\n\nshape: (5, 7)YearMonthDayOzoneSolar_RWindTempi64i64i64f64f64f64i6419735141.0190.07.46719735236.0118.08.07219735312.0149.012.67419735418.0313.011.562197355nullnull14.356\n\n\nThe default polars output above is really helpful for data analysis! By passing it to the GT constructor, we can start getting it ready for presentation.\n\ngt_air = GT(pl_airquality)\n\ngt_air\n\n\n\n\n\n\n  Year\n  Month\n  Day\n  Ozone\n  Solar_R\n  Wind\n  Temp\n\n\n  \n    1973\n    5\n    1\n    41.0\n    190.0\n    7.4\n    67\n  \n  \n    1973\n    5\n    2\n    36.0\n    118.0\n    8.0\n    72\n  \n  \n    1973\n    5\n    3\n    12.0\n    149.0\n    12.6\n    74\n  \n  \n    1973\n    5\n    4\n    18.0\n    313.0\n    11.5\n    62\n  \n  \n    1973\n    5\n    5\n    None\n    None\n    14.3\n    56\n  \n\n\n\n\n\n\n        \n\n\nIn the next section I’ll show setting a title, and then go on to more exciting stuff like styling the body and creating column spanners."
  },
  {
    "objectID": "blog/polars-styling/index.html#set-title-and-subtitle",
    "href": "blog/polars-styling/index.html#set-title-and-subtitle",
    "title": "Great Tables: The Polars DataFrame Styler of Your Dreams",
    "section": "Set title and subtitle",
    "text": "Set title and subtitle\nThe simplest method in gt is GT.tab_header(), which lets you add a title and subtitle.\n\n(\n    gt_air\n\n    # Table header ----\n    .tab_header(\n        title = \"New York Air Quality Measurements\",\n        subtitle = \"Daily measurements in New York City (May 1-10, 1973)\"\n    )\n)\n\n\n\n\n\n  \n    New York Air Quality Measurements\n  \n  \n    Daily measurements in New York City (May 1-10, 1973)\n  \n\n\n  Year\n  Month\n  Day\n  Ozone\n  Solar_R\n  Wind\n  Temp\n\n\n  \n    1973\n    5\n    1\n    41.0\n    190.0\n    7.4\n    67\n  \n  \n    1973\n    5\n    2\n    36.0\n    118.0\n    8.0\n    72\n  \n  \n    1973\n    5\n    3\n    12.0\n    149.0\n    12.6\n    74\n  \n  \n    1973\n    5\n    4\n    18.0\n    313.0\n    11.5\n    62\n  \n  \n    1973\n    5\n    5\n    None\n    None\n    14.3\n    56\n  \n\n\n\n\n\n\n        \n\n\nJust like with plots, tables need titles so people know what they’re about!"
  },
  {
    "objectID": "blog/polars-styling/index.html#set-body-styles",
    "href": "blog/polars-styling/index.html#set-body-styles",
    "title": "Great Tables: The Polars DataFrame Styler of Your Dreams",
    "section": "Set body styles",
    "text": "Set body styles\nThe .tab_style() method sets styles—like fill color, or text properties—on different parts of the table. Let’s use it twice with a polars expression. First to highlight the row corresponding to the max Wind value, and then to bold that value.\n\nfrom great_tables import style, loc\n\nis_max_wind = pl.col(\"Wind\") == pl.col(\"Wind\").max()\n\n(\n    gt_air\n\n    # Table styles ----\n    .tab_style(\n        style.fill(\"lightyellow\"),\n        loc.body(\n            columns = cs.all(),\n            rows = is_max_wind\n        )\n    )\n    .tab_style(\n        style.text(weight = \"bold\"),\n        loc.body(\"Wind\", is_max_wind)\n    )\n)\n\n\n\n\n\n\n  Year\n  Month\n  Day\n  Ozone\n  Solar_R\n  Wind\n  Temp\n\n\n  \n    1973\n    5\n    1\n    41.0\n    190.0\n    7.4\n    67\n  \n  \n    1973\n    5\n    2\n    36.0\n    118.0\n    8.0\n    72\n  \n  \n    1973\n    5\n    3\n    12.0\n    149.0\n    12.6\n    74\n  \n  \n    1973\n    5\n    4\n    18.0\n    313.0\n    11.5\n    62\n  \n  \n    1973\n    5\n    5\n    None\n    None\n    14.3\n    56\n  \n\n\n\n\n\n\n        \n\n\nNote two important pieces:\n\nFunctions like style.fill() indicate what style to set.\nFunctions like loc.body() indicate where to apply the style. Its columns= and rows= parameters let you target specific parts of the table body (using polars expressions).\n\nCurrently, Great Tables only supports styling the table body. In the (very near) future, other loc.* functions will allow styling other parts of the table (e.g. the title, column labels, etc..).\nFor more details on styles, see Styling the Table Body in the Geting Started guide."
  },
  {
    "objectID": "blog/polars-styling/index.html#set-column-spanners",
    "href": "blog/polars-styling/index.html#set-column-spanners",
    "title": "Great Tables: The Polars DataFrame Styler of Your Dreams",
    "section": "Set column spanners",
    "text": "Set column spanners\nThe last piece to set in the table is the column spanners, which are made up of two things:\n\nLabels describing groups of columns (e.g. Time, Measurement).\nMore readable labels for columns themselves.\n\nUse GT.tab_spanner() to set labels on groups of columns.\n\ntime_cols = [\"Year\", \"Month\", \"Day\"]\n\ngt_with_spanners = (\n    gt_air\n\n    # Table column spanners ----\n    .tab_spanner(\n        label = \"Time\",\n        columns = time_cols\n    )\n    .tab_spanner(\n        label = \"Measurement\",\n        columns = cs.all().exclude(time_cols)\n    )\n)\n\ngt_with_spanners\n\n\n\n\n\n\n  \n    Time\n  \n  \n    Measurement\n  \n\n\n  Year\n  Month\n  Day\n  Ozone\n  Solar_R\n  Wind\n  Temp\n\n\n  \n    1973\n    5\n    1\n    41.0\n    190.0\n    7.4\n    67\n  \n  \n    1973\n    5\n    2\n    36.0\n    118.0\n    8.0\n    72\n  \n  \n    1973\n    5\n    3\n    12.0\n    149.0\n    12.6\n    74\n  \n  \n    1973\n    5\n    4\n    18.0\n    313.0\n    11.5\n    62\n  \n  \n    1973\n    5\n    5\n    None\n    None\n    14.3\n    56\n  \n\n\n\n\n\n\n        \n\n\nNotice that there are now labels for “Time” and “Measurement” sitting above the column names. This is useful for emphasizing columns that share something in common.\nUse GT.cols_labels() with html() to create human-friendly labels (e.g. convert things like cal_m_2 to cal/m2).\n\nfrom great_tables import html\n\n(\n    gt_with_spanners\n    .cols_label(\n        Ozone = html(\"Ozone,&lt;br&gt;ppbV\"),\n        Solar_R = html(\"Solar R.,&lt;br&gt;cal/m&lt;sup&gt;2&lt;/sup&gt;\"),\n        Wind = html(\"Wind,&lt;br&gt;mph\"),\n        Temp = html(\"Temp,&lt;br&gt;&deg;F\")\n    )\n)\n\n\n\n\n\n\n  \n    Time\n  \n  \n    Measurement\n  \n\n\n  Year\n  Month\n  Day\n  Ozone,ppbV\n  Solar R.,cal/m2\n  Wind,mph\n  Temp,°F\n\n\n  \n    1973\n    5\n    1\n    41.0\n    190.0\n    7.4\n    67\n  \n  \n    1973\n    5\n    2\n    36.0\n    118.0\n    8.0\n    72\n  \n  \n    1973\n    5\n    3\n    12.0\n    149.0\n    12.6\n    74\n  \n  \n    1973\n    5\n    4\n    18.0\n    313.0\n    11.5\n    62\n  \n  \n    1973\n    5\n    5\n    None\n    None\n    14.3\n    56\n  \n\n\n\n\n\n\n        \n\n\nThis is helpful because labels are often in a funky format (e.g. cal_m_2) because they’re easier to work with programmatically, so need to be cleaned up for presentation.\nSee the Column Labels page of the guide for more details."
  },
  {
    "objectID": "blog/polars-styling/index.html#putting-it-all-together",
    "href": "blog/polars-styling/index.html#putting-it-all-together",
    "title": "Great Tables: The Polars DataFrame Styler of Your Dreams",
    "section": "Putting it all together",
    "text": "Putting it all together\nFinally, we’ll combine everything from the sections above into a single block of code, and use a few more rows of data.\n\n\nCode\nimport polars as pl\nimport polars.selectors as cs\n\nfrom great_tables import GT, md, html, style, loc\nfrom great_tables.data import airquality\n\nairquality_mini = airquality.head(10).assign(Year = 1973)\npl_airquality = pl.DataFrame(airquality_mini).select(\n    \"Year\", \"Month\", \"Day\", \"Ozone\", \"Solar_R\", \"Wind\", \"Temp\"\n)\ngt_air = GT(pl_airquality)\n\n(\n    gt_air\n\n    # Table header ----\n    .tab_header(\n        title = \"New York Air Quality Measurements\",\n        subtitle = \"Daily measurements in New York City (May 1-10, 1973)\"\n    )\n\n    # Table column spanners ----\n    .tab_spanner(\n        label = \"Time\",\n        columns = [\"Year\", \"Month\", \"Day\"]\n    )\n    .tab_spanner(\n        label = \"Measurement\",\n        columns = [\"Ozone\", \"Solar_R\", \"Wind\", \"Temp\"]\n    )\n    .cols_label(\n        Ozone = html(\"Ozone,&lt;br&gt;ppbV\"),\n        Solar_R = html(\"Solar R.,&lt;br&gt;cal/m&lt;sup&gt;2&lt;/sup&gt;\"),\n        Wind = html(\"Wind,&lt;br&gt;mph\"),\n        Temp = html(\"Temp,&lt;br&gt;&deg;F\")\n    )\n\n    # Table styles ----\n    .tab_style(\n        style.fill(\"lightyellow\"),\n        loc.body(\n            columns = cs.all(),\n            rows = pl.col(\"Wind\") == pl.col(\"Wind\").max()\n        )\n    )\n    .tab_style(\n        style.text(weight = \"bold\"),\n        loc.body(\"Wind\", pl.col(\"Wind\") == pl.col(\"Wind\").max())\n    )\n)\n\n\n\n\n\n\n  \n    New York Air Quality Measurements\n  \n  \n    Daily measurements in New York City (May 1-10, 1973)\n  \n\n\n  \n    Time\n  \n  \n    Measurement\n  \n\n\n  Year\n  Month\n  Day\n  Ozone,ppbV\n  Solar R.,cal/m2\n  Wind,mph\n  Temp,°F\n\n\n  \n    1973\n    5\n    1\n    41.0\n    190.0\n    7.4\n    67\n  \n  \n    1973\n    5\n    2\n    36.0\n    118.0\n    8.0\n    72\n  \n  \n    1973\n    5\n    3\n    12.0\n    149.0\n    12.6\n    74\n  \n  \n    1973\n    5\n    4\n    18.0\n    313.0\n    11.5\n    62\n  \n  \n    1973\n    5\n    5\n    None\n    None\n    14.3\n    56\n  \n  \n    1973\n    5\n    6\n    28.0\n    None\n    14.9\n    66\n  \n  \n    1973\n    5\n    7\n    23.0\n    299.0\n    8.6\n    65\n  \n  \n    1973\n    5\n    8\n    19.0\n    99.0\n    13.8\n    59\n  \n  \n    1973\n    5\n    9\n    8.0\n    19.0\n    20.1\n    61\n  \n  \n    1973\n    5\n    10\n    None\n    194.0\n    8.6\n    69\n  \n\n\n\n\n\n\n        \n\n\nNot too bad!\nTable styling is a surprisingly deep topic, and we’ve only scratched the surface on what Great Tables can do. A big one not covered here is the many column formatting methods, like GT.fmt_currency().\nThoughtfully styled tables tell viewers that you care as much about communicating the table, as much as the data wrangling behind it. Working with polars has been an absolute dream, and we’re excited to explore different ways it and Great Tables make for easy table styling!"
  },
  {
    "objectID": "blog/introduction-0.3.0/index.html",
    "href": "blog/introduction-0.3.0/index.html",
    "title": "Great Tables v0.3.0: So Many Style Options!",
    "section": "",
    "text": "As our work on Great Tables continues, we want you to be able to produce increasingly sophisticated tables. The look of an HTML table really matters and we believe aesthetics can elevate the presentation of tabular data. In the v0.3.0 release, we’ve implemented features that are concerned with modifying the visual aspects of a table. Let’s get down to what’s new in this version.\n\nModifying the widths of columns\nBefore v0.3.0, you could not alter the widths of individual columns. This meant that to great extent your content decided the width of individual columns. Even though browsers do an adequate job in sizing the widths of table columns, it doesn’t always result in a pleasing-to-look-at table. What if you want more space? Maybe you want consistently-sized columns? There’s many reasons to want to have a choice in the matter and the new cols_width() method now makes this possible.\nHere’s an example where the widths of all columns are set with our preferred length values (in px).\n\nfrom great_tables import GT, exibble\n\nexibble_mini = exibble[[\"num\", \"char\", \"date\", \"datetime\", \"row\"]].head(5)\n\n(\n    GT(exibble_mini).cols_width(\n        cases={\n            \"num\": \"30px\",\n            \"char\": \"100px\",\n            \"date\": \"150px\",\n            \"datetime\": \"200px\",\n            \"row\": \"50px\"\n        }\n    )\n)\n\n\n\n\n\n  \n  \n  \n  \n  \n\n\n\n\n  num\n  char\n  date\n  datetime\n  row\n\n\n  \n    0.1111\n    apricot\n    2015-01-15\n    2018-01-01 02:22\n    row_1\n  \n  \n    2.222\n    banana\n    2015-02-15\n    2018-02-02 14:33\n    row_2\n  \n  \n    33.33\n    coconut\n    2015-03-15\n    2018-03-03 03:44\n    row_3\n  \n  \n    444.4\n    durian\n    2015-04-15\n    2018-04-04 15:55\n    row_4\n  \n  \n    5550.0\n    \n    2015-05-15\n    2018-05-05 04:00\n    row_5\n  \n\n\n\n\n\n\n        \n\n\nYou don’t have to define widths for all columns with cols_width(), and you’re free to use either px or % values when defining widths. See the reference page for more information and relevant examples.\n\n\nSetting options across the entire table with tab_options()\nThe new tab_options() method gives you the freedom to specify any of dozens of global style and layout options for the table. Want a font that’s used across all cells? Use the table_font_names= option. Do you need to make the text smaller, but only in the stub? Use stub_font_size= for that. The number of options is perhaps overwhelming at first but we think you’ll enjoy having them around nonetheless. It makes styling the table (and developing your own table themes) a relatively simple task.\nHere’s an example that creates a table with a few common components and then uses tab_options() to set up a collection of fonts for the table with the (also new) system_fonts() function:\n\nfrom great_tables import md, system_fonts\n\ngt_tbl = (\n    GT(\n        exibble[[\"num\", \"char\", \"currency\", \"row\", \"group\"]],\n        rowname_col=\"row\",\n        groupname_col=\"group\",\n    )\n    .tab_header(\n        title=md(\"Data listing from **exibble**\"),\n        subtitle=md(\"`exibble` is a **Great Tables** dataset.\"),\n    )\n    .fmt_number(columns=\"num\")\n    .fmt_currency(columns=\"currency\")\n    .tab_source_note(source_note=\"This is only a subset of the dataset.\")\n)\n\ngt_tbl.tab_options(table_font_names=system_fonts(name=\"industrial\"))\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nNote that table_font_names= accepts a list of fonts that operate as fallbacks for users across different systems (i.e., they may not have the font you have). And the system_fonts() helper function in Great Tables makes this easy by providing you with themed, local font stacks that are meant to work across different computing platforms.\nHere’s another example where we set the width of the table to span across the entire page (or containing element).\n\ngt_tbl.tab_options(table_width=\"100%\")\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nOne more where the background color of the table is set to \"lightcyan\":\n\ngt_tbl.tab_options(table_background_color=\"lightcyan\")\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nThere are many more options available in tab_options(), so have a look at its reference page for more information and useful examples.\n\n\nUsing the new opt_*() methods to do more complex tasks with table options\nWhile tab_options() is a great method for setting global table options, sometimes you want to set a number of them at once for a combined effect. For that type of operation, we have the opt_*() series of methods. A common thing you might do is align the content in the table header, we can make that an easy thing with opt_align_table_header():\n\ngt_tbl.opt_align_table_header(align=\"left\")\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nWith that, you don’t have to hunt through the myriad options within tab_options() to find the two args you need to get the job done.\nThe opt_all_caps() method transforms the text within the column labels, the stub, and in all row groups so that we get an all-capitalized (yet somewhat sized down) look that better differentiates the labels from the data. It’s rather easy to use, just do this:\n\ngt_tbl.opt_all_caps()\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nThis sets nine options you’d otherwise set in tab_options() all at once, making life generally easier.\nHere’s one last example, this time using opt_vertical_padding(). You’d use that if you’re dissatisfied with the level of top/bottom padding within cells of all locations (e.g., in the table body, in the column labels, etc.). You can either make a table taller or more ‘compressed’ with a single argument: scale=. Here’s an example where the amount of vertical padding is reduced, resulting in a table taking up less vertical space.\n\ngt_tbl.opt_vertical_padding(scale=0.5)\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nWe have the following methods available in the opt_*() family\n\nopt_align_table_header()\nopt_all_caps()\nopt_vertical_padding()\nopt_horizontal_padding()\n\nand we plan to add more opt_*() methods in future releases.\n\n\nA new formatting method: fmt_image()\nWouldn’t it be great to add graphics to your table? The fmt_image() method provides an easy way to add image files on disk into table body cells. The cells need to contain some reference to an image file. The path= and file_pattern= arguments give you some flexibility in defining exactly where the image files live.\nHere’s an example using the metro dataset that’s included within Great Tables.\n\nfrom great_tables.data import metro\nfrom importlib_resources import files\n\nimg_paths = files(\"great_tables\") / \"data/metro_images\"\nmetro_mini = metro[[\"name\", \"lines\", \"passengers\"]].head(5)\n\n(\n    GT(metro_mini)\n    .fmt_image(columns=\"lines\", path=img_paths, file_pattern=\"metro_{}.svg\")\n    .fmt_integer(columns=\"passengers\")\n    .cols_label(\n        name=\"Station\",\n        lines=\"Metro Lines\",\n        passengers=\"Passengers per Year (2021)\"\n    )\n    .tab_options(table_width=\"700px\")\n)\n\n\n\n\n\n\n  Station\n  Metro Lines\n  Passengers per Year (2021)\n\n\n  \n    Argentine\n    \n    2,079,212\n  \n  \n    Bastille\n      \n    8,069,243\n  \n  \n    Bérault\n    \n    2,106,827\n  \n  \n    Champs-Élysées—Clemenceau\n     \n    1,909,005\n  \n  \n    Charles de Gaulle—Étoile\n      \n    4,291,663\n  \n\n\n\n\n\n\n        \n\n\nNotice that path=img_paths specified the folder the images live in, and file_pattern=\"metro_{}.svg\" provided a template for converting each value in the lines column to an SVG file name.\nThe fmt_image() method supports three kinds of files as inputs, either: (1) complete http/https or local paths to the files; (2) the file names, where a common path can be provided via the path= arg; or (3) a fragment of the file name, as shown in the example above.\nThe package has some graphics stored in the data/metro_images directory. They are SVGs and they look very nice in the example table!\nSee the fmt_image() reference page for more information on this new method.\n\n\nWrapping up\nThis v0.3.0 release has some great new methods that add value to most any table-making endeavor. We also fixed a few bugs along the way so that you’ll have a overall smoother experience when building beautiful tables. As ever, we’ll work toward more and more improvements to give you more creative possibilities!"
  },
  {
    "objectID": "get-started/index.html",
    "href": "get-started/index.html",
    "title": "Intro",
    "section": "",
    "text": "The Great Tables package is all about making it simple to produce nice-looking display tables. Display tables? Well yes, we are trying to distinguish between data tables (i.e., DataFrames) and those tables you’d find in a web page, a journal article, or in a magazine. Such tables can likewise be called presentation tables, summary tables, or just tables really. Here are some examples, ripped straight from the web:\nWe can think of display tables as output only, where we’d not want to use them as input ever again. Other features include annotations, table element styling, and text transformations that serve to communicate the subject matter more clearly.",
    "crumbs": [
      "Get Started",
      "Intro"
    ]
  },
  {
    "objectID": "get-started/index.html#lets-install",
    "href": "get-started/index.html#lets-install",
    "title": "Intro",
    "section": "Let’s Install",
    "text": "Let’s Install\nThe installation really couldn’t be much easier. Use this:\npip install great_tables",
    "crumbs": [
      "Get Started",
      "Intro"
    ]
  },
  {
    "objectID": "get-started/index.html#a-basic-table-using-great-tables",
    "href": "get-started/index.html#a-basic-table-using-great-tables",
    "title": "Intro",
    "section": "A Basic Table using Great Tables",
    "text": "A Basic Table using Great Tables\nLet’s use a subset of the islands dataset available within great_tables.data:\n\nfrom great_tables import GT, md, html\nfrom great_tables.data import islands\n\nislands_mini = islands.head(10)\n\nThe islands data is a simple Pandas DataFrame with 2 columns and that’ll serve as a great start. Speaking of which, the main entry point into the Great Tables API is the GT class. Let’s use that to make a presentable table:\n\n# Create a display table showing ten of the largest islands in the world\ngt_tbl = GT(islands_mini)\n\n# Show the output table\ngt_tbl\n\n\n\n\n\n\n  name\n  size\n\n\n  \n    Africa\n    11506\n  \n  \n    Antarctica\n    5500\n  \n  \n    Asia\n    16988\n  \n  \n    Australia\n    2968\n  \n  \n    Axel Heiberg\n    16\n  \n  \n    Baffin\n    184\n  \n  \n    Banks\n    23\n  \n  \n    Borneo\n    280\n  \n  \n    Britain\n    84\n  \n  \n    Celebes\n    73\n  \n\n\n\n\n\n\n        \n\n\nThat doesn’t look too bad! Sure, it’s basic but we really didn’t really ask for much. We did receive a proper table with column labels and the data. Oftentimes however, you’ll want a bit more: a Table header, a Stub, and sometimes source notes in the Table Footer component.",
    "crumbs": [
      "Get Started",
      "Intro"
    ]
  },
  {
    "objectID": "get-started/index.html#some-beautiful-examples",
    "href": "get-started/index.html#some-beautiful-examples",
    "title": "Intro",
    "section": "Some Beautiful Examples",
    "text": "Some Beautiful Examples\nIn the following pages we’ll use Great Tables to turn DataFrames into beautiful tables, like the ones below.\n\n\nShow the Code\nfrom great_tables import GT, md, html\nfrom great_tables.data import islands\n\nislands_mini = islands.head(10)\n\n(\n    GT(islands_mini, rowname_col = \"name\")\n    .tab_header(\n        title=\"Large Landmasses of the World\",\n        subtitle=\"The top ten largest are presented\"\n    )\n    .tab_source_note(\n        source_note=\"Source: The World Almanac and Book of Facts, 1975, page 406.\"\n    )\n    .tab_source_note(\n        source_note=md(\"Reference: McNeil, D. R. (1977) *Interactive Data Analysis*. Wiley.\")\n    )\n    .tab_stubhead(label=\"landmass\")\n)\n\n\n\n\n\n\n  \n    Large Landmasses of the World\n  \n  \n    The top ten largest are presented\n  \n\n\n  landmass\n  size\n\n\n  \n    Africa\n    11506\n  \n  \n    Antarctica\n    5500\n  \n  \n    Asia\n    16988\n  \n  \n    Australia\n    2968\n  \n  \n    Axel Heiberg\n    16\n  \n  \n    Baffin\n    184\n  \n  \n    Banks\n    23\n  \n  \n    Borneo\n    280\n  \n  \n    Britain\n    84\n  \n  \n    Celebes\n    73\n  \n\n  \n  \n  \n    Source: The World Almanac and Book of Facts, 1975, page 406.\n  \n\n\n  \n    Reference: McNeil, D. R. (1977) Interactive Data Analysis. Wiley.\n  \n\n\n\n\n\n\n        \n\n\n\n\nShow the Code\nfrom great_tables import GT, html\nfrom great_tables.data import airquality\n\nairquality_m = airquality.head(10).assign(Year=1973)\n\ngt_airquality = (\n    GT(airquality_m)\n    .tab_header(\n        title=\"New York Air Quality Measurements\",\n        subtitle=\"Daily measurements in New York City (May 1-10, 1973)\",\n    )\n    .tab_spanner(label=\"Time\", columns=[\"Year\", \"Month\", \"Day\"])\n    .tab_spanner(label=\"Measurement\", columns=[\"Ozone\", \"Solar_R\", \"Wind\", \"Temp\"])\n    .cols_move_to_start(columns=[\"Year\", \"Month\", \"Day\"])\n    .cols_label(\n        Ozone=html(\"Ozone,&lt;br&gt;ppbV\"),\n        Solar_R=html(\"Solar R.,&lt;br&gt;cal/m&lt;sup&gt;2&lt;/sup&gt;\"),\n        Wind=html(\"Wind,&lt;br&gt;mph\"),\n        Temp=html(\"Temp,&lt;br&gt;&deg;F\"),\n    )\n)\n\ngt_airquality\n\n\n\n\n\n\n  \n    New York Air Quality Measurements\n  \n  \n    Daily measurements in New York City (May 1-10, 1973)\n  \n\n\n  \n    Time\n  \n  \n    Measurement\n  \n\n\n  Year\n  Month\n  Day\n  Ozone,ppbV\n  Solar R.,cal/m2\n  Wind,mph\n  Temp,°F\n\n\n  \n    1973\n    5\n    1\n    41.0\n    190.0\n    7.4\n    67\n  \n  \n    1973\n    5\n    2\n    36.0\n    118.0\n    8.0\n    72\n  \n  \n    1973\n    5\n    3\n    12.0\n    149.0\n    12.6\n    74\n  \n  \n    1973\n    5\n    4\n    18.0\n    313.0\n    11.5\n    62\n  \n  \n    1973\n    5\n    5\n    \n    \n    14.3\n    56\n  \n  \n    1973\n    5\n    6\n    28.0\n    \n    14.9\n    66\n  \n  \n    1973\n    5\n    7\n    23.0\n    299.0\n    8.6\n    65\n  \n  \n    1973\n    5\n    8\n    19.0\n    99.0\n    13.8\n    59\n  \n  \n    1973\n    5\n    9\n    8.0\n    19.0\n    20.1\n    61\n  \n  \n    1973\n    5\n    10\n    \n    194.0\n    8.6\n    69",
    "crumbs": [
      "Get Started",
      "Intro"
    ]
  },
  {
    "objectID": "get-started/overview.html",
    "href": "get-started/overview.html",
    "title": "Overview",
    "section": "",
    "text": "The Great Tables package makes it relatively easy to add components so that the resulting output table better conveys the information you want to present. These table components work well together and the possible variations in arrangement can handle even the most demanding table presentation needs. The previous output table we showed had only two components: the Column Labels and the Table Body. The next few examples will show all of the other table parts that are available.\nThis is the way the main parts of a table (and their subparts) fit together:\n\nThe components (roughly from top to bottom) are:\n\nthe Table Header (optional; with a title and possibly a subtitle)\nthe Stub and the Stub Head (optional; contains row labels, optionally within row groups having row group labels)\nthe Column Labels (contains column labels, optionally under spanner labels)\nthe Table Body (contains columns and rows of cells)\nthe Table Footer (optional; possibly with one or more source notes)",
    "crumbs": [
      "Get Started",
      "Overview"
    ]
  },
  {
    "objectID": "get-started/overview.html#adding-parts-to-this-simple-table",
    "href": "get-started/overview.html#adding-parts-to-this-simple-table",
    "title": "Overview",
    "section": "",
    "text": "The Great Tables package makes it relatively easy to add components so that the resulting output table better conveys the information you want to present. These table components work well together and the possible variations in arrangement can handle even the most demanding table presentation needs. The previous output table we showed had only two components: the Column Labels and the Table Body. The next few examples will show all of the other table parts that are available.\nThis is the way the main parts of a table (and their subparts) fit together:\n\nThe components (roughly from top to bottom) are:\n\nthe Table Header (optional; with a title and possibly a subtitle)\nthe Stub and the Stub Head (optional; contains row labels, optionally within row groups having row group labels)\nthe Column Labels (contains column labels, optionally under spanner labels)\nthe Table Body (contains columns and rows of cells)\nthe Table Footer (optional; possibly with one or more source notes)",
    "crumbs": [
      "Get Started",
      "Overview"
    ]
  },
  {
    "objectID": "get-started/table-theme-premade.html",
    "href": "get-started/table-theme-premade.html",
    "title": "Premade Themes",
    "section": "",
    "text": "Great Tables provides convenience methods starting with opt_ (e.g. GT.opt_row_striping()), as a shortcut for various styles that can be set via GT.tab_options().\nThere are two important kinds of GT.opt_*() methods:\nWe’ll use the basic GT object below for most examples, since it marks some of the table parts.\nfrom great_tables import GT, exibble\n\nlil_exibble = exibble.head(5)[[\"num\", \"char\", \"row\", \"group\"]]\n\ngt_ex = (\n    GT(lil_exibble, rowname_col=\"row\", groupname_col=\"group\")\n    .tab_header(\"THE HEADING\", \"(a subtitle)\")\n    .tab_stubhead(\"THE STUBHEAD\")\n    .tab_source_note(\"THE SOURCE NOTE\")\n)\n\ngt_ex\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n  \n  \n    row_2\n    2.222\n    banana\n  \n  \n    row_3\n    33.33\n    coconut\n  \n  \n    row_4\n    444.4\n    durian\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n  \n\n  \n  \n  \n    THE SOURCE NOTE",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Premade Themes"
    ]
  },
  {
    "objectID": "get-started/table-theme-premade.html#opt_stylize-premade-themes",
    "href": "get-started/table-theme-premade.html#opt_stylize-premade-themes",
    "title": "Premade Themes",
    "section": "opt_stylize(): premade themes",
    "text": "opt_stylize(): premade themes\nBelow are the first two premade styles. The first uses color=\"blue\", and the second uses color=\"red\".\n\n\n\ngt_ex.opt_stylize(style = 1, color = \"blue\")\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n  \n  \n    row_2\n    2.222\n    banana\n  \n  \n    row_3\n    33.33\n    coconut\n  \n  \n    row_4\n    444.4\n    durian\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n  \n\n  \n  \n  \n    THE SOURCE NOTE\n  \n\n\n\n\n\n\n        \n\n\n\n\n\ngt_ex.opt_stylize(style = 2, color = \"red\")\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n  \n  \n    row_2\n    2.222\n    banana\n  \n  \n    row_3\n    33.33\n    coconut\n  \n  \n    row_4\n    444.4\n    durian\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n  \n\n  \n  \n  \n    THE SOURCE NOTE\n  \n\n\n\n\n\n\n        \n\n\n\n\nNotice that first table (blue) emphasizes the row labels with a solid background color. The second table (red) emphasizes the column labels, and uses solid lines to separate the body cell values.\nThere are six styles available, each emphasizing different table parts. The styles are currently numbered 1-6. The options for colors are \"blue\", \"cyan\", \"pink\", \"green\", \"red\", and \"gray\".",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Premade Themes"
    ]
  },
  {
    "objectID": "get-started/table-theme-premade.html#opt_-convenience-methods",
    "href": "get-started/table-theme-premade.html#opt_-convenience-methods",
    "title": "Premade Themes",
    "section": "opt_*() convenience methods",
    "text": "opt_*() convenience methods\nThis section shows the different GT.opt_*() methods available. They serve as convenience methods for common GT.tab_options() tasks.\n\nAlign table header\n\ngt_ex.opt_align_table_header(align=\"left\")\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n  \n  \n    row_2\n    2.222\n    banana\n  \n  \n    row_3\n    33.33\n    coconut\n  \n  \n    row_4\n    444.4\n    durian\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n  \n\n  \n  \n  \n    THE SOURCE NOTE\n  \n\n\n\n\n\n\n        \n\n\n\n\nMake text ALL CAPS\n\ngt_ex.opt_all_caps()\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n  \n  \n    row_2\n    2.222\n    banana\n  \n  \n    row_3\n    33.33\n    coconut\n  \n  \n    row_4\n    444.4\n    durian\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n  \n\n  \n  \n  \n    THE SOURCE NOTE\n  \n\n\n\n\n\n\n        \n\n\n\n\nReduce or expand padding\n\ngt_ex.opt_vertical_padding(scale=0.3)\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n  \n  \n    row_2\n    2.222\n    banana\n  \n  \n    row_3\n    33.33\n    coconut\n  \n  \n    row_4\n    444.4\n    durian\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n  \n\n  \n  \n  \n    THE SOURCE NOTE\n  \n\n\n\n\n\n\n        \n\n\n\ngt_ex.opt_horizontal_padding(scale=3)\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n  \n  \n    row_2\n    2.222\n    banana\n  \n  \n    row_3\n    33.33\n    coconut\n  \n  \n    row_4\n    444.4\n    durian\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n  \n\n  \n  \n  \n    THE SOURCE NOTE\n  \n\n\n\n\n\n\n        \n\n\n\n\nSet table outline\n\ngt_ex.opt_table_outline()\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n  \n  \n    row_2\n    2.222\n    banana\n  \n  \n    row_3\n    33.33\n    coconut\n  \n  \n    row_4\n    444.4\n    durian\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n  \n\n  \n  \n  \n    THE SOURCE NOTE",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Premade Themes"
    ]
  },
  {
    "objectID": "get-started/basic-styling.html",
    "href": "get-started/basic-styling.html",
    "title": "Stying the Table Body",
    "section": "",
    "text": "Great Tables can add styles—like color, text properties, and borders—on many different parts of the displayed table. The following set of examples shows how to set styles on the body of table, where the data cells are located.\nFor the examples on this page, we’ll use the included airquality dataset to set up GT objects for both Pandas and Polars DataFrames.\nimport polars as pl\n\nfrom great_tables import GT, from_column, style, loc\nfrom great_tables.data import airquality\n\nair_head = airquality.head()\n\ngt_air = GT(air_head)\ngt_pl_air = GT(pl.from_pandas(air_head))",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Stying the Table Body"
    ]
  },
  {
    "objectID": "get-started/basic-styling.html#style-basics",
    "href": "get-started/basic-styling.html#style-basics",
    "title": "Stying the Table Body",
    "section": "Style basics",
    "text": "Style basics\nWe use the tab_style() method in combination with loc.body() to set styles on cells of data in the table body. For example, the table-making code below applies a yellow background color to specific cells.\n\ngt_air.tab_style(\n    style=style.fill(color=\"yellow\"),\n    locations=loc.body(columns=\"Temp\", rows=[1, 2])\n)\n\n\n\n\n\n\n  Ozone\n  Solar_R\n  Wind\n  Temp\n  Month\n  Day\n\n\n  \n    41.0\n    190.0\n    7.4\n    67\n    5\n    1\n  \n  \n    36.0\n    118.0\n    8.0\n    72\n    5\n    2\n  \n  \n    12.0\n    149.0\n    12.6\n    74\n    5\n    3\n  \n  \n    18.0\n    313.0\n    11.5\n    62\n    5\n    4\n  \n  \n    \n    \n    14.3\n    56\n    5\n    5\n  \n\n\n\n\n\n\n        \n\n\nThere are two important arguments to tab_style(): style= and locations=. We are calling a specific function for each of these:\n\nstyle.fill(): the type of style to apply. In this case the fill (or background color).\nloc.body(): the area we want to style. In this case, it’s the table body with specific columns and rows specified.\n\nIn addition to style.fill(), several other styling functions exist. We’ll look at styling borders and text in the following sections.\n\nCustomizing Borders\nLet’s use style.borders() to place borders around targeted cells. In this next example, the table has a red dashed border above two rows.\n\ngt_air.tab_style(\n    style=style.borders(sides=\"top\", color=\"red\", style=\"dashed\", weight=\"3px\"),\n    locations=loc.body(rows=[1, 2])\n)\n\n\n\n\n\n\n  Ozone\n  Solar_R\n  Wind\n  Temp\n  Month\n  Day\n\n\n  \n    41.0\n    190.0\n    7.4\n    67\n    5\n    1\n  \n  \n    36.0\n    118.0\n    8.0\n    72\n    5\n    2\n  \n  \n    12.0\n    149.0\n    12.6\n    74\n    5\n    3\n  \n  \n    18.0\n    313.0\n    11.5\n    62\n    5\n    4\n  \n  \n    \n    \n    14.3\n    56\n    5\n    5\n  \n\n\n\n\n\n\n        \n\n\n\n\nCustomizing Text\nWe can style text with by using the style.text() function. This gives us many customization possibilities for any text we target. For example, the Solar_R column below has green, bolded text in a custom font.\n\ngt_air.tab_style(\n    style=style.text(color=\"green\", font=\"Times New Roman\", weight=\"bold\"),\n    locations=loc.body(columns=\"Solar_R\")\n)\n\n\n\n\n\n\n  Ozone\n  Solar_R\n  Wind\n  Temp\n  Month\n  Day\n\n\n  \n    41.0\n    190.0\n    7.4\n    67\n    5\n    1\n  \n  \n    36.0\n    118.0\n    8.0\n    72\n    5\n    2\n  \n  \n    12.0\n    149.0\n    12.6\n    74\n    5\n    3\n  \n  \n    18.0\n    313.0\n    11.5\n    62\n    5\n    4\n  \n  \n    \n    \n    14.3\n    56\n    5\n    5",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Stying the Table Body"
    ]
  },
  {
    "objectID": "get-started/basic-styling.html#column-based-styles",
    "href": "get-started/basic-styling.html#column-based-styles",
    "title": "Stying the Table Body",
    "section": "Column-based Styles",
    "text": "Column-based Styles\nIn addition to setting styles to specific values (e.g., a \"yellow\" background fill), you can also use parameter values from table columns to specify styles. The way to do this is to use the from_column() helper function to access those values.\n\ndf = pl.DataFrame({\"x\": [1, 2], \"background\": [\"lightyellow\", \"lightblue\"]})\n\n(\n    GT(df)\n    .tab_style(\n        style=style.fill(color=from_column(column=\"background\")),\n        locations=loc.body(columns=\"x\")\n    )\n)\n\n\n\n\n\n\n  x\n  background\n\n\n  \n    1\n    lightyellow\n  \n  \n    2\n    lightblue\n  \n\n\n\n\n\n\n        \n\n\nNotice that in the code above, we used values from the background column to specify the fill color for each styled row.\nIn the next few sections, we’ll first show how this combines nicely with the cols_hide() method, then, we’ll demonstrate how to use Polars expressions to do everything much more simply.\n\nCombining Styling with cols_hide()\nOne common approach is to specify a style from a column, and then hide that column in the final output. For example, we can add a background column to our airquality data:\n\ncolor_map = {\n    True: \"lightyellow\",\n    False: \"lightblue\"\n}\n\nwith_color = air_head.assign(\n    background=(air_head[\"Temp\"] &gt; 70).replace(color_map)\n)\n\nwith_color\n\n\n\n\n  \n    \n      \n      Ozone\n      Solar_R\n      Wind\n      Temp\n      Month\n      Day\n      background\n    \n  \n  \n    \n      0\n      41.0\n      190.0\n      7.4\n      67\n      5\n      1\n      lightblue\n    \n    \n      1\n      36.0\n      118.0\n      8.0\n      72\n      5\n      2\n      lightyellow\n    \n    \n      2\n      12.0\n      149.0\n      12.6\n      74\n      5\n      3\n      lightyellow\n    \n    \n      3\n      18.0\n      313.0\n      11.5\n      62\n      5\n      4\n      lightblue\n    \n    \n      4\n      NaN\n      NaN\n      14.3\n      56\n      5\n      5\n      lightblue\n    \n  \n\n\n\n\nNotice that the dataset now has a background column set to either \"lightyellow\" or \"lightblue\", depending on whether Temp is above 70.\nWe can then use this background column to set the fill color of certain body cells, and then hide the background column since we don’t need that in our finalized display table:\n\n(\n    GT(with_color)\n    .tab_style(\n        style=style.fill(color=from_column(column=\"background\")),\n        locations=loc.body(columns=\"Temp\")\n    )\n    .cols_hide(columns=\"background\")\n)\n\n\n\n\n\n\n  Ozone\n  Solar_R\n  Wind\n  Temp\n  Month\n  Day\n\n\n  \n    41.0\n    190.0\n    7.4\n    67\n    5\n    1\n  \n  \n    36.0\n    118.0\n    8.0\n    72\n    5\n    2\n  \n  \n    12.0\n    149.0\n    12.6\n    74\n    5\n    3\n  \n  \n    18.0\n    313.0\n    11.5\n    62\n    5\n    4\n  \n  \n    \n    \n    14.3\n    56\n    5\n    5\n  \n\n\n\n\n\n\n        \n\n\nNote the two methods used above:\n\ntab_style(): uses from_column() to set the color using the values of the background column.\ncols_hide(): prevents the background column from being displayed in the output.\n\n\n\nUsing Polars expressions\nStyles can also be specified using Polars expressions. For example, the code below uses the Temp column to set color to \"lightyellow\" or \"lightblue\".\n\n# A Polars expression defines color based on `Temp`\ntemp_color = (\n    pl.when(pl.col(\"Temp\") &gt; 70)\n    .then(pl.lit(\"lightyellow\"))\n    .otherwise(pl.lit(\"lightblue\"))\n)\n\ngt_pl_air.tab_style(\n    style=style.fill(color=temp_color),\n    locations=loc.body(\"Temp\")\n)\n\n\n\n\n\n\n  Ozone\n  Solar_R\n  Wind\n  Temp\n  Month\n  Day\n\n\n  \n    41.0\n    190.0\n    7.4\n    67\n    5\n    1\n  \n  \n    36.0\n    118.0\n    8.0\n    72\n    5\n    2\n  \n  \n    12.0\n    149.0\n    12.6\n    74\n    5\n    3\n  \n  \n    18.0\n    313.0\n    11.5\n    62\n    5\n    4\n  \n  \n    None\n    None\n    14.3\n    56\n    5\n    5\n  \n\n\n\n\n\n\n        \n\n\n\n\nUsing functions\nYou can also use a function, that takes the DataFrame and returns a Series with a style value for each row.\nThis is shown below on a pandas DataFrame.\n\ndef map_color(df):\n    return (df[\"Temp\"] &gt; 70).map(\n        {True: \"lightyellow\", False: \"lightblue\"}\n    )\n\ngt_air.tab_style(\n    style=style.fill(\n        color=map_color),\n    locations=loc.body(\"Temp\")\n)\n\n\n\n\n\n\n  Ozone\n  Solar_R\n  Wind\n  Temp\n  Month\n  Day\n\n\n  \n    41.0\n    190.0\n    7.4\n    67\n    5\n    1\n  \n  \n    36.0\n    118.0\n    8.0\n    72\n    5\n    2\n  \n  \n    12.0\n    149.0\n    12.6\n    74\n    5\n    3\n  \n  \n    18.0\n    313.0\n    11.5\n    62\n    5\n    4\n  \n  \n    \n    \n    14.3\n    56\n    5\n    5",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Stying the Table Body"
    ]
  },
  {
    "objectID": "get-started/basic-styling.html#specifying-columns-and-rows",
    "href": "get-started/basic-styling.html#specifying-columns-and-rows",
    "title": "Stying the Table Body",
    "section": "Specifying columns and rows",
    "text": "Specifying columns and rows\n\nUsing polars selectors\nIf you are using Polars, you can use column selectors and expressions for selecting specific columns and rows:\n\nimport polars.selectors as cs\n\ngt_pl_air.tab_style(\n    style=style.fill(color=\"yellow\"),\n    locations=loc.body(\n        columns=cs.starts_with(\"Te\"),\n        rows=pl.col(\"Temp\") &gt; 70\n    )\n)\n\n\n\n\n\n\n  Ozone\n  Solar_R\n  Wind\n  Temp\n  Month\n  Day\n\n\n  \n    41.0\n    190.0\n    7.4\n    67\n    5\n    1\n  \n  \n    36.0\n    118.0\n    8.0\n    72\n    5\n    2\n  \n  \n    12.0\n    149.0\n    12.6\n    74\n    5\n    3\n  \n  \n    18.0\n    313.0\n    11.5\n    62\n    5\n    4\n  \n  \n    None\n    None\n    14.3\n    56\n    5\n    5\n  \n\n\n\n\n\n\n        \n\n\nSee Column Selection for details on selecting columns.\n\n\nUsing a function\nFor tools like pandas, you can use a function (or lambda) to select rows. The function should take a DataFrame, and output a boolean Series.\n\ngt_air.tab_style(\n    style=style.fill(color=\"yellow\"),\n    locations=loc.body(\n        columns=lambda col_name: col_name.startswith(\"Te\"),\n        rows=lambda D: D[\"Temp\"] &gt; 70,\n    )\n)\n\n\n\n\n\n\n  Ozone\n  Solar_R\n  Wind\n  Temp\n  Month\n  Day\n\n\n  \n    41.0\n    190.0\n    7.4\n    67\n    5\n    1\n  \n  \n    36.0\n    118.0\n    8.0\n    72\n    5\n    2\n  \n  \n    12.0\n    149.0\n    12.6\n    74\n    5\n    3\n  \n  \n    18.0\n    313.0\n    11.5\n    62\n    5\n    4\n  \n  \n    \n    \n    14.3\n    56\n    5\n    5",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Stying the Table Body"
    ]
  },
  {
    "objectID": "get-started/basic-styling.html#multiple-styles-and-locations",
    "href": "get-started/basic-styling.html#multiple-styles-and-locations",
    "title": "Stying the Table Body",
    "section": "Multiple styles and locations",
    "text": "Multiple styles and locations\nWe can use a list within style= to apply multiple styles at once. For example, the code below sets fill and border styles on the same set of body cells.\n\ngt_air.tab_style(\n    style=[style.fill(color=\"yellow\"), style.borders(sides=\"all\")],\n    locations=loc.body(columns=\"Temp\", rows=[1, 2]),\n)\n\n\n\n\n\n\n  Ozone\n  Solar_R\n  Wind\n  Temp\n  Month\n  Day\n\n\n  \n    41.0\n    190.0\n    7.4\n    67\n    5\n    1\n  \n  \n    36.0\n    118.0\n    8.0\n    72\n    5\n    2\n  \n  \n    12.0\n    149.0\n    12.6\n    74\n    5\n    3\n  \n  \n    18.0\n    313.0\n    11.5\n    62\n    5\n    4\n  \n  \n    \n    \n    14.3\n    56\n    5\n    5\n  \n\n\n\n\n\n\n        \n\n\nNote that you can also pass a list to locations=!\n\ngt_air.tab_style(\n    style=style.fill(color=\"yellow\"),\n    locations=[\n        loc.body(columns=\"Temp\", rows=[1, 2]),\n        loc.body(columns=\"Ozone\", rows=[0])\n    ]\n)\n\n\n\n\n\n\n  Ozone\n  Solar_R\n  Wind\n  Temp\n  Month\n  Day\n\n\n  \n    41.0\n    190.0\n    7.4\n    67\n    5\n    1\n  \n  \n    36.0\n    118.0\n    8.0\n    72\n    5\n    2\n  \n  \n    12.0\n    149.0\n    12.6\n    74\n    5\n    3\n  \n  \n    18.0\n    313.0\n    11.5\n    62\n    5\n    4\n  \n  \n    \n    \n    14.3\n    56\n    5\n    5\n  \n\n\n\n\n\n\n        \n\n\nYou can also combine Polars selectors with a row filtering expression, in order to select a combination of columns and rows.\n\nimport polars.selectors as cs\n\ngt_pl_air.tab_style(\n    style=style.fill(color=\"yellow\"),\n    locations=loc.body(\n        columns=cs.all().exclude([\"Month\", \"Day\"]),\n        rows=pl.col(\"Temp\") == pl.col(\"Temp\").max()\n    )\n)\n\n\n\n\n\n\n  Ozone\n  Solar_R\n  Wind\n  Temp\n  Month\n  Day\n\n\n  \n    41.0\n    190.0\n    7.4\n    67\n    5\n    1\n  \n  \n    36.0\n    118.0\n    8.0\n    72\n    5\n    2\n  \n  \n    12.0\n    149.0\n    12.6\n    74\n    5\n    3\n  \n  \n    18.0\n    313.0\n    11.5\n    62\n    5\n    4\n  \n  \n    None\n    None\n    14.3\n    56\n    5\n    5",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Stying the Table Body"
    ]
  },
  {
    "objectID": "get-started/basic-styling.html#learning-more",
    "href": "get-started/basic-styling.html#learning-more",
    "title": "Stying the Table Body",
    "section": "Learning more",
    "text": "Learning more\n\nAPI Docs:\n\nGT.tab_style().\nstyle.* and loc.* functions.\nfrom_column().",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Stying the Table Body"
    ]
  },
  {
    "objectID": "get-started/basic-stub.html",
    "href": "get-started/basic-stub.html",
    "title": "Stub (Row Labels)",
    "section": "",
    "text": "The Stub component of a table is the area to the left that typically contains row labels and may also contain row group labels. Those subparts can be grouped in a sequence of row groups. The Stub Head provides a location for a label that describes the Stub (and could also be used to describe the column labels). The Stub is optional since there are cases where a Stub wouldn’t be useful (the display tables presented in the previous section looked just fine without a Stub).",
    "crumbs": [
      "Get Started",
      "Table Structure",
      "Stub (Row Labels)"
    ]
  },
  {
    "objectID": "get-started/basic-stub.html#row-names",
    "href": "get-started/basic-stub.html#row-names",
    "title": "Stub (Row Labels)",
    "section": "Row names",
    "text": "Row names\nAn easy way to generate a Stub part is by specifying a stub column in the GT() class with the rowname_col= argument. This will signal to Great Tables that the named column should be used as the stub, using the contents of that column to make row labels. Let’s add a stub with our islands dataset by using rowname_col= in the call to GT():\n\nfrom great_tables import GT, md, html\nfrom great_tables.data import islands\n\nislands_mini = islands.head(10)\n\nGT(islands_mini, rowname_col=\"name\")\n\n\n\n\n\n\n  \n  size\n\n\n  \n    Africa\n    11506\n  \n  \n    Antarctica\n    5500\n  \n  \n    Asia\n    16988\n  \n  \n    Australia\n    2968\n  \n  \n    Axel Heiberg\n    16\n  \n  \n    Baffin\n    184\n  \n  \n    Banks\n    23\n  \n  \n    Borneo\n    280\n  \n  \n    Britain\n    84\n  \n  \n    Celebes\n    73\n  \n\n\n\n\n\n\n        \n\n\nNotice that the landmass names are now placed to the left? That’s the Stub. Notably, there is a prominent border to the right of it but there’s no label above the Stub. We can change this and apply what’s known as a stubhead label through use of the tab_stubhead() method:\n\n(\n    GT(islands_mini, rowname_col=\"name\")\n    .tab_stubhead(label=\"landmass\")\n)\n\n\n\n\n\n\n  landmass\n  size\n\n\n  \n    Africa\n    11506\n  \n  \n    Antarctica\n    5500\n  \n  \n    Asia\n    16988\n  \n  \n    Australia\n    2968\n  \n  \n    Axel Heiberg\n    16\n  \n  \n    Baffin\n    184\n  \n  \n    Banks\n    23\n  \n  \n    Borneo\n    280\n  \n  \n    Britain\n    84\n  \n  \n    Celebes\n    73\n  \n\n\n\n\n\n\n        \n\n\nA very important thing to note here is that the table now has one column. Before, when there was no Stub, two columns were present (with the Column Labels of \"name\" and \"size\") but now column number 1 (the only column remaining) is size.",
    "crumbs": [
      "Get Started",
      "Table Structure",
      "Stub (Row Labels)"
    ]
  },
  {
    "objectID": "get-started/basic-stub.html#row-groups",
    "href": "get-started/basic-stub.html#row-groups",
    "title": "Stub (Row Labels)",
    "section": "Row groups",
    "text": "Row groups\nLet’s incorporate row groups into the display table. This divides rows into groups, creating row groups, and results in a display of a row group labels right above the each group. This can be easily done with a table containing row labels and the key is to use the groupname_col= argument of the GT() class. Here we will create three row groups (with row group labels \"continent\", \"country\", and \"subregion\") to have a grouping of rows.\n\nisland_groups = islands.head(10).assign(group = [\"subregion\"] * 2 + [\"country\"] * 2 + [\"continent\"] * 6)\n\nGT(island_groups, rowname_col=\"name\", groupname_col=\"group\").tab_stubhead(label=\"landmass\")\n\n\n\n\n\n\n  landmass\n  size\n\n\n  \n    subregion\n  \n  \n    Africa\n    11506\n  \n  \n    Antarctica\n    5500\n  \n  \n    country\n  \n  \n    Asia\n    16988\n  \n  \n    Australia\n    2968\n  \n  \n    continent\n  \n  \n    Axel Heiberg\n    16\n  \n  \n    Baffin\n    184\n  \n  \n    Banks\n    23\n  \n  \n    Borneo\n    280\n  \n  \n    Britain\n    84\n  \n  \n    Celebes\n    73",
    "crumbs": [
      "Get Started",
      "Table Structure",
      "Stub (Row Labels)"
    ]
  },
  {
    "objectID": "get-started/column-selection.html",
    "href": "get-started/column-selection.html",
    "title": "Column Selection",
    "section": "",
    "text": "The columns= argument for methods like GT.tab_spanner(), GT.cols_move(), and GT.tab_style allows a range of options for selecting columns.\nThe simplest approach is just a list of strings with the exact column names. However, we can specify columns using any of the following:\nfrom great_tables import GT\nfrom great_tables.data import exibble\n\nlil_exibble = exibble[[\"num\", \"char\", \"fctr\", \"date\", \"time\"]].head(4)\ngt_ex = GT(lil_exibble)\n\ngt_ex\n\n\n\n\n\n\n  num\n  char\n  fctr\n  date\n  time\n\n\n  \n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n  \n  \n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n  \n  \n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n  \n  \n    444.4\n    durian\n    four\n    2015-04-15\n    16:50",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Column Selection"
    ]
  },
  {
    "objectID": "get-started/column-selection.html#using-integers",
    "href": "get-started/column-selection.html#using-integers",
    "title": "Column Selection",
    "section": "Using integers",
    "text": "Using integers\nWe can use a list of strings or integers to select columns by name or position, respectively.\n\ngt_ex.cols_move_to_start(columns=[\"date\", 1, -1])\n\n\n\n\n\n\n  date\n  char\n  time\n  num\n  fctr\n\n\n  \n    2015-01-15\n    apricot\n    13:35\n    0.1111\n    one\n  \n  \n    2015-02-15\n    banana\n    14:40\n    2.222\n    two\n  \n  \n    2015-03-15\n    coconut\n    15:45\n    33.33\n    three\n  \n  \n    2015-04-15\n    durian\n    16:50\n    444.4\n    four\n  \n\n\n\n\n\n\n        \n\n\nNote the code above moved the following columns:\n\nThe string \"date\" matched the column of the same name.\nThe integer 1 matched the second column (this is similar to list indexing).\nThe integer -1 matched the last column.\n\nMoreover, the order of the list defines the order of selected columns. In this case, \"data\" was the first entry, so it’s the very first column in the new table.",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Column Selection"
    ]
  },
  {
    "objectID": "get-started/column-selection.html#using-polars-selectors",
    "href": "get-started/column-selection.html#using-polars-selectors",
    "title": "Column Selection",
    "section": "Using Polars selectors",
    "text": "Using Polars selectors\nWhen using a Polars DataFrame, you can select columns using Polars selectors. The example below uses Polars selectors to move all columns that start with \"c\" or \"f\" to the start of the table.\n\nimport polars as pl\nimport polars.selectors as cs\n\npl_df = pl.from_pandas(lil_exibble)\n\nGT(pl_df).cols_move_to_start(columns=cs.starts_with(\"c\") | cs.starts_with(\"f\"))\n\n\n\n\n\n\n  char\n  fctr\n  num\n  date\n  time\n\n\n  \n    apricot\n    one\n    0.1111\n    2015-01-15\n    13:35\n  \n  \n    banana\n    two\n    2.222\n    2015-02-15\n    14:40\n  \n  \n    coconut\n    three\n    33.33\n    2015-03-15\n    15:45\n  \n  \n    durian\n    four\n    444.4\n    2015-04-15\n    16:50\n  \n\n\n\n\n\n\n        \n\n\nIn general, selection should match the behaviors of the Polars DataFrame.select() method.\n\npl_df.select(cs.starts_with(\"c\") | cs.starts_with(\"f\")).columns\n\n['char', 'fctr']\n\n\nSee the Selectors page in the polars docs for more information on this.",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Column Selection"
    ]
  },
  {
    "objectID": "get-started/column-selection.html#using-functions",
    "href": "get-started/column-selection.html#using-functions",
    "title": "Column Selection",
    "section": "Using functions",
    "text": "Using functions\nA function can be used to select columns. It should take a column name as a string and return True or False.\n\ngt_ex.cols_move_to_start(columns=lambda x: \"c\" in x)\n\n\n\n\n\n\n  char\n  fctr\n  num\n  date\n  time\n\n\n  \n    apricot\n    one\n    0.1111\n    2015-01-15\n    13:35\n  \n  \n    banana\n    two\n    2.222\n    2015-02-15\n    14:40\n  \n  \n    coconut\n    three\n    33.33\n    2015-03-15\n    15:45\n  \n  \n    durian\n    four\n    444.4\n    2015-04-15\n    16:50",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Column Selection"
    ]
  },
  {
    "objectID": "examples/index.html",
    "href": "examples/index.html",
    "title": "Examples",
    "section": "",
    "text": "Show the Code\nimport polars as pl\nfrom great_tables import GT, md, html\nfrom great_tables.data import islands\n\nislands_mini = (\n    pl.from_pandas(islands).sort(\"size\", descending=True)\n    .head(10)\n)\n\n(\n    GT(islands_mini, rowname_col=\"name\")\n    .tab_header(\n        title=\"Large Landmasses of the World\",\n        subtitle=\"The top ten largest are presented\"\n    )\n    .tab_source_note(source_note=\"Source: The World Almanac and Book of Facts, 1975, page 406.\")\n    .tab_source_note(\n        source_note=md(\"Reference: McNeil, D. R. (1977) *Interactive Data Analysis*. Wiley.\")\n    )\n    .tab_stubhead(label=\"landmass\")\n    .fmt_integer(columns=\"size\")\n)\n\n\n\n\n\n\n  \n    Large Landmasses of the World\n  \n  \n    The top ten largest are presented\n  \n\n\n  landmass\n  size\n\n\n  \n    Asia\n    16,988\n  \n  \n    Africa\n    11,506\n  \n  \n    North America\n    9,390\n  \n  \n    South America\n    6,795\n  \n  \n    Antarctica\n    5,500\n  \n  \n    Europe\n    3,745\n  \n  \n    Australia\n    2,968\n  \n  \n    Greenland\n    840\n  \n  \n    New Guinea\n    306\n  \n  \n    Borneo\n    280\n  \n\n  \n  \n  \n    Source: The World Almanac and Book of Facts, 1975, page 406.\n  \n\n\n  \n    Reference: McNeil, D. R. (1977) Interactive Data Analysis. Wiley.\n  \n\n\n\n\n\n\n        \n\n\n\n\n\n\nShow the Code\nfrom great_tables import GT, html\nfrom great_tables.data import airquality\n\nairquality_mini = airquality.head(10).assign(Year = 1973)\n\n(\n    GT(airquality_mini)\n    .tab_header(\n        title=\"New York Air Quality Measurements\",\n        subtitle=\"Daily measurements in New York City (May 1-10, 1973)\"\n    )\n    .tab_spanner(\n        label=\"Time\",\n        columns=[\"Year\", \"Month\", \"Day\"]\n    )\n    .tab_spanner(\n        label=\"Measurement\",\n        columns=[\"Ozone\", \"Solar_R\", \"Wind\", \"Temp\"]\n    )\n    .cols_move_to_start(columns=[\"Year\", \"Month\", \"Day\"])\n    .cols_label(\n        Ozone = html(\"Ozone,&lt;br&gt;ppbV\"),\n        Solar_R = html(\"Solar R.,&lt;br&gt;cal/m&lt;sup&gt;2&lt;/sup&gt;\"),\n        Wind = html(\"Wind,&lt;br&gt;mph\"),\n        Temp = html(\"Temp,&lt;br&gt;&deg;F\")\n    )\n)\n\n\n\n\n\n\n  \n    New York Air Quality Measurements\n  \n  \n    Daily measurements in New York City (May 1-10, 1973)\n  \n\n\n  \n    Time\n  \n  \n    Measurement\n  \n\n\n  Year\n  Month\n  Day\n  Ozone,ppbV\n  Solar R.,cal/m2\n  Wind,mph\n  Temp,°F\n\n\n  \n    1973\n    5\n    1\n    41.0\n    190.0\n    7.4\n    67\n  \n  \n    1973\n    5\n    2\n    36.0\n    118.0\n    8.0\n    72\n  \n  \n    1973\n    5\n    3\n    12.0\n    149.0\n    12.6\n    74\n  \n  \n    1973\n    5\n    4\n    18.0\n    313.0\n    11.5\n    62\n  \n  \n    1973\n    5\n    5\n    \n    \n    14.3\n    56\n  \n  \n    1973\n    5\n    6\n    28.0\n    \n    14.9\n    66\n  \n  \n    1973\n    5\n    7\n    23.0\n    299.0\n    8.6\n    65\n  \n  \n    1973\n    5\n    8\n    19.0\n    99.0\n    13.8\n    59\n  \n  \n    1973\n    5\n    9\n    8.0\n    19.0\n    20.1\n    61\n  \n  \n    1973\n    5\n    10\n    \n    194.0\n    8.6\n    69\n  \n\n\n\n\n\n\n        \n\n\n\n\n\n\nShow the Code\nfrom great_tables import GT\nfrom great_tables.data import countrypops\nimport polars as pl\nimport polars.selectors as cs\n\n# Get vectors of 2-letter country codes for each region of Oceania\noceania = {\n    \"Australasia\": [\"AU\", \"NZ\"],\n    \"Melanesia\": [\"NC\", \"PG\", \"SB\", \"VU\"],\n    \"Micronesia\": [\"FM\", \"GU\", \"KI\", \"MH\", \"MP\", \"NR\", \"PW\"],\n    \"Polynesia\": [\"PF\", \"WS\", \"TO\", \"TV\"],\n}\n\n# Create a dictionary mapping country to region (e.g. AU -&gt; Australasia)\ncountry_to_region = {\n    country: region for region, countries in oceania.items() for country in countries\n}\n\nwide_pops = (\n    pl.from_pandas(countrypops)\n    .filter(\n        pl.col(\"country_code_2\").is_in(list(country_to_region))\n        & pl.col(\"year\").is_in([2000, 2010, 2020])\n    )\n    .with_columns(pl.col(\"country_code_2\").replace(country_to_region).alias(\"region\"))\n    .pivot(index=[\"country_name\", \"region\"], columns=\"year\", values=\"population\")\n    .sort(\"2020\", descending=True)\n)\n\n(\n    GT(wide_pops, rowname_col=\"country_name\", groupname_col=\"region\")\n    .tab_header(title=\"Populations of Oceania's Countries in 2000, 2010, and 2020\")\n    .tab_spanner(label=\"Total Population\", columns=cs.all())\n    .fmt_integer()\n)\n\n\n\n\n\n\n  \n    Populations of Oceania's Countries in 2000, 2010, and 2020\n  \n\n\n  \n  \n    Total Population\n  \n\n\n  2000\n  2010\n  2020\n\n\n  \n    Australasia\n  \n  \n    Australia\n    19,028,802\n    22,031,750\n    25,655,289\n  \n  \n    New Zealand\n    3,857,700\n    4,350,700\n    5,090,200\n  \n  \n    Melanesia\n  \n  \n    Papua New Guinea\n    5,508,297\n    7,583,269\n    9,749,640\n  \n  \n    Solomon Islands\n    429,978\n    540,394\n    691,191\n  \n  \n    Vanuatu\n    192,074\n    245,453\n    311,685\n  \n  \n    New Caledonia\n    213,230\n    249,750\n    272,460\n  \n  \n    Polynesia\n  \n  \n    French Polynesia\n    250,927\n    283,788\n    301,920\n  \n  \n    Samoa\n    184,008\n    194,672\n    214,929\n  \n  \n    Tonga\n    102,603\n    107,383\n    105,254\n  \n  \n    Tuvalu\n    9,638\n    10,550\n    11,069\n  \n  \n    Micronesia\n  \n  \n    Guam\n    160,188\n    164,905\n    169,231\n  \n  \n    Kiribati\n    88,826\n    107,995\n    126,463\n  \n  \n    Micronesia (Federated States)\n    111,709\n    107,588\n    112,106\n  \n  \n    Northern Mariana Islands\n    80,338\n    54,087\n    49,587\n  \n  \n    Marshall Islands\n    54,224\n    53,416\n    43,413\n  \n  \n    Palau\n    19,726\n    18,540\n    17,972\n  \n  \n    Nauru\n    10,377\n    10,241\n    12,315\n  \n\n\n\n\n\n\n        \n\n\n\n\n\n\nShow the Code\nfrom great_tables import GT, html\nfrom great_tables.data import towny\n\ntowny_mini = (\n    towny[[\"name\", \"website\", \"density_2021\", \"land_area_km2\", \"latitude\", \"longitude\"]]\n    .sort_values(\"density_2021\", ascending=False)\n    .head(10)\n)\n\ntowny_mini[\"url_name\"] = [\"[\"] + towny_mini[\"name\"] + [\"]\"] + [\"(\"] + towny_mini[\"website\"] + [\")\"]\n\ntowny_mini[\"location\"] = (\n    [\"[map](http://maps.google.com/?ie=UTF8&hq=&ll=\"]\n    + towny_mini[\"latitude\"].astype(str)\n    + [\",\"]\n    + towny_mini[\"longitude\"].astype(str)\n    + [\"&z=13)\"]\n)\n\n(\n    GT(\n        towny_mini[[\"url_name\", \"location\", \"land_area_km2\", \"density_2021\"]],\n        rowname_col=\"url_name\",\n    )\n    .tab_header(\n        title=\"The Municipalities of Ontario\",\n        subtitle=\"The top 10 highest population density in 2021\",\n    )\n    .tab_stubhead(label=\"Municipality\")\n    .fmt_markdown(columns=[\"url_name\", \"location\"])\n    .fmt_number(columns=[\"land_area_km2\", \"density_2021\"], decimals=1)\n    .cols_label(\n        land_area_km2=html(\"land area, &lt;br&gt;km&lt;sup&gt;2&lt;/sup&gt;\"),\n        density_2021=html(\"density, &lt;br&gt;people/km&lt;sup&gt;2&lt;/sup&gt;\"),\n    )\n)\n\n\n\n\n\n\n  \n    The Municipalities of Ontario\n  \n  \n    The top 10 highest population density in 2021\n  \n\n\n  Municipality\n  location\n  land area, km2\n  density, people/km2\n\n\n  \n    Toronto\n    map\n    631.1\n    4,427.8\n  \n  \n    Brampton\n    map\n    265.9\n    2,469.0\n  \n  \n    Mississauga\n    map\n    292.7\n    2,452.6\n  \n  \n    Newmarket\n    map\n    38.5\n    2,284.2\n  \n  \n    Richmond Hill\n    map\n    100.8\n    2,004.4\n  \n  \n    Orangeville\n    map\n    15.2\n    1,989.9\n  \n  \n    Ajax\n    map\n    66.6\n    1,900.8\n  \n  \n    Waterloo\n    map\n    64.1\n    1,895.7\n  \n  \n    Kitchener\n    map\n    136.8\n    1,877.7\n  \n  \n    Guelph\n    map\n    87.4\n    1,644.1\n  \n\n\n\n\n\n\n        \n\n\n\n\n\n\nShow the Code\nfrom great_tables import GT, html\nfrom great_tables.data import sza\nimport polars as pl\nimport polars.selectors as cs\n\nsza_pivot = (\n    pl.from_pandas(sza)\n    .filter((pl.col(\"latitude\") == \"20\") & (pl.col(\"tst\") &lt;= \"1200\"))\n    .select(pl.col(\"*\").exclude(\"latitude\"))\n    .drop_nulls()\n    .pivot(values=\"sza\", index=\"month\", columns=\"tst\", sort_columns=True)\n)\n\n(\n    GT(sza_pivot, rowname_col=\"month\")\n    .data_color(\n        domain=[90, 0],\n        palette=[\"rebeccapurple\", \"white\", \"orange\"],\n        na_color=\"white\",\n    )\n    .tab_header(\n        title=\"Solar Zenith Angles from 05:30 to 12:00\",\n        subtitle=html(\"Average monthly values at latitude of 20&deg;N.\"),\n    )\n    .sub_missing(missing_text=\"\")\n)\n\n\n\n\n\n\n  \n    Solar Zenith Angles from 05:30 to 12:00\n  \n  \n    Average monthly values at latitude of 20°N.\n  \n\n\n  \n  0530\n  0600\n  0630\n  0700\n  0730\n  0800\n  0830\n  0900\n  0930\n  1000\n  1030\n  1100\n  1130\n  1200\n\n\n  \n    jan\n    \n    \n    \n    84.9\n    78.7\n    72.7\n    66.1\n    61.5\n    56.5\n    52.1\n    48.3\n    45.5\n    43.6\n    43.0\n  \n  \n    feb\n    \n    \n    88.9\n    82.5\n    75.8\n    69.6\n    63.3\n    57.7\n    52.2\n    47.4\n    43.1\n    40.0\n    37.8\n    37.2\n  \n  \n    mar\n    \n    \n    85.7\n    78.8\n    72.0\n    65.2\n    58.6\n    52.3\n    46.2\n    40.5\n    35.5\n    31.4\n    28.6\n    27.7\n  \n  \n    apr\n    \n    88.5\n    81.5\n    74.4\n    67.4\n    60.3\n    53.4\n    46.5\n    39.7\n    33.2\n    26.9\n    21.3\n    17.2\n    15.5\n  \n  \n    may\n    \n    85.0\n    78.2\n    71.2\n    64.3\n    57.2\n    50.2\n    43.2\n    36.1\n    29.1\n    26.1\n    15.2\n    8.8\n    5.0\n  \n  \n    jun\n    89.2\n    82.7\n    76.0\n    69.3\n    62.5\n    55.7\n    48.8\n    41.9\n    35.0\n    28.1\n    21.1\n    14.2\n    7.3\n    2.0\n  \n  \n    jul\n    88.8\n    82.3\n    75.7\n    69.1\n    62.3\n    55.5\n    48.7\n    41.8\n    35.0\n    28.1\n    21.2\n    14.3\n    7.7\n    3.1\n  \n  \n    aug\n    \n    83.8\n    77.1\n    70.2\n    63.3\n    56.4\n    49.4\n    42.4\n    35.4\n    28.3\n    21.3\n    14.3\n    7.3\n    1.9\n  \n  \n    sep\n    \n    87.2\n    80.2\n    73.2\n    66.1\n    59.1\n    52.1\n    45.1\n    38.1\n    31.3\n    24.7\n    18.6\n    13.7\n    11.6\n  \n  \n    oct\n    \n    \n    84.1\n    77.1\n    70.2\n    63.3\n    56.5\n    49.9\n    43.5\n    37.5\n    32.0\n    27.4\n    24.3\n    23.1\n  \n  \n    nov\n    \n    \n    87.8\n    81.3\n    74.5\n    68.3\n    61.8\n    56.0\n    50.2\n    45.3\n    40.7\n    37.4\n    35.1\n    34.4\n  \n  \n    dec\n    \n    \n    \n    84.3\n    78.0\n    71.8\n    66.1\n    60.5\n    55.6\n    50.9\n    47.2\n    44.2\n    42.4\n    41.8\n  \n\n\n\n\n\n\n        \n\n\n\n\nView notebook ⬀\n\n\n\n\n\n\n  \n    Highest Paid Athletes in 2023\n  \n\n  \n  Name\n  icon\n  Sport\n  \n    Earnings\n  \n\n\n  Total $M\n  Off field $M\n  Off field %\n\n\n\n  1\n  Cristiano Ronaldo\n  \n  Soccer\n  136.0\n  90.0\n                      \n\n\n  2\n  Lionel Messi\n  \n  Soccer\n  130.0\n  65.0\n                      \n\n\n  3\n  Kylian Mbappé\n  \n  Soccer\n  120.0\n  20.0\n                      \n\n\n  4\n  LeBron James\n  \n  Basketball\n  119.5\n  75.0\n                      \n\n\n  5\n  Canelo Alvarez\n  \n  Boxing\n  110.0\n  10.0\n                      \n\n\n  6\n  Dustin Johnson\n  \n  Golf\n  107.0\n  5.0\n                      \n\n\n  7\n  Phil Mickelson\n  \n  Golf\n  106.0\n  2.0\n                      \n\n\n  8\n  Stephen Curry\n  \n  Basketball\n  100.4\n  52.0\n                      \n\n\n  9\n  Roger Federer\n  \n  Tennis\n  95.1\n  95.0\n                      \n\n\n  \n  \n  \n    Original table: @LisaHornung_ | Sports icons: Firza Alamsyah | Data: Forbes"
  },
  {
    "objectID": "examples/sports-earnings/index.html",
    "href": "examples/sports-earnings/index.html",
    "title": "great_tables",
    "section": "",
    "text": "import polars as pl\nimport polars.selectors as cs\nfrom great_tables import GT, md\n\n\ndef create_bar(prop_fill: float, max_width: int, height: int) -&gt; str:\n    \"\"\"Create divs to represent prop_fill as a bar.\"\"\"\n    width = round(max_width * prop_fill, 2)\n    px_width = f\"{width}px\"\n    return f\"\"\"\\\n    &lt;div style=\"width: {max_width}px; background-color: lightgrey;\"&gt;\\\n        &lt;div style=\"height:{height}px;width:{px_width};background-color:green;\"&gt;&lt;/div&gt;\\\n    &lt;/div&gt;\\\n    \"\"\"\n\n\ndf = pl.read_csv(\"./sports_earnings.csv\")\n\nres = (\n    df.with_columns(\n        (pl.col(\"Off-the-Field Earnings\") / pl.col(\"Total Earnings\")).alias(\"raw_perc\"),\n        (pl.col(\"Sport\").str.to_lowercase() + \".png\").alias(\"icon\"),\n    )\n    .head(9)\n    .with_columns(\n        pl.col(\"raw_perc\")\n          .map_elements(lambda x: create_bar(x, max_width=75, height=20))\n          .alias(\"Off-the-Field Earnings Perc\")\n    )\n    .select(\"Rank\", \"Name\", \"icon\", \"Sport\", \"Total Earnings\", \"Off-the-Field Earnings\", \"Off-the-Field Earnings Perc\")\n)\n\n\n\n(\n    GT(res, rowname_col=\"Rank\")\n    .tab_header(\"Highest Paid Athletes in 2023\")\n    .tab_spanner(\"Earnings\", cs.contains(\"Earnings\"))\n    #.fmt_number(cs.starts_with(\"Total\"), scale_by = 1/1_000_000, decimals=1)\n    .cols_label(**{\n        \"Total Earnings\": \"Total $M\",\n        \"Off-the-Field Earnings\": \"Off field $M\",\n        \"Off-the-Field Earnings Perc\": \"Off field %\"\n    })\n    .fmt_number([\"Total Earnings\", \"Off-the-Field Earnings\"], scale_by = 1/1_000_000, decimals=1)\n    .fmt_image(\"icon\", path=\"./\")\n    .tab_source_note(\n        md(\n            '&lt;br&gt;&lt;div style=\"text-align: center;\"&gt;'\n            \"Original table: [@LisaHornung_](https://twitter.com/LisaHornung_/status/1752981867769266231)\"\n            \" | Sports icons: [Firza Alamsyah](https://thenounproject.com/browse/collection-icon/sports-96427)\"\n            \" | Data: Forbes\"\n            \"&lt;/div&gt;\"\n            \"&lt;br&gt;\"\n        )\n    )\n)\n\n\n\n\n  \n    Highest Paid Athletes in 2023\n  \n\n  \n  Name\n  icon\n  Sport\n  \n    Earnings\n  \n\n\n  Total $M\n  Off field $M\n  Off field %\n\n\n\n  1\n  Cristiano Ronaldo\n  \n  Soccer\n  136.0\n  90.0\n                      \n\n\n  2\n  Lionel Messi\n  \n  Soccer\n  130.0\n  65.0\n                      \n\n\n  3\n  Kylian Mbappé\n  \n  Soccer\n  120.0\n  20.0\n                      \n\n\n  4\n  LeBron James\n  \n  Basketball\n  119.5\n  75.0\n                      \n\n\n  5\n  Canelo Alvarez\n  \n  Boxing\n  110.0\n  10.0\n                      \n\n\n  6\n  Dustin Johnson\n  \n  Golf\n  107.0\n  5.0\n                      \n\n\n  7\n  Phil Mickelson\n  \n  Golf\n  106.0\n  2.0\n                      \n\n\n  8\n  Stephen Curry\n  \n  Basketball\n  100.4\n  52.0\n                      \n\n\n  9\n  Roger Federer\n  \n  Tennis\n  95.1\n  95.0\n                      \n\n\n  \n  \n  \n    Original table: @LisaHornung_ | Sports icons: Firza Alamsyah | Data: Forbes"
  },
  {
    "objectID": "get-started/basic-column-labels.html",
    "href": "get-started/basic-column-labels.html",
    "title": "Column Labels",
    "section": "",
    "text": "The table’s Column Labels part contains, at a minimum, columns and their column labels. The last example had a single column: size. Just as in the Stub, we can create groupings called spanner labels that encompass one or more columns.\nTo better demonstrate how Column Labels work and are displayed, let’s use an input data table with more columns. In this case, that input table will be airquality. It has the following columns:\nWe know that all measurements took place in 1973, so a year column will be added to the dataset before it is passed to the GT() class.\nfrom great_tables import GT, html\nfrom great_tables.data import airquality\n\nairquality_mini = airquality.head(10).assign(Year = 1973)\n\nairquality_mini\n\n\n\n\n  \n    \n      \n      Ozone\n      Solar_R\n      Wind\n      Temp\n      Month\n      Day\n      Year\n    \n  \n  \n    \n      0\n      41.0\n      190.0\n      7.4\n      67\n      5\n      1\n      1973\n    \n    \n      1\n      36.0\n      118.0\n      8.0\n      72\n      5\n      2\n      1973\n    \n    \n      2\n      12.0\n      149.0\n      12.6\n      74\n      5\n      3\n      1973\n    \n    \n      3\n      18.0\n      313.0\n      11.5\n      62\n      5\n      4\n      1973\n    \n    \n      4\n      NaN\n      NaN\n      14.3\n      56\n      5\n      5\n      1973\n    \n    \n      5\n      28.0\n      NaN\n      14.9\n      66\n      5\n      6\n      1973\n    \n    \n      6\n      23.0\n      299.0\n      8.6\n      65\n      5\n      7\n      1973\n    \n    \n      7\n      19.0\n      99.0\n      13.8\n      59\n      5\n      8\n      1973\n    \n    \n      8\n      8.0\n      19.0\n      20.1\n      61\n      5\n      9\n      1973\n    \n    \n      9\n      NaN\n      194.0\n      8.6\n      69\n      5\n      10\n      1973",
    "crumbs": [
      "Get Started",
      "Table Structure",
      "Column Labels"
    ]
  },
  {
    "objectID": "get-started/basic-column-labels.html#adding-column-spanners",
    "href": "get-started/basic-column-labels.html#adding-column-spanners",
    "title": "Column Labels",
    "section": "Adding Column Spanners",
    "text": "Adding Column Spanners\nLet’s organize the time information under a Time spanner label, and put the other columns under a Measurement spanner label. We can do this with the tab_spanner() method.\n\ngt_airquality = (\n    GT(airquality_mini)\n    .tab_header(\n        title=\"New York Air Quality Measurements\",\n        subtitle=\"Daily measurements in New York City (May 1-10, 1973)\"\n    )\n    .tab_spanner(\n        label=\"Time\",\n        columns=[\"Year\", \"Month\", \"Day\"]\n    )\n    .tab_spanner(\n        label=\"Measurement\",\n        columns=[\"Ozone\", \"Solar_R\", \"Wind\", \"Temp\"]\n    )\n)\n\ngt_airquality\n\n\n\n\n\n  \n    New York Air Quality Measurements\n  \n  \n    Daily measurements in New York City (May 1-10, 1973)\n  \n\n\n  \n    Measurement\n  \n  \n    Time\n  \n\n\n  Ozone\n  Solar_R\n  Wind\n  Temp\n  Year\n  Month\n  Day\n\n\n  \n    41.0\n    190.0\n    7.4\n    67\n    1973\n    5\n    1\n  \n  \n    36.0\n    118.0\n    8.0\n    72\n    1973\n    5\n    2\n  \n  \n    12.0\n    149.0\n    12.6\n    74\n    1973\n    5\n    3\n  \n  \n    18.0\n    313.0\n    11.5\n    62\n    1973\n    5\n    4\n  \n  \n    \n    \n    14.3\n    56\n    1973\n    5\n    5\n  \n  \n    28.0\n    \n    14.9\n    66\n    1973\n    5\n    6\n  \n  \n    23.0\n    299.0\n    8.6\n    65\n    1973\n    5\n    7\n  \n  \n    19.0\n    99.0\n    13.8\n    59\n    1973\n    5\n    8\n  \n  \n    8.0\n    19.0\n    20.1\n    61\n    1973\n    5\n    9\n  \n  \n    \n    194.0\n    8.6\n    69\n    1973\n    5\n    10",
    "crumbs": [
      "Get Started",
      "Table Structure",
      "Column Labels"
    ]
  },
  {
    "objectID": "get-started/basic-column-labels.html#moving-and-relabeling-columns",
    "href": "get-started/basic-column-labels.html#moving-and-relabeling-columns",
    "title": "Column Labels",
    "section": "Moving and Relabeling Columns",
    "text": "Moving and Relabeling Columns\nWe can do two more things to make this presentable:\n\nmove the Time columns to the beginning of the series (using cols_move_to_start())\ncustomize the column labels so that they are more descriptive (using cols_label())\n\nLet’s do both of these things in the next example:\n\n(\n    gt_airquality\n    .cols_move_to_start(columns=[\"Year\", \"Month\", \"Day\"])\n    .cols_label(\n        Ozone=html(\"Ozone,&lt;br&gt;ppbV\"),\n        Solar_R=html(\"Solar R.,&lt;br&gt;cal/m&lt;sup&gt;2&lt;/sup&gt;\"),\n        Wind=html(\"Wind,&lt;br&gt;mph\"),\n        Temp=html(\"Temp,&lt;br&gt;&deg;F\")\n    )\n)\n\n\n\n\n\n  \n    New York Air Quality Measurements\n  \n  \n    Daily measurements in New York City (May 1-10, 1973)\n  \n\n\n  \n    Time\n  \n  \n    Measurement\n  \n\n\n  Year\n  Month\n  Day\n  Ozone,ppbV\n  Solar R.,cal/m2\n  Wind,mph\n  Temp,°F\n\n\n  \n    1973\n    5\n    1\n    41.0\n    190.0\n    7.4\n    67\n  \n  \n    1973\n    5\n    2\n    36.0\n    118.0\n    8.0\n    72\n  \n  \n    1973\n    5\n    3\n    12.0\n    149.0\n    12.6\n    74\n  \n  \n    1973\n    5\n    4\n    18.0\n    313.0\n    11.5\n    62\n  \n  \n    1973\n    5\n    5\n    \n    \n    14.3\n    56\n  \n  \n    1973\n    5\n    6\n    28.0\n    \n    14.9\n    66\n  \n  \n    1973\n    5\n    7\n    23.0\n    299.0\n    8.6\n    65\n  \n  \n    1973\n    5\n    8\n    19.0\n    99.0\n    13.8\n    59\n  \n  \n    1973\n    5\n    9\n    8.0\n    19.0\n    20.1\n    61\n  \n  \n    1973\n    5\n    10\n    \n    194.0\n    8.6\n    69\n  \n\n\n\n\n\n\n        \n\n\nNote that even though columns were moved using cols_move_to_start(), the spanner column labels still spanned above the correct column labels. There are a number of methods on GT to move columns, including cols_move(), cols_move_to_end(); there’s even a method to hide columns: cols_hide().\nMultiple columns can be renamed in a single use of cols_label(). Further to this, the helper functions md() and html() can be used to create column labels with additional styling. In the above example, we provided column labels as HTML so that we can insert linebreaks with &lt;br&gt;, insert a superscripted 2 (with &lt;sup&gt;2&lt;/sup&gt;), and insert a degree symbol as an HTML entity (&deg;).",
    "crumbs": [
      "Get Started",
      "Table Structure",
      "Column Labels"
    ]
  },
  {
    "objectID": "get-started/basic-column-labels.html#targeting-columns-for-columns",
    "href": "get-started/basic-column-labels.html#targeting-columns-for-columns",
    "title": "Column Labels",
    "section": "Targeting Columns for columns=",
    "text": "Targeting Columns for columns=\nIn the above examples, we selected columns to span or move using a list of column names (as strings). However, Great Tables supports a wide range of ways to select columns.\nFor example, you can use a lambda function:\n\n(\n    GT(airquality_mini)\n    .cols_move_to_start(columns=lambda colname: colname.endswith(\"R\"))\n)\n\n\n\n\n\n\n  Solar_R\n  Ozone\n  Wind\n  Temp\n  Month\n  Day\n  Year\n\n\n  \n    190.0\n    41.0\n    7.4\n    67\n    5\n    1\n    1973\n  \n  \n    118.0\n    36.0\n    8.0\n    72\n    5\n    2\n    1973\n  \n  \n    149.0\n    12.0\n    12.6\n    74\n    5\n    3\n    1973\n  \n  \n    313.0\n    18.0\n    11.5\n    62\n    5\n    4\n    1973\n  \n  \n    \n    \n    14.3\n    56\n    5\n    5\n    1973\n  \n  \n    \n    28.0\n    14.9\n    66\n    5\n    6\n    1973\n  \n  \n    299.0\n    23.0\n    8.6\n    65\n    5\n    7\n    1973\n  \n  \n    99.0\n    19.0\n    13.8\n    59\n    5\n    8\n    1973\n  \n  \n    19.0\n    8.0\n    20.1\n    61\n    5\n    9\n    1973\n  \n  \n    194.0\n    \n    8.6\n    69\n    5\n    10\n    1973\n  \n\n\n\n\n\n\n        \n\n\nInputs like strings, integers, and polars selectors are also supported. For more information, see Column Selection.",
    "crumbs": [
      "Get Started",
      "Table Structure",
      "Column Labels"
    ]
  },
  {
    "objectID": "get-started/basic-formatting.html",
    "href": "get-started/basic-formatting.html",
    "title": "Formatting Values",
    "section": "",
    "text": "The values within the table body, specifically those within the body cells, can be formatted with a large selection of fmt_*() methods like fmt_number(), fmt_integer(), fmt_scientific(), and more. Let’s use a portion of the exibble dataset and introduce some formatting to the cell values. First, we’ll generate the basic GT object and take a look at the table without any cell formatting applied.\nfrom great_tables import GT\nfrom great_tables.data import exibble\nfrom great_tables import vals\n\ngt_ex = GT(exibble[[\"num\", \"date\", \"time\", \"currency\"]].head(5))\n\ngt_ex\n\n\n\n\n\n\n  num\n  date\n  time\n  currency\n\n\n  \n    0.1111\n    2015-01-15\n    13:35\n    49.95\n  \n  \n    2.222\n    2015-02-15\n    14:40\n    17.95\n  \n  \n    33.33\n    2015-03-15\n    15:45\n    1.39\n  \n  \n    444.4\n    2015-04-15\n    16:50\n    65100.0\n  \n  \n    5550.0\n    2015-05-15\n    17:55\n    1325.81\nThe num column contains both small and much larger numbers. We can use the fmt_number() method to obtain formatted values have a fixed level of decimal precision and grouping separators. At the same time, we’ll format the numeric values in currency column to get monetary values.\ngt_ex = gt_ex.fmt_number(columns=\"num\", decimals=2).fmt_currency(columns=\"currency\")\n\ngt_ex\n\n\n\n\n\n\n  num\n  date\n  time\n  currency\n\n\n  \n    0.11\n    2015-01-15\n    13:35\n    $49.95\n  \n  \n    2.22\n    2015-02-15\n    14:40\n    $17.95\n  \n  \n    33.33\n    2015-03-15\n    15:45\n    $1.39\n  \n  \n    444.40\n    2015-04-15\n    16:50\n    $65,100.00\n  \n  \n    5,550.00\n    2015-05-15\n    17:55\n    $1,325.81\nDates and times can be formatted as well. As long as they are in ISO 8601 form, the fmt_date() and fmt_time() methods can be used to format such values. These methods have corresponding date_style= and time_style= arguments that accept a number of keywords that act as preset formatting styles.\ngt_ex = (\n    gt_ex.fmt_date(columns=\"date\", date_style=\"m_day_year\")\n    .fmt_time(columns=\"time\", time_style=\"h_m_p\")\n)\n\ngt_ex\n\n\n\n\n\n\n  num\n  date\n  time\n  currency\n\n\n  \n    0.11\n    Jan 15, 2015\n    1:35 PM\n    $49.95\n  \n  \n    2.22\n    Feb 15, 2015\n    2:40 PM\n    $17.95\n  \n  \n    33.33\n    Mar 15, 2015\n    3:45 PM\n    $1.39\n  \n  \n    444.40\n    Apr 15, 2015\n    4:50 PM\n    $65,100.00\n  \n  \n    5,550.00\n    May 15, 2015\n    5:55 PM\n    $1,325.81\nIt’s possible to format cells that have already been formatted. Using a formatting method again on previously formatted cells will always work within the ‘last-formatted-wins’ rule.\ngt_ex = gt_ex.fmt_date(columns=\"date\", date_style=\"wday_day_month_year\")\n\ngt_ex\n\n\n\n\n\n\n  num\n  date\n  time\n  currency\n\n\n  \n    0.11\n    Thursday 15 January 2015\n    1:35 PM\n    $49.95\n  \n  \n    2.22\n    Sunday 15 February 2015\n    2:40 PM\n    $17.95\n  \n  \n    33.33\n    Sunday 15 March 2015\n    3:45 PM\n    $1.39\n  \n  \n    444.40\n    Wednesday 15 April 2015\n    4:50 PM\n    $65,100.00\n  \n  \n    5,550.00\n    Friday 15 May 2015\n    5:55 PM\n    $1,325.81\nWithin the selected columns= we can choose to target specific cells with the rows= argument. The latter argument allows us to pass in a list of row indices.\ngt_ex = gt_ex.fmt_currency(columns=\"currency\", rows=[2, 3, 4], currency=\"GBP\")\n\ngt_ex\n\n\n\n\n\n\n  num\n  date\n  time\n  currency\n\n\n  \n    0.11\n    Thursday 15 January 2015\n    1:35 PM\n    $49.95\n  \n  \n    2.22\n    Sunday 15 February 2015\n    2:40 PM\n    $17.95\n  \n  \n    33.33\n    Sunday 15 March 2015\n    3:45 PM\n    £1.39\n  \n  \n    444.40\n    Wednesday 15 April 2015\n    4:50 PM\n    £65,100.00\n  \n  \n    5,550.00\n    Friday 15 May 2015\n    5:55 PM\n    £1,325.81",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Formatting Values"
    ]
  },
  {
    "objectID": "get-started/basic-formatting.html#arguments-common-to-several-formatting-methodsfunctions",
    "href": "get-started/basic-formatting.html#arguments-common-to-several-formatting-methodsfunctions",
    "title": "Formatting Values",
    "section": "Arguments Common to Several Formatting Methods/Functions",
    "text": "Arguments Common to Several Formatting Methods/Functions\nWhile we can use the fmt_*() methods on a table, we can also use the functional versions of these methods on scalar values or lists of values. These variants exist within the vals module. While arguments across these functions and their corresponding method aren’t exactly the same, there are nonetheless many arguments that are shared amongst them. Here are a few examples:\n\ndecimals=: set a fixed precision of decimal places\nsep_mark=, dec_mark=: set digit separators and the decimal symbol (defaults are \",\" and \".\")\nscale_by=: we can choose to scale targeted values by a multiplier value\ncompact=: larger figures (thousands, millions, etc.) can be autoscaled and decorated with the appropriate suffixes (e.g., \"10000\" becomes \"10K\")\npattern=: option to use a text pattern for decoration of the formatted values\nlocale=: providing a locale ID (e.g., \"en\", \"fr\", \"de-AT\", etc.) will result in numeric formatting specific to the chosen locale\n\nHere are a number of examples that use vals.fmt_number().\n\nfmt_number_1 = vals.fmt_number([1.64, 3.26, 3000.63, 236742.37])\nfmt_number_2 = vals.fmt_number([1.64, 3.26, 3000.63, 236742.37], compact=True)\nfmt_number_3 = vals.fmt_number([1.64, 3.26, 3000.63, 236742.37], decimals=3)\nfmt_number_4 = vals.fmt_number([1.64, 3.26, 3000.63, 236742.37], pattern=\"[{x}]\")\nfmt_number_5 = vals.fmt_number([1.64, 3.26, 3000.63, 236742.37], locale=\"es\")\n\nprint(fmt_number_1, fmt_number_2, fmt_number_3, fmt_number_4, fmt_number_5, sep=\"\\n\")\n\n['1.64', '3.26', '3,000.63', '236,742.37']\n['1.64', '3.26', '3.00K', '236.74K']\n['1.640', '3.260', '3,000.630', '236,742.370']\n['[1.64]', '[3.26]', '[3,000.63]', '[236,742.37]']\n['1,64', '3,26', '3.000,63', '236.742,37']\n\n\nScientific notation can be done with vals.fmt_scientific().\n\nfmt_sci_1 = vals.fmt_scientific([0.00064, 7.353, 863454.63])\nfmt_sci_2 = vals.fmt_scientific([1.64, 3.26, 3000.63], decimals=3)\nfmt_sci_3 = vals.fmt_scientific([1.64, 3.26, 3000.63], exp_style=\"E\")\nfmt_sci_4 = vals.fmt_scientific([1.64, 3.26, 3000.63], locale=\"de\")\n\nprint(fmt_sci_1, fmt_sci_2, fmt_sci_3, fmt_sci_4, sep=\"\\n\")\n\n[\"6.40 × 10&lt;sup style='font-size: 65%;'&gt;−4&lt;/sup&gt;\", '7.35', \"8.63 × 10&lt;sup style='font-size: 65%;'&gt;5&lt;/sup&gt;\"]\n['1.640', '3.260', \"3.001 × 10&lt;sup style='font-size: 65%;'&gt;3&lt;/sup&gt;\"]\n['1.64E00', '3.26E00', '3.00E30']\n['1,64', '3,26', \"3,00 × 10&lt;sup style='font-size: 65%;'&gt;3&lt;/sup&gt;\"]\n\n\nDates and times are handled with vals.fmt_date() and vals.fmt_time().\n\nfmt_date_1 = vals.fmt_date(\n    [\"2015-03-15\", \"2017-08-18\", \"2020-04-12\"], date_style=\"wday_month_day_year\"\n)\nfmt_date_2 = vals.fmt_date([\"2015-03-15\", \"2017-08-18\", \"2020-04-12\"], date_style=\"month_day_year\")\nfmt_time_1 = vals.fmt_time([\"23:03\", \"00:55\", \"08:23\"], time_style=\"h_m_p\")\nfmt_time_2 = vals.fmt_time([\"23:03\", \"00:55\", \"08:23\"], time_style=\"h_p\")\n\nprint(fmt_date_1, fmt_date_2, fmt_time_1, fmt_time_2, sep=\"\\n\")\n\n['Sunday, March 15, 2015', 'Friday, August 18, 2017', 'Sunday, April 12, 2020']\n['March 15, 2015', 'August 18, 2017', 'April 12, 2020']\n['11:03 PM', '12:55 AM', '8:23 AM']\n['11 PM', '12 AM', '8 AM']\n\n\nSometimes it’s easier and more convenient to experiment with formatting using the formatting functions in the vals module. There are many options to explore with each type of formatting and so visiting the API Reference is certainly worthwhile.",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Formatting Values"
    ]
  },
  {
    "objectID": "get-started/row-selection.html",
    "href": "get-started/row-selection.html",
    "title": "Row Selection",
    "section": "",
    "text": "Location and formatter functions (e.g. loc.body() and GT.fmt_number()) can be applied to specific rows, using the rows= argument.\nRows may be specified using any of the following:\nThe following sections will use a subset of the exibble data, to demonstrate these options.\nfrom great_tables import GT, exibble, loc, style\n\nlil_exibble = exibble[[\"num\", \"char\", \"currency\"]].head(3)\ngt_ex = GT(lil_exibble)",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Row Selection"
    ]
  },
  {
    "objectID": "get-started/row-selection.html#using-integers",
    "href": "get-started/row-selection.html#using-integers",
    "title": "Row Selection",
    "section": "Using integers",
    "text": "Using integers\nUse a single integer, or a list of integers, to select rows by position.\n\ngt_ex.fmt_currency(\"currency\", rows=0, decimals=1)\n\n\n\n\n\n\n  num\n  char\n  currency\n\n\n  \n    0.1111\n    apricot\n    $50.0\n  \n  \n    2.222\n    banana\n    17.95\n  \n  \n    33.33\n    coconut\n    1.39\n  \n\n\n\n\n\n\n        \n\n\nNotice that a dollar sign ($) was only added to the first row (index 0 in python).\nIndexing works the same as selecting items from a python list. This negative integers select relative to the final row.\n\ngt_ex.fmt_currency(\"currency\", rows=[0, -1], decimals=1)\n\n\n\n\n\n\n  num\n  char\n  currency\n\n\n  \n    0.1111\n    apricot\n    $50.0\n  \n  \n    2.222\n    banana\n    17.95\n  \n  \n    33.33\n    coconut\n    $1.4",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Row Selection"
    ]
  },
  {
    "objectID": "get-started/row-selection.html#using-polars-expressions",
    "href": "get-started/row-selection.html#using-polars-expressions",
    "title": "Row Selection",
    "section": "Using polars expressions",
    "text": "Using polars expressions\nThe rows= argument accepts polars expressions, which return a boolean Series, indicating which rows to operate on.\nFor example, the code below only formats the num column, but only when currency is less than 40.\n\nimport polars as pl\n\ngt_polars = GT(pl.from_pandas(lil_exibble))\n\ngt_polars.fmt_integer(\"num\", rows=pl.col(\"currency\") &lt; 40)\n\n\n\n\n\n\n  num\n  char\n  currency\n\n\n  \n    0.1111\n    apricot\n    49.95\n  \n  \n    2\n    banana\n    17.95\n  \n  \n    33\n    coconut\n    1.39\n  \n\n\n\n\n\n\n        \n\n\nHere’s a more realistic example, which highlights the row with the highest value for currency.\n\nimport polars.selectors as cs\n\ngt_polars.tab_style(\n    style.fill(\"yellow\"),\n    loc.body(\n        columns=cs.all(),\n        rows=pl.col(\"currency\") == pl.col(\"currency\").max()\n    )\n)\n\n\n\n\n\n\n  num\n  char\n  currency\n\n\n  \n    0.1111\n    apricot\n    49.95\n  \n  \n    2.222\n    banana\n    17.95\n  \n  \n    33.33\n    coconut\n    1.39",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Row Selection"
    ]
  },
  {
    "objectID": "get-started/row-selection.html#using-a-function",
    "href": "get-started/row-selection.html#using-a-function",
    "title": "Row Selection",
    "section": "Using a function",
    "text": "Using a function\nSince libraries like pandas don’t have lazy expressions, the rows= argument also accepts a function for selecting rows. The function should take a DataFrame and return a boolean series.\nHere’s the same example as the previous polars section, but with pandas data, and a lamba for selecting rows.\n\ngt_ex.fmt_integer(\"num\", rows=lambda D: D[\"currency\"] &lt; 40)\n\n\n\n\n\n\n  num\n  char\n  currency\n\n\n  \n    0.1111\n    apricot\n    49.95\n  \n  \n    2\n    banana\n    17.95\n  \n  \n    33\n    coconut\n    1.39\n  \n\n\n\n\n\n\n        \n\n\nHere’s the styling example from the previous polars section.\n\nimport polars.selectors as cs\n\ngt_ex.tab_style(\n    style.fill(\"yellow\"),\n    loc.body(\n        columns=lambda colname: True,\n        rows=lambda D: D[\"currency\"] == D[\"currency\"].max()\n    )\n)\n\n\n\n\n\n\n  num\n  char\n  currency\n\n\n  \n    0.1111\n    apricot\n    49.95\n  \n  \n    2.222\n    banana\n    17.95\n  \n  \n    33.33\n    coconut\n    1.39",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Row Selection"
    ]
  },
  {
    "objectID": "get-started/nanoplots.html",
    "href": "get-started/nanoplots.html",
    "title": "Nanoplots",
    "section": "",
    "text": "Warning\n\n\n\nfmt_nanoplot() is still experimental.\nNanoplots are tiny plots you can use in your table. They are simple by design, mainly because there isn’t a lot of space to work with. With that simplicity, however, you do get a set of very succinct data visualizations that adapt nicely to the amount of data you feed into them. Here’s some of the main features:",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Nanoplots"
    ]
  },
  {
    "objectID": "get-started/nanoplots.html#a-simple-line-based-nanoplot",
    "href": "get-started/nanoplots.html#a-simple-line-based-nanoplot",
    "title": "Nanoplots",
    "section": "A simple line-based nanoplot",
    "text": "A simple line-based nanoplot\nLet’s make some simple plots with a Polars DataFrame. Here we are using lists to define data values for each cell in the numbers column. The fmt_nanoplot() method understands that these are input values for a line plot (the default type of nanoplot).\n\nfrom great_tables import GT\nimport polars as pl\n\nrandom_numbers_df = pl.DataFrame(\n    {\n        \"example\": [\"Row \" + str(x) for x in range(1, 5)],\n        \"numbers\": [\n            \"20 23 6 7 37 23 21 4 7 16\",\n            \"2.3 6.8 9.2 2.42 3.5 12.1 5.3 3.6 7.2 3.74\",\n            \"-12 -5 6 3.7 0 8 -7.4\",\n            \"2 0 15 7 8 10 1 24 17 13 6\",\n        ],\n    }\n)\n\nGT(random_numbers_df).fmt_nanoplot(columns=\"numbers\")\n\n\n\n\n\n\n  example\n  numbers\n\n\n  \n    Row 1\n    37.04.0020.023.06.007.0037.023.021.04.007.0016.0\n  \n  \n    Row 2\n    12.12.302.306.809.202.423.5012.15.303.607.203.74\n  \n  \n    Row 3\n    8.00−12.0−12.0−5.006.003.7008.00−7.40\n  \n  \n    Row 4\n    24.002.00015.07.008.0010.01.0024.017.013.06.00\n  \n\n\n\n\n\n\n        \n\n\nThis looks a lot like the familiar sparklines you might see in tables where space for plots is limited. The input values, strings of space-separated values, can be considered here as y values and they are evenly spaced along the imaginary x axis.\nHovering over (or touching) the values is something of a treat! You might notice that:\n\ndata values are automatically formatted for you in a compact fashion\nthe plot elements also display pertinent values\n\nThis sort of interactively is baked into the rendered SVG graphics that fmt_nanoplot() generates from your data and selection of options.\nPolars lets us express ‘lists-of-values-per-cell’ in different ways and Great Tables is pretty good at understanding different column dtypes. So, you can alternatively create the same table as above with the following code.\nrandom_numbers_df = pl.DataFrame(\n    {\n        \"example\": [\"Row \" + str(x) for x in range(1, 5)],\n        \"numbers\": [\n            { \"val\": [20, 23, 6, 7, 37, 23, 21, 4, 7, 16] },\n            { \"val\": [2.3, 6.8, 9.2, 2.42, 3.5, 12.1, 5.3, 3.6, 7.2, 3.74] },\n            { \"val\": [-12, -5, 6, 3.7, 0, 8, -7.4] },\n            { \"val\": [2, 0, 15, 7, 8, 10, 1, 24, 17, 13, 6] },\n        ],\n    }\n)\n\nGT(random_numbers_df).fmt_nanoplot(columns=\"numbers\")\nBoth forms of the numbers column in the two DataFrames look the same to fmt_nanoplot(). The key for the list of values (here, \"val\") can be anything as long as it’s repeated down the column. So the choice is yours on how you want to prepare those column values.",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Nanoplots"
    ]
  },
  {
    "objectID": "get-started/nanoplots.html#the-reference-line-and-the-reference-area",
    "href": "get-started/nanoplots.html#the-reference-line-and-the-reference-area",
    "title": "Nanoplots",
    "section": "The reference line and the reference area",
    "text": "The reference line and the reference area\nYou can insert two additional things which may be useful: a reference line and a reference area. You can define them either through literal values or via keywords (these are: \"mean\", \"median\", \"min\", \"max\", \"q1\", \"q3\", \"first\", or \"last\"). Here’s a reference line that corresponds to the mean data value of each nanoplot:\n\nGT(random_numbers_df).fmt_nanoplot(columns=\"numbers\", reference_line=\"mean\")\n\n\n\n\n\n\n  example\n  numbers\n\n\n  \n    Row 1\n    16.437.04.0020.023.06.007.0037.023.021.04.007.0016.0\n  \n  \n    Row 2\n    5.6212.12.302.306.809.202.423.5012.15.303.607.203.74\n  \n  \n    Row 3\n    −0.968.00−12.0−12.0−5.006.003.7008.00−7.40\n  \n  \n    Row 4\n    9.3624.002.00015.07.008.0010.01.0024.017.013.06.00\n  \n\n\n\n\n\n\n        \n\n\nThis example uses a reference area that bounds the minimum value to the median value:\n\nGT(random_numbers_df).fmt_nanoplot(columns=\"numbers\", reference_area=[\"min\", \"median\"])\n\n\n\n\n\n\n  example\n  numbers\n\n\n  \n    Row 1\n    37.04.0020.023.06.007.0037.023.021.04.007.0016.0\n  \n  \n    Row 2\n    12.12.302.306.809.202.423.5012.15.303.607.203.74\n  \n  \n    Row 3\n    8.00−12.0−12.0−5.006.003.7008.00−7.40\n  \n  \n    Row 4\n    24.002.00015.07.008.0010.01.0024.017.013.06.00\n  \n\n\n\n\n\n\n        \n\n\nAs an added touch, you don’t need to worry about the order of the keywords provided to reference_area= (which could be potentially problematic if providing a literal value and a keyword).",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Nanoplots"
    ]
  },
  {
    "objectID": "get-started/nanoplots.html#using-autoscale-to-have-a-common-y-axis-scale-across-plots",
    "href": "get-started/nanoplots.html#using-autoscale-to-have-a-common-y-axis-scale-across-plots",
    "title": "Nanoplots",
    "section": "Using autoscale= to have a common y-axis scale across plots",
    "text": "Using autoscale= to have a common y-axis scale across plots\nThere are lots of options. Like, if you want to ensure that the scale is shared across all of the nanoplots (so you can better get a sense of overall magnitude), you can set autoscale= to True:\n\nGT(random_numbers_df).fmt_nanoplot(columns=\"numbers\", autoscale=True)\n\n\n\n\n\n\n  example\n  numbers\n\n\n  \n    Row 1\n    37.0−12.020.023.06.007.0037.023.021.04.007.0016.0\n  \n  \n    Row 2\n    37.0−12.02.306.809.202.423.5012.15.303.607.203.74\n  \n  \n    Row 3\n    37.0−12.0−12.0−5.006.003.7008.00−7.40\n  \n  \n    Row 4\n    37.0−12.02.00015.07.008.0010.01.0024.017.013.06.00\n  \n\n\n\n\n\n\n        \n\n\nIf you hover along or touch the left side of any of the plots above, you’ll see that each y scale runs from -12.0 to 37.0. Using autoscale=True is very useful if you want to compare the magnitudes of values across rows in addition to their trends. It won’t, however, make much sense if the overall magnitudes of values vary wildly across rows (e.g., comparing changing currency values or stock prices over time).",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Nanoplots"
    ]
  },
  {
    "objectID": "get-started/nanoplots.html#using-the-nanoplot_options-helper-function",
    "href": "get-started/nanoplots.html#using-the-nanoplot_options-helper-function",
    "title": "Nanoplots",
    "section": "Using the nanoplot_options() helper function",
    "text": "Using the nanoplot_options() helper function\nThere are many options for customization. You can radically change the look of a collection of nanoplots with the nanoplot_options() helper function. With that function, you invoke it in the options= argument of fmt_nanoplot(). You can modify the sizes and colors of different elements, decide which elements are even present, and much more! Here’s an example where a line-based nanoplot retains all of its elements, but the overall appearance is greatly altered.\n\nfrom great_tables import nanoplot_options\n\n(\n    GT(random_numbers_df)\n    .fmt_nanoplot(\n        columns=\"numbers\",\n        options=nanoplot_options(\n            data_point_radius=8,\n            data_point_stroke_color=\"black\",\n            data_point_stroke_width=2,\n            data_point_fill_color=\"white\",\n            data_line_type=\"straight\",\n            data_line_stroke_color=\"brown\",\n            data_line_stroke_width=2,\n            data_area_fill_color=\"orange\",\n            vertical_guide_stroke_color=\"green\",\n        ),\n    )\n)\n\n\n\n\n\n\n  example\n  numbers\n\n\n  \n    Row 1\n    37.04.0020.023.06.007.0037.023.021.04.007.0016.0\n  \n  \n    Row 2\n    12.12.302.306.809.202.423.5012.15.303.607.203.74\n  \n  \n    Row 3\n    8.00−12.0−12.0−5.006.003.7008.00−7.40\n  \n  \n    Row 4\n    24.002.00015.07.008.0010.01.0024.017.013.06.00\n  \n\n\n\n\n\n\n        \n\n\nAs can be seen, you have a lot of fine-grained control over the look of a nanoplot.",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Nanoplots"
    ]
  },
  {
    "objectID": "get-started/nanoplots.html#making-nanoplots-with-bars-using-plot_typebar",
    "href": "get-started/nanoplots.html#making-nanoplots-with-bars-using-plot_typebar",
    "title": "Nanoplots",
    "section": "Making nanoplots with bars using plot_type=\"bar\"",
    "text": "Making nanoplots with bars using plot_type=\"bar\"\nWe don’t just support line plots in fmt_nanoplot(), we also have the option to show bar plots. The only thing you need to change is the value of plot_type= argument to \"bar\":\n\nGT(random_numbers_df).fmt_nanoplot(columns=\"numbers\", plot_type=\"bar\")\n\n\n\n\n\n\n  example\n  numbers\n\n\n  \n    Row 1\n    37.0020.023.06.007.0037.023.021.04.007.0016.0\n  \n  \n    Row 2\n    12.102.306.809.202.423.5012.15.303.607.203.74\n  \n  \n    Row 3\n    8.00−12.0−12.0−5.006.003.7008.00−7.40\n  \n  \n    Row 4\n    24.002.00015.07.008.0010.01.0024.017.013.06.00\n  \n\n\n\n\n\n\n        \n\n\nAn important difference between line plots and bar plots is that the bars project from a zero line. Notice that some negative values in the bar-based nanoplot appear red and radiate downward from the gray zero line.\nUsing plot_type=\"bar\" still allows us to supply a reference line and a reference area with reference_line= and reference_area=. The autoscale= option works here as well. We also have a set of options just for bar plots available inside nanoplot_options(). Here’s an example where we use all of the aforementioned customization possibilities:\n\n(\n    GT(random_numbers_df)\n    .fmt_nanoplot(\n        columns=\"numbers\",\n        plot_type=\"bar\",\n        autoscale=True,\n        reference_line=\"min\",\n        reference_area=[0, \"max\"],\n        options=nanoplot_options(\n            data_bar_stroke_color=\"gray\",\n            data_bar_stroke_width=2,\n            data_bar_fill_color=\"orange\",\n            data_bar_negative_stroke_color=\"blue\",\n            data_bar_negative_stroke_width=1,\n            data_bar_negative_fill_color=\"lightblue\",\n            reference_line_color=\"pink\",\n            reference_area_fill_color=\"bisque\",\n            vertical_guide_stroke_color=\"blue\",\n        ),\n    )\n)\n\n\n\n\n\n\n  example\n  numbers\n\n\n  \n    Row 1\n    4.0037.0−12.020.023.06.007.0037.023.021.04.007.0016.0\n  \n  \n    Row 2\n    2.3037.0−12.02.306.809.202.423.5012.15.303.607.203.74\n  \n  \n    Row 3\n    −12.037.0−12.0−12.0−5.006.003.7008.00−7.40\n  \n  \n    Row 4\n    037.0−12.02.00015.07.008.0010.01.0024.017.013.06.00",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Nanoplots"
    ]
  },
  {
    "objectID": "get-started/nanoplots.html#horizontal-bar-and-line-plots",
    "href": "get-started/nanoplots.html#horizontal-bar-and-line-plots",
    "title": "Nanoplots",
    "section": "Horizontal bar and line plots",
    "text": "Horizontal bar and line plots\nSingle-value bar plots, running in the horizontal direction, can be made by simply invoking fmt_nanoplot() on a column of numeric values. These plots are meant for comparison across rows so the method automatically scales the horizontal bars to facilitate this type of display. Here’s a simple example that uses plot_type=\"bar\" on the numbers column that contains a single numeric value in every cell.\n\nsingle_vals_df = pl.DataFrame(\n    {\n        \"example\": [\"Row \" + str(x) for x in range(1, 5)],\n        \"numbers\": [2.75, 0, -3.2, 8]\n    }\n)\n\nGT(single_vals_df).fmt_nanoplot(columns=\"numbers\", plot_type=\"bar\")\n\n\n\n\n\n\n  example\n  numbers\n\n\n  \n    Row 1\n    2.75\n  \n  \n    Row 2\n    0\n  \n  \n    Row 3\n    −3.20\n  \n  \n    Row 4\n    8.00\n  \n\n\n\n\n\n\n        \n\n\nThis, interestingly enough, works with the \"line\" type of nanoplot. The result is akin to a lollipop plot:\n\nGT(single_vals_df).fmt_nanoplot(columns=\"numbers\")\n\n\n\n\n\n\n  example\n  numbers\n\n\n  \n    Row 1\n    2.75\n  \n  \n    Row 2\n    0\n  \n  \n    Row 3\n    −3.20\n  \n  \n    Row 4\n    8.00\n  \n\n\n\n\n\n\n        \n\n\nYou get to customize the line and the data point marker with the latter display of single values, and that’s a plus. Nonetheless, it is more common to see horizontal bar plots in tables and the extra customization of negative values makes that form of presentation more advantageous.",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Nanoplots"
    ]
  },
  {
    "objectID": "get-started/nanoplots.html#line-plots-with-paired-x-and-y-values",
    "href": "get-started/nanoplots.html#line-plots-with-paired-x-and-y-values",
    "title": "Nanoplots",
    "section": "Line plots with paired x and y values",
    "text": "Line plots with paired x and y values\nAside from a single stream of y values, we can plot pairs of x and y values. This works only for the \"line\" type of plot. We can set up a column of Polars struct values in a DataFrame to have this input data prepared for fmt_nanoplot(). Notice that the dictionary values in the enclosed list must have the \"x\" and \"y\" keys. Further to this, the list lengths for each of \"x\" and \"y\" must match (i.e., to make valid pairs of x and y).\n\nweather_2 = pl.DataFrame(\n    {\n        \"station\": [\"Station \" + str(x) for x in range(1, 4)],\n        \"temperatures\": [\n            {\n                \"x\": [6.1, 8.0, 10.1, 10.5, 11.2, 12.4, 13.1, 15.3],\n                \"y\": [24.2, 28.2, 30.2, 30.5, 30.5, 33.1, 33.5, 32.7],\n            },\n            {\n                \"x\": [7.1, 8.2, 10.3, 10.75, 11.25, 12.5, 13.5, 14.2],\n                \"y\": [18.2, 18.1, 20.3, 20.5, 21.4, 21.9, 23.1, 23.3],\n            },\n            {\n                \"x\": [6.3, 7.1, 10.3, 11.0, 12.07, 13.1, 15.12, 16.42],\n                \"y\": [15.2, 17.77, 21.42, 21.63, 25.23, 26.84, 27.2, 27.44],\n            },\n        ]\n    }\n)\n\n(\n    GT(weather_2)\n    .fmt_nanoplot(\n        columns=\"temperatures\",\n        plot_type=\"line\",\n        expand_x=[5, 16],\n        expand_y=[10, 40],\n        options=nanoplot_options(\n            show_data_area=False,\n            show_data_line=False\n        )\n    )\n)\n\n\n\n\n\n\n  station\n  temperatures\n\n\n  \n    Station 1\n    401024.228.230.230.530.533.133.532.7\n  \n  \n    Station 2\n    401018.218.120.320.521.421.923.123.3\n  \n  \n    Station 3\n    401015.217.821.421.625.226.827.227.4\n  \n\n\n\n\n\n\n        \n\n\nThe options for removing the data area and the data line (though the corresponding show_* arguments of nanoplot_options()) make the finalized nanoplots look somewhat like scatter plots.",
    "crumbs": [
      "Get Started",
      "Extra Topics",
      "Nanoplots"
    ]
  },
  {
    "objectID": "get-started/colorizing-with-data.html",
    "href": "get-started/colorizing-with-data.html",
    "title": "Colorizing with Data",
    "section": "",
    "text": "You sometimes come across heat maps in data visualization, and they’re used to represent data values with color gradients. This technique is great for identifying patterns, trends, outliers, and missing data when there’s lots of data. Tables can have this sort of treatment as well! Typically, formatted numeric values are shown along with some color treatment coinciding with the underlying data values.\nWe can make this possible in Great Tables by using the data_color() method. Let’s start with a simple example, using a Polars DataFrame with three columns of values. We can introduce that data to GT() and use data_color() without any arguments.\nfrom great_tables import GT\nimport polars as pl\n\nsimple_df = pl.DataFrame(\n    {\n        \"integer\": [1, 2, 3, 4, 5],\n        \"float\": [2.3, 1.3, 5.1, None, 4.4],\n        \"category\": [\"one\", \"two\", \"three\", \"one\", \"three\"],\n    }\n)\n\nGT(simple_df).data_color()\n\n\n\n\n\n\n  integer\n  float\n  category\n\n\n  \n    1\n    2.3\n    one\n  \n  \n    2\n    1.3\n    two\n  \n  \n    3\n    5.1\n    three\n  \n  \n    4\n    None\n    one\n  \n  \n    5\n    4.4\n    three\nThis works but doesn’t look all too appealing. However, we can take note of a few things straight away. The first thing is that data_color() doesn’t format the values but rather it applies color fill values to the cells. The second thing is that you don’t have to intervene and modify the text color so that there’s enough contrast, Great Tables will do that for you (this behavior can be deactivated with the autocolor_text= argument though).",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Colorizing with Data"
    ]
  },
  {
    "objectID": "get-started/colorizing-with-data.html#setting-palette-colors",
    "href": "get-started/colorizing-with-data.html#setting-palette-colors",
    "title": "Colorizing with Data",
    "section": "Setting palette colors",
    "text": "Setting palette colors\nWhile this first example illustrated some basic things, the common thing to do in practices to provide a list of colors to the palette= argument. Let’s choose two colors \"green\" and \"red\" and place them in that order.\n\nGT(simple_df).data_color(palette=[\"blue\", \"red\"])\n\n\n\n\n\n\n  integer\n  float\n  category\n\n\n  \n    1\n    2.3\n    one\n  \n  \n    2\n    1.3\n    two\n  \n  \n    3\n    5.1\n    three\n  \n  \n    4\n    None\n    one\n  \n  \n    5\n    4.4\n    three\n  \n\n\n\n\n\n\n        \n\n\nNow that we’ve moved away from the default palette and specified colors, we can see that lower numerical values are closer to blue and higher values are closer to red (those in the middle have colors that are a blend of the two; in this case, more in the purple range). Categorical values behave similarly, they take on ordinal values based on their first appearance (from top to bottom) and those values are used to generate the background colors.",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Colorizing with Data"
    ]
  },
  {
    "objectID": "get-started/colorizing-with-data.html#coloring-missing-values-with-na_color",
    "href": "get-started/colorizing-with-data.html#coloring-missing-values-with-na_color",
    "title": "Colorizing with Data",
    "section": "Coloring missing values with na_color",
    "text": "Coloring missing values with na_color\nThere is a lone \"None\" value in the float column, and it has a gray background. Thoughout the Great Tables package, missing values are treated in different ways and, in this case, it’s given a default color value. We can change that with the na_color= argument. Let’s try it now:\n\nGT(simple_df).data_color(palette=[\"blue\", \"red\"], na_color=\"#FFE4C4\")\n\n\n\n\n\n\n  integer\n  float\n  category\n\n\n  \n    1\n    2.3\n    one\n  \n  \n    2\n    1.3\n    two\n  \n  \n    3\n    5.1\n    three\n  \n  \n    4\n    None\n    one\n  \n  \n    5\n    4.4\n    three\n  \n\n\n\n\n\n\n        \n\n\nNow, the gray color has been changed to Bisque. Note that when it comes to colors, you can use any combination of CSS/X11 color names and hexadecimal color codes.",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Colorizing with Data"
    ]
  },
  {
    "objectID": "get-started/colorizing-with-data.html#using-domain-to-color-values-across-columns",
    "href": "get-started/colorizing-with-data.html#using-domain-to-color-values-across-columns",
    "title": "Colorizing with Data",
    "section": "Using domain= to color values across columns",
    "text": "Using domain= to color values across columns\nThe previous usages of the data_color() method were such that the color ranges encompassed the boundaries of the data values. That can be changed with the domain= argument, which expects a list of two values (a lower and an upper value). Let’s use the range [0, 10] on the first two columns, integer and float, and not the third (since a numerical domain is incompatible with string-based values). Here’s the table code for that:\n\n(\n    GT(simple_df)\n    .data_color(\n        columns=[\"integer\", \"float\"],\n        palette=[\"blue\", \"red\"],\n        domain=[0, 10],\n        na_color=\"white\"\n    )\n)\n\n\n\n\n\n\n  integer\n  float\n  category\n\n\n  \n    1\n    2.3\n    one\n  \n  \n    2\n    1.3\n    two\n  \n  \n    3\n    5.1\n    three\n  \n  \n    4\n    None\n    one\n  \n  \n    5\n    4.4\n    three\n  \n\n\n\n\n\n\n        \n\n\nNice! We can clearly see that the color ramp in the first column (integer) only proceeds from blue (value: 1) to purple (value: 5) and there isn’t a reddish color in sight (would need a value close to 10).",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Colorizing with Data"
    ]
  },
  {
    "objectID": "get-started/colorizing-with-data.html#bringing-it-all-together",
    "href": "get-started/colorizing-with-data.html#bringing-it-all-together",
    "title": "Colorizing with Data",
    "section": "Bringing it all together",
    "text": "Bringing it all together\nFor a more advanced treatment of data colorization in the table, let’s take the sza dataset (available in the great_tables.data submodule) and vigorously reshape it with Polars so that solar zenith angles are arranged as rows by month, and the half-hourly clock times are the columns (from early morning to solar noon).\nOnce the pivot()ing is done, we can introduce that that table to the GT() class, placing the names of the months in the table stub. We will use data_color() with a domain that runs from 90 to 0 (here, 90° is sunrise, and 0° is represents the sun angle that’s directly overhead). There are months where the sun rises later in the morning, before the sunrise times we’ll see missing values in the dataset, and na_color=\"white\" will handle those cases. Okay, that’s the plan, and now here’s the code:\n\nfrom great_tables import html\nfrom great_tables.data import sza\nimport polars.selectors as cs\n\nsza_pivot = (\n    pl.from_pandas(sza)\n    .filter((pl.col(\"latitude\") == \"20\") & (pl.col(\"tst\") &lt;= \"1200\"))\n    .select(pl.col(\"*\").exclude(\"latitude\"))\n    .drop_nulls()\n    .pivot(values=\"sza\", index=\"month\", columns=\"tst\", sort_columns=True)\n)\n\n(\n    GT(sza_pivot, rowname_col=\"month\")\n    .data_color(\n        domain=[90, 0],\n        palette=[\"rebeccapurple\", \"white\", \"orange\"],\n        na_color=\"white\",\n    )\n    .tab_header(\n        title=\"Solar Zenith Angles from 05:30 to 12:00\",\n        subtitle=html(\"Average monthly values at latitude of 20&deg;N.\"),\n    )\n)\n\n\n\n\n\n  \n    Solar Zenith Angles from 05:30 to 12:00\n  \n  \n    Average monthly values at latitude of 20°N.\n  \n\n\n  \n  0530\n  0600\n  0630\n  0700\n  0730\n  0800\n  0830\n  0900\n  0930\n  1000\n  1030\n  1100\n  1130\n  1200\n\n\n  \n    jan\n    None\n    None\n    None\n    84.9\n    78.7\n    72.7\n    66.1\n    61.5\n    56.5\n    52.1\n    48.3\n    45.5\n    43.6\n    43.0\n  \n  \n    feb\n    None\n    None\n    88.9\n    82.5\n    75.8\n    69.6\n    63.3\n    57.7\n    52.2\n    47.4\n    43.1\n    40.0\n    37.8\n    37.2\n  \n  \n    mar\n    None\n    None\n    85.7\n    78.8\n    72.0\n    65.2\n    58.6\n    52.3\n    46.2\n    40.5\n    35.5\n    31.4\n    28.6\n    27.7\n  \n  \n    apr\n    None\n    88.5\n    81.5\n    74.4\n    67.4\n    60.3\n    53.4\n    46.5\n    39.7\n    33.2\n    26.9\n    21.3\n    17.2\n    15.5\n  \n  \n    may\n    None\n    85.0\n    78.2\n    71.2\n    64.3\n    57.2\n    50.2\n    43.2\n    36.1\n    29.1\n    26.1\n    15.2\n    8.8\n    5.0\n  \n  \n    jun\n    89.2\n    82.7\n    76.0\n    69.3\n    62.5\n    55.7\n    48.8\n    41.9\n    35.0\n    28.1\n    21.1\n    14.2\n    7.3\n    2.0\n  \n  \n    jul\n    88.8\n    82.3\n    75.7\n    69.1\n    62.3\n    55.5\n    48.7\n    41.8\n    35.0\n    28.1\n    21.2\n    14.3\n    7.7\n    3.1\n  \n  \n    aug\n    None\n    83.8\n    77.1\n    70.2\n    63.3\n    56.4\n    49.4\n    42.4\n    35.4\n    28.3\n    21.3\n    14.3\n    7.3\n    1.9\n  \n  \n    sep\n    None\n    87.2\n    80.2\n    73.2\n    66.1\n    59.1\n    52.1\n    45.1\n    38.1\n    31.3\n    24.7\n    18.6\n    13.7\n    11.6\n  \n  \n    oct\n    None\n    None\n    84.1\n    77.1\n    70.2\n    63.3\n    56.5\n    49.9\n    43.5\n    37.5\n    32.0\n    27.4\n    24.3\n    23.1\n  \n  \n    nov\n    None\n    None\n    87.8\n    81.3\n    74.5\n    68.3\n    61.8\n    56.0\n    50.2\n    45.3\n    40.7\n    37.4\n    35.1\n    34.4\n  \n  \n    dec\n    None\n    None\n    None\n    84.3\n    78.0\n    71.8\n    66.1\n    60.5\n    55.6\n    50.9\n    47.2\n    44.2\n    42.4\n    41.8\n  \n\n\n\n\n\n\n        \n\n\nBecause this is a table for presentation, we can’t neglect using tab_header(). A title and subtitle can provide just enough information to guide the reader out through your table visualization.",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Colorizing with Data"
    ]
  },
  {
    "objectID": "get-started/basic-header.html",
    "href": "get-started/basic-header.html",
    "title": "Header and Footer",
    "section": "",
    "text": "The way that we add components like the Table Header and source notes in the Table Footer is to use the tab_*() family of methods. A Table Header is easy to add so let’s see how the previous table looks with a title and a subtitle. We can add this component using the tab_header() method:\n\nfrom great_tables import GT, md, html\nfrom great_tables.data import islands\n\nislands_mini = islands.head(10)\n\n# Make a display table with the `islands_tbl` table;\n# put a heading just above the column labels\n(\n    GT(islands_mini)\n    .tab_header(\n        title = \"Large Landmasses of the World\",\n        subtitle = \"The top ten largest are presented\"\n    )\n)\n\n\n\n\n\n  \n    Large Landmasses of the World\n  \n  \n    The top ten largest are presented\n  \n\n\n  name\n  size\n\n\n  \n    Africa\n    11506\n  \n  \n    Antarctica\n    5500\n  \n  \n    Asia\n    16988\n  \n  \n    Australia\n    2968\n  \n  \n    Axel Heiberg\n    16\n  \n  \n    Baffin\n    184\n  \n  \n    Banks\n    23\n  \n  \n    Borneo\n    280\n  \n  \n    Britain\n    84\n  \n  \n    Celebes\n    73\n  \n\n\n\n\n\n\n        \n\n\nThe Header table component provides an opportunity to describe the data that’s presented. Using subtitle= allows us to insert a subtitle, which is an optional part of the Header. We may also style the title= and subtitle= using Markdown! We do this by wrapping the values passed to title= or subtitle= with the md() helper function (we may also use html() in a similar fashion). Here is an example with the table data truncated for brevity:\n\n# Make a display table with the `islands_tbl` table;\n# put a heading just above the column labels\ngt_tbl = (\n    GT(islands.head(2))\n    .tab_header(\n        title = md(\"Large Landmasses of the *World* &#x1F310;\"),\n        subtitle = md(\"The top **ten** largest are presented\")\n    )\n)\n\ngt_tbl\n\n\n\n\n\n  \n    Large Landmasses of the World 🌐\n  \n  \n    The top ten largest are presented\n  \n\n\n  name\n  size\n\n\n  \n    Africa\n    11506\n  \n  \n    Antarctica\n    5500\n  \n\n\n\n\n\n\n        \n\n\nA source note can be added to the table’s Footer through use of the tab_source_note() method. It works in the same way as tab_header() (it also allows for Markdown inputs) except it can be called multiple times—each invocation results in the addition of a source note.\n\n# Display the `islands_tbl` data with a heading and two source notes\n(\n    gt_tbl\n    .tab_source_note(\n        source_note = \"Source: The World Almanac and Book of Facts, 1975, page 406.\"\n    )\n    .tab_source_note(\n        source_note = md(\"Reference: McNeil, D. R. (1977) *Interactive Data Analysis*. Wiley.\")\n    )\n)\n\n\n\n\n\n  \n    Large Landmasses of the World 🌐\n  \n  \n    The top ten largest are presented\n  \n\n\n  name\n  size\n\n\n  \n    Africa\n    11506\n  \n  \n    Antarctica\n    5500\n  \n\n  \n  \n  \n    Source: The World Almanac and Book of Facts, 1975, page 406.\n  \n\n\n  \n    Reference: McNeil, D. R. (1977) Interactive Data Analysis. Wiley.",
    "crumbs": [
      "Get Started",
      "Table Structure",
      "Header and Footer"
    ]
  },
  {
    "objectID": "get-started/table-theme-options.html",
    "href": "get-started/table-theme-options.html",
    "title": "Table Theme Options",
    "section": "",
    "text": "Great Tables exposes options to customize the appearance of tables via two methods:\nBoth methods target parts of the table, as shown in the diagram below.\nThis page covers how to style and theme your table using GT.tab_options(), which is meant to quickly set a broad range of styles. In the future, even more granular options will become available via GT.tab_style().\nWe’ll use the basic GT object below for most examples, since it marks some of the table parts.\nfrom great_tables import GT, exibble\n\ngt_ex = (\n    GT(exibble.head(5), rowname_col=\"row\", groupname_col=\"group\")\n    .tab_header(\"THE HEADING\", \"(a subtitle)\")\n    .tab_stubhead(\"THE STUBHEAD\")\n    .tab_source_note(\"THE SOURCE NOTE\")\n)\n\ngt_ex\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n  \n  \n    row_2\n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n  \n  \n    row_4\n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n  \n\n  \n  \n  \n    THE SOURCE NOTE",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Table Theme Options"
    ]
  },
  {
    "objectID": "get-started/table-theme-options.html#table-option-parts",
    "href": "get-started/table-theme-options.html#table-option-parts",
    "title": "Table Theme Options",
    "section": "Table option parts",
    "text": "Table option parts\nAs the graph above showed, tables are made of many parts—such as the heading, column labels, and stub. .tab_options() organizes options based on table part.\nThe code below illustrates the table parts .tab_options() can target, by setting the background color for various parts.\n\n(\n    gt_ex\n    .tab_options(\n        container_width = \"100%\",\n        table_background_color=\"lightblue\",\n        heading_background_color = \"gold\",\n        column_labels_background_color=\"aquamarine\",\n        row_group_background_color=\"lightyellow\",\n        stub_background_color=\"lightgreen\",\n        source_notes_background_color=\"#f1e2af\",\n    )\n)\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n  \n  \n    row_2\n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n  \n  \n    row_4\n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n  \n\n  \n  \n  \n    THE SOURCE NOTE\n  \n\n\n\n\n\n\n        \n\n\nNotice two important pieces:\n\nThe argument heading_background_color=\"gold\" sets the heading part’s background to gold.\nParts like container and table are the broadest. They cover all the other parts of the table.",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Table Theme Options"
    ]
  },
  {
    "objectID": "get-started/table-theme-options.html#finding-options-part-type-attribute",
    "href": "get-started/table-theme-options.html#finding-options-part-type-attribute",
    "title": "Table Theme Options",
    "section": "Finding options: part, type, attribute",
    "text": "Finding options: part, type, attribute\nOption names follow this format:\n{part name}_{type}_{attribute}\nFor example, the option row_group_border_top_color has these pieces:\n\npart: row_group\ntype: border_top\nattribute: color\n\n\n\n\n\n\n\nNote\n\n\n\nHere are the parts supported in .tab_options():\n\ncontainer, table\nheading, source_note\ncolumn_labels, row_group, stub, stub_row\ntable_body",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Table Theme Options"
    ]
  },
  {
    "objectID": "get-started/table-theme-options.html#styling-borders",
    "href": "get-started/table-theme-options.html#styling-borders",
    "title": "Table Theme Options",
    "section": "Styling borders",
    "text": "Styling borders\nMany table parts support customizing border colors and style. This is shown below for column labels.\n\ngt_ex.tab_options(\n    column_labels_border_top_color=\"blue\",\n    column_labels_border_top_style=\"solid\",\n    column_labels_border_top_width=\"5px\"\n)\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n  \n  \n    row_2\n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n  \n  \n    row_4\n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n  \n\n  \n  \n  \n    THE SOURCE NOTE",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Table Theme Options"
    ]
  },
  {
    "objectID": "get-started/table-theme-options.html#styling-background-color",
    "href": "get-started/table-theme-options.html#styling-background-color",
    "title": "Table Theme Options",
    "section": "Styling background color",
    "text": "Styling background color\n\ngt_ex.tab_options(\n    heading_background_color=\"purple\"\n)\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n  \n  \n    row_2\n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n  \n  \n    row_4\n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n  \n\n  \n  \n  \n    THE SOURCE NOTE",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Table Theme Options"
    ]
  },
  {
    "objectID": "get-started/table-theme-options.html#styling-body-cells",
    "href": "get-started/table-theme-options.html#styling-body-cells",
    "title": "Table Theme Options",
    "section": "Styling body cells",
    "text": "Styling body cells\nThe table body can style the lines between individual cells. Use the hline and vline option types to specify cell line color, style, and width.\nFor example, the code below changes horizontal lines (hline) between cells to be red, dashed lines.\n\ngt_ex.tab_options(\n    table_body_hlines_color=\"red\",\n    table_body_hlines_style=\"dashed\",\n    table_body_hlines_width=\"4px\",\n)\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n  \n  \n    row_2\n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n  \n  \n    row_4\n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n  \n\n  \n  \n  \n    THE SOURCE NOTE\n  \n\n\n\n\n\n\n        \n\n\nIn order to define the vertical lines between cells, set vline styles. For example, the code below makes both horizontal and vertical lines between cells solid.\n\ngt_ex.tab_options(\n    table_body_hlines_style=\"solid\",\n    table_body_vlines_style=\"solid\",\n)\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n  \n  \n    row_2\n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n  \n  \n    row_4\n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n  \n\n  \n  \n  \n    THE SOURCE NOTE",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Table Theme Options"
    ]
  },
  {
    "objectID": "get-started/table-theme-options.html#set-options-across-table-parts",
    "href": "get-started/table-theme-options.html#set-options-across-table-parts",
    "title": "Table Theme Options",
    "section": "Set options across table parts",
    "text": "Set options across table parts\nSome options starting with table_ apply to all parts of the table. For example, fonts and background color apply everywhere.\n\ngt_ex.tab_options(\n    table_background_color=\"green\",\n    table_font_color=\"darkblue\",\n    table_font_style=\"italic\",\n    table_font_names=\"Times New Roman\"\n)\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n  \n  \n    row_2\n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n  \n  \n    row_4\n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n  \n\n  \n  \n  \n    THE SOURCE NOTE\n  \n\n\n\n\n\n\n        \n\n\nOptions set across the whole table, can be overriden by styling a specific part.\n\ngt_ex.tab_options(\n    table_background_color=\"orange\",\n    heading_background_color=\"pink\"\n)\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n  \n  \n    row_2\n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n  \n  \n    row_4\n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n  \n\n  \n  \n  \n    THE SOURCE NOTE",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Table Theme Options"
    ]
  },
  {
    "objectID": "get-started/table-theme-options.html#a-basic-theme",
    "href": "get-started/table-theme-options.html#a-basic-theme",
    "title": "Table Theme Options",
    "section": "A basic theme",
    "text": "A basic theme\nBased on the sections above, we can design an overall theme for a table.\nThis requires setting a decent number of options, but makes a big difference when presenting a table! Below is a table with a simple, blue theme. (The code is hidden by default, but can be expanded to see all the options set).\n\n\nCode\nfrom great_tables import GT, exibble\n\n# TODO: are there names we can give the three colors?\n# e.g. primary = \"#0076BA\", etc..\n\n(GT(exibble, rowname_col=\"row\", groupname_col=\"group\")\n    .tab_header(\"THE HEADING\", \"(a subtitle)\")\n    .tab_stubhead(\"THE STUBHEAD\")\n    .tab_source_note(\"THE SOURCE NOTE\")\n    .tab_options(\n        # table ----\n        table_border_top_color=\"#004D80\",\n        table_border_bottom_color=\"#004D80\",\n\n        # heading ----\n        heading_border_bottom_color=\"#0076BA\",\n\n        # column labels ----\n        column_labels_border_top_color=\"#0076BA\",\n        column_labels_border_bottom_color=\"#0076BA\",\n        column_labels_background_color=\"#FFFFFF\",\n\n        # row group ----\n        row_group_border_top_color=\"#0076BA\",\n        row_group_border_bottom_color=\"#0076BA\",\n\n        # stub ----\n        stub_background_color=\"#0076BA\",\n        stub_border_style=\"solid\",\n        stub_border_color=\"#0076BA\",\n\n        # table body ----\n        table_body_border_top_color=\"#0076BA\",\n        table_body_border_bottom_color=\"#0076BA\",\n        table_body_hlines_style=\"none\",\n        table_body_vlines_style=\"none\",\n\n        # misc ----\n        #row_striping_background_color=\"#F4F4F4\"\n    )\n\n)\n\n\n\n\n\n\n  \n    THE HEADING\n  \n  \n    (a subtitle)\n  \n\n\n  THE STUBHEAD\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n  \n  \n    row_2\n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n  \n  \n    row_4\n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n  \n  \n    row_6\n    \n    fig\n    six\n    2015-06-15\n    \n    2018-06-06 16:11\n    13.255\n  \n  \n    row_7\n    777000.0\n    grapefruit\n    seven\n    \n    19:10\n    2018-07-07 05:22\n    \n  \n  \n    row_8\n    8880000.0\n    honeydew\n    eight\n    2015-08-15\n    20:20\n    \n    0.44\n  \n\n  \n  \n  \n    THE SOURCE NOTE",
    "crumbs": [
      "Get Started",
      "Format and Style",
      "Table Theme Options"
    ]
  },
  {
    "objectID": "blog/superbowl-squares/index.html",
    "href": "blog/superbowl-squares/index.html",
    "title": "Using Polars to Win at Super Bowl Squares",
    "section": "",
    "text": "The Super Bowl is upon us, and with it the glittering squares of chance. Maybe you’ve seen Super Bowl Squares at your work. Maybe you’ve played it with your pals. Or maybe you have no idea what it is.\nWhether you’re a Squares-head or not, this post will help you win with data."
  },
  {
    "objectID": "blog/superbowl-squares/index.html#what-is-super-bowl-squares",
    "href": "blog/superbowl-squares/index.html#what-is-super-bowl-squares",
    "title": "Using Polars to Win at Super Bowl Squares",
    "section": "What is Super Bowl Squares?",
    "text": "What is Super Bowl Squares?\nSuper Bowl Squares is a betting game, where you bet on the final digits of each team in a game.\nFor example, here are some scores with the final digit bolded:\n\nHome team score: 14\nAway team score: 7\n\nSo the final digits would be:\n\nHome team digit: 4\nAway team digit: 7\n\nLet’s say you choose the digits above, and write this as 4/7—meaning a final digit of 4 for home and 7 for away. You would mark yourself on this square:\n\n\nCode\ndf = (\n    pl.DataFrame({\"x\": list(range(10))})\n    .join(pl.DataFrame({\"y\": list(range(10)), \"z\": \"_._\"}), how=\"cross\")\n    .with_columns(\n        z=pl.when((pl.col(\"x\") == 7) & (pl.col(\"y\") == 4)).then(pl.lit(\"4/7\")).otherwise(\"z\")\n    )\n    .pivot(index=\"x\", values=\"z\", columns=\"y\")\n    .with_row_index()\n)\n\n(\n    GT(df, rowname_col=\"x\")\n    .tab_header(\"Example Superbowl Square\")\n    .tab_spanner(\"Home\", cs.all())\n    .tab_style(style.fill(\"green\"), loc.body(columns=\"4\", rows=pl.col(\"index\") == 7))\n    .tab_style(style.text(color=\"#FFFFFF\", weight=\"bold\"), loc.body())\n    .cols_hide(\"index\")\n    .tab_stubhead(\"Away\")\n)\n\n\n\n\n\n\n  \n    Example Superbowl Square\n  \n\n\n  Away\n  \n    Home\n  \n\n\n  0\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n\n\n  \n    0\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n  \n  \n    1\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n  \n  \n    2\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n  \n  \n    3\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n  \n  \n    4\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n  \n  \n    5\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n  \n  \n    6\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n  \n  \n    7\n    _._\n    _._\n    _._\n    _._\n    4/7\n    _._\n    _._\n    _._\n    _._\n    _._\n  \n  \n    8\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n  \n  \n    9\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n    _._\n  \n\n\n\n\n\n\n        \n\n\nIf the final score ends up being Home 4, Away 7—ding ding ding, big winner—you win the pool, and hopefully take home some combination of money and glory. For more details on playing, see this WikiHow article."
  },
  {
    "objectID": "blog/superbowl-squares/index.html#why-analyze-squares",
    "href": "blog/superbowl-squares/index.html#why-analyze-squares",
    "title": "Using Polars to Win at Super Bowl Squares",
    "section": "Why analyze squares?",
    "text": "Why analyze squares?\nNot all options in a Super Bowl Squares are created equal. This is because there are specific point values you can add to your score. For example, touchdowns often to result in 7 points, and its common to score 3 points via a field goal. This means that ending up with a final digit of 5 is uncommon.\nAnalyzing the chance of each square winning let’s you pick the best ones. (In some versions of Super Bowl Squares, the squares get randomly assigned to people. In that case, knowing the chance of winning tells you whether you got a bum deal or not ;)."
  },
  {
    "objectID": "blog/superbowl-squares/index.html#what-squares-are-most-likely-to-win",
    "href": "blog/superbowl-squares/index.html#what-squares-are-most-likely-to-win",
    "title": "Using Polars to Win at Super Bowl Squares",
    "section": "What squares are most likely to win?",
    "text": "What squares are most likely to win?\nWe looked back at games for the KC Chiefs (away), and games for the San Francisco 49ers (home), and calculated the proportion of the time each team ended with a specific digit. Putting this together for the two teams, here is the chance of winning on a given square:\n\n\nCode\nimport polars as pl\nimport polars.selectors as cs\nfrom great_tables import GT, md\n\n\n# Utilities -----\n\n\ndef calc_n(df: pl.DataFrame, colname: str):\n    \"\"\"Count the number of final digits observed across games.\"\"\"\n\n    return df.select(final_digit=pl.col(colname).mod(10)).group_by(\"final_digit\").agg(n=pl.len())\n\n\ndef team_final_digits(game: pl.DataFrame, team_code: str) -&gt; pl.DataFrame:\n    \"\"\"Calculate a team's proportion of digits across games (both home and away).\"\"\"\n\n    home_n = calc_n(game.filter(pl.col(\"home_team\") == team_code), \"home_score\")\n    away_n = calc_n(game.filter(pl.col(\"away_team\") == team_code), \"away_score\")\n\n    joined = (\n        home_n.join(away_n, \"final_digit\")\n        .select(\"final_digit\", n=pl.col(\"n\") + pl.col(\"n_right\"))\n        .with_columns(prop=pl.col(\"n\") / pl.col(\"n\").sum())\n    )\n\n    return joined\n\n\n# Analysis -----\n\ngames = pl.read_csv(\"./games.csv\").filter(\n    pl.col(\"game_id\") != \"2023_22_SF_KC\",\n    pl.col(\"season\") &gt;= 2015,\n)\n\n# Individual probabilities of final digits per team\nhome = team_final_digits(games, \"KC\")\naway = team_final_digits(games, \"SF\")\n\n# Cross and multiply p(digit | team=KC)p(digit | team=SF) to get\n# the joint probability p(digit_KC, digit_SF | KC, SF)\njoint = (\n    home.join(away, on=\"final_digit\", how=\"cross\")\n    .with_columns(joint=pl.col(\"prop\") * pl.col(\"prop_right\"))\n    .sort(\"final_digit\", \"final_digit_right\")\n    .pivot(values=\"joint\", columns=\"final_digit_right\", index=\"final_digit\")\n    .with_columns((cs.all().exclude(\"final_digit\") * 100).round(1))\n)\n\n# Display -----\n\n(\n    GT(joint, rowname_col=\"final_digit\")\n    .data_color(domain=[0, 4], palette=[\"red\", \"grey\", \"blue\"])\n    .tab_header(\n        \"Super Bowl Squares | Final Score Probabilities\",\n        \"Based on all NFL regular season and playoff games (2015-2023)\",\n    )\n    .tab_stubhead(\"\")\n    .tab_spanner(\"San Francisco 49ers\", cs.all())\n    .tab_stubhead(\"KC Chiefs\")\n    .tab_source_note(\n        md(\n            '&lt;span style=\"float: right;\"&gt;Source data: [Lee Sharpe, nflverse](https://github.com/nflverse/nfldata)&lt;/span&gt;'\n        )\n    )\n)\n\n\n\n\n\n\n  \n    Super Bowl Squares | Final Score Probabilities\n  \n  \n    Based on all NFL regular season and playoff games (2015-2023)\n  \n\n\n  KC Chiefs\n  \n    San Francisco 49ers\n  \n\n\n  0\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n\n\n  \n    0\n    2.3\n    1.5\n    0.6\n    2.4\n    1.7\n    0.9\n    1.2\n    3.2\n    1.1\n    0.8\n  \n  \n    1\n    1.8\n    1.2\n    0.5\n    1.9\n    1.3\n    0.7\n    0.9\n    2.6\n    0.9\n    0.6\n  \n  \n    2\n    1.1\n    0.7\n    0.3\n    1.2\n    0.8\n    0.4\n    0.6\n    1.6\n    0.5\n    0.4\n  \n  \n    3\n    1.7\n    1.1\n    0.5\n    1.8\n    1.3\n    0.7\n    0.9\n    2.5\n    0.8\n    0.6\n  \n  \n    4\n    1.8\n    1.2\n    0.5\n    1.9\n    1.3\n    0.7\n    0.9\n    2.6\n    0.9\n    0.6\n  \n  \n    5\n    0.7\n    0.5\n    0.2\n    0.7\n    0.5\n    0.3\n    0.4\n    1.0\n    0.3\n    0.2\n  \n  \n    6\n    1.0\n    0.6\n    0.2\n    1.0\n    0.7\n    0.4\n    0.5\n    1.4\n    0.5\n    0.3\n  \n  \n    7\n    2.3\n    1.5\n    0.6\n    2.4\n    1.7\n    0.9\n    1.2\n    3.4\n    1.1\n    0.8\n  \n  \n    8\n    0.8\n    0.5\n    0.2\n    0.8\n    0.6\n    0.3\n    0.4\n    1.1\n    0.4\n    0.3\n  \n  \n    9\n    1.0\n    0.7\n    0.3\n    1.1\n    0.8\n    0.4\n    0.5\n    1.5\n    0.5\n    0.4\n  \n\n  \n  \n  \n    Source data: Lee Sharpe, nflverse\n  \n\n\n\n\n\n\n        \n\n\nNotice how much higher the chance of winning on any score involving 7 is. This shows up in two places on the table:\n\nAcross the 7 row (i.e. KC Chiefs end with a 7)\nDown the 7 column (i.e. S.F. 49ers ends with a 7)\n\nMoreover, the 7/7 square has the highest chance (3.4%). Some other good squares are 7/0 (or 0/7), and 0/0."
  },
  {
    "objectID": "blog/superbowl-squares/index.html#go-forth-and-win-the-respect-of-your-coworkers",
    "href": "blog/superbowl-squares/index.html#go-forth-and-win-the-respect-of-your-coworkers",
    "title": "Using Polars to Win at Super Bowl Squares",
    "section": "Go forth and win the respect of your coworkers",
    "text": "Go forth and win the respect of your coworkers\nWe hope this square will make you the envy of your coworkers. Here at Great Tables, we’re not just interested in the beautiful display of tables, but your success in defeating the person in the cubicle next to you.\nAs a final shout out, we used the python data analysis tool Polars for all the data analysis. Using Polars with Great Tables was a total delight. To learn more about how we analyzed the data, along with the code, see the appendix below!\n\n\n\n\n\n\nAppendix: analysis and code\n\n\n\n\n\nAppendix: analysis and code\n\nMethod\nIn order to calculate the probability of a given square winning, we focused on the joint probability of observing a final digit for the home team AND a final digit for the away team.\nThis can be expressed as p(home_digit, away_digit | home=\"SF\", away=\"KC\"). Note that the probability is conditioned on the teams playing in the Super Bowl. In order to estimate this, we p(digit | team=\"SF\")*p(digit | team=\"KC\").\nThis essentially makes two assumptions:\n\nThat the final digit does not depend on whether a team is home or away (though it may depend on the team playing).\nThat the final digit for a given team is independent of the team they are playing.\n\nAnother way to think about this is that digit is being modeled as if each team is drawing a ball numbered 0-9 from their own urn. We are modelling the chance of observing a pair of numbers, corresponding to a draw from each team’s urns.\nThe code for this analysis is in this python script on github, and is included below:\n\n\nCode\n\nimport polars as pl\nimport polars.selectors as cs\nfrom great_tables import GT, md\n\n\n# Utilities -----\n\n\ndef calc_n(df: pl.DataFrame, colname: str):\n    \"\"\"Count the number of final digits observed across games.\"\"\"\n\n    return df.select(final_digit=pl.col(colname).mod(10)).group_by(\"final_digit\").agg(n=pl.len())\n\n\ndef team_final_digits(game: pl.DataFrame, team_code: str) -&gt; pl.DataFrame:\n    \"\"\"Calculate a team's proportion of digits across games (both home and away).\"\"\"\n\n    home_n = calc_n(game.filter(pl.col(\"home_team\") == team_code), \"home_score\")\n    away_n = calc_n(game.filter(pl.col(\"away_team\") == team_code), \"away_score\")\n\n    joined = (\n        home_n.join(away_n, \"final_digit\")\n        .select(\"final_digit\", n=pl.col(\"n\") + pl.col(\"n_right\"))\n        .with_columns(prop=pl.col(\"n\") / pl.col(\"n\").sum())\n    )\n\n    return joined\n\n\n# Analysis -----\n\ngames = pl.read_csv(\"./games.csv\").filter(\n    pl.col(\"game_id\") != \"2023_22_SF_KC\",\n    pl.col(\"season\") &gt;= 2015,\n)\n\n# Individual probabilities of final digits per team\nhome = team_final_digits(games, \"KC\")\naway = team_final_digits(games, \"SF\")\n\n# Cross and multiply p(digit | team=KC)p(digit | team=SF) to get\n# the joint probability p(digit_KC, digit_SF | KC, SF)\njoint = (\n    home.join(away, on=\"final_digit\", how=\"cross\")\n    .with_columns(joint=pl.col(\"prop\") * pl.col(\"prop_right\"))\n    .sort(\"final_digit\", \"final_digit_right\")\n    .pivot(values=\"joint\", columns=\"final_digit_right\", index=\"final_digit\")\n    .with_columns((cs.all().exclude(\"final_digit\") * 100).round(1))\n)\n\n# Display -----\n\n(\n    GT(joint, rowname_col=\"final_digit\")\n    .data_color(domain=[0, 4], palette=[\"red\", \"grey\", \"blue\"])\n    .tab_header(\n        \"Super Bowl Squares | Final Score Probabilities\",\n        \"Based on all NFL regular season and playoff games (2015-2023)\",\n    )\n    .tab_stubhead(\"\")\n    .tab_spanner(\"San Francisco 49ers\", cs.all())\n    .tab_stubhead(\"KC Chiefs\")\n    .tab_source_note(\n        md(\n            '&lt;span style=\"float: right;\"&gt;Source data: [Lee Sharpe, nflverse](https://github.com/nflverse/nfldata)&lt;/span&gt;'\n        )\n    )\n)\n\n\n\n\n\n  \n    Super Bowl Squares | Final Score Probabilities\n  \n  \n    Based on all NFL regular season and playoff games (2015-2023)\n  \n\n\n  KC Chiefs\n  \n    San Francisco 49ers\n  \n\n\n  0\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n\n\n  \n    0\n    2.3\n    1.5\n    0.6\n    2.4\n    1.7\n    0.9\n    1.2\n    3.2\n    1.1\n    0.8\n  \n  \n    1\n    1.8\n    1.2\n    0.5\n    1.9\n    1.3\n    0.7\n    0.9\n    2.6\n    0.9\n    0.6\n  \n  \n    2\n    1.1\n    0.7\n    0.3\n    1.2\n    0.8\n    0.4\n    0.6\n    1.6\n    0.5\n    0.4\n  \n  \n    3\n    1.7\n    1.1\n    0.5\n    1.8\n    1.3\n    0.7\n    0.9\n    2.5\n    0.8\n    0.6\n  \n  \n    4\n    1.8\n    1.2\n    0.5\n    1.9\n    1.3\n    0.7\n    0.9\n    2.6\n    0.9\n    0.6\n  \n  \n    5\n    0.7\n    0.5\n    0.2\n    0.7\n    0.5\n    0.3\n    0.4\n    1.0\n    0.3\n    0.2\n  \n  \n    6\n    1.0\n    0.6\n    0.2\n    1.0\n    0.7\n    0.4\n    0.5\n    1.4\n    0.5\n    0.3\n  \n  \n    7\n    2.3\n    1.5\n    0.6\n    2.4\n    1.7\n    0.9\n    1.2\n    3.4\n    1.1\n    0.8\n  \n  \n    8\n    0.8\n    0.5\n    0.2\n    0.8\n    0.6\n    0.3\n    0.4\n    1.1\n    0.4\n    0.3\n  \n  \n    9\n    1.0\n    0.7\n    0.3\n    1.1\n    0.8\n    0.4\n    0.5\n    1.5\n    0.5\n    0.4\n  \n\n  \n  \n  \n    Source data: Lee Sharpe, nflverse"
  },
  {
    "objectID": "blog/superbowl-squares/index.html#appendix-analysis-and-code",
    "href": "blog/superbowl-squares/index.html#appendix-analysis-and-code",
    "title": "Using Polars to Win at Super Bowl Squares",
    "section": "Appendix: analysis and code",
    "text": "Appendix: analysis and code\n\nMethod\nIn order to calculate the probability of a given square winning, we focused on the joint probability of observing a final digit for the home team AND a final digit for the away team.\nThis can be expressed as p(home_digit, away_digit | home=\"SF\", away=\"KC\"). Note that the probability is conditioned on the teams playing in the Super Bowl. In order to estimate this, we p(digit | team=\"SF\")*p(digit | team=\"KC\").\nThis essentially makes two assumptions:\n\nThat the final digit does not depend on whether a team is home or away (though it may depend on the team playing).\nThat the final digit for a given team is independent of the team they are playing.\n\nAnother way to think about this is that digit is being modeled as if each team is drawing a ball numbered 0-9 from their own urn. We are modelling the chance of observing a pair of numbers, corresponding to a draw from each team’s urns.\nThe code for this analysis is in this python script on github, and is included below:\n\n\nCode\n\nimport polars as pl\nimport polars.selectors as cs\nfrom great_tables import GT, md\n\n\n# Utilities -----\n\n\ndef calc_n(df: pl.DataFrame, colname: str):\n    \"\"\"Count the number of final digits observed across games.\"\"\"\n\n    return df.select(final_digit=pl.col(colname).mod(10)).group_by(\"final_digit\").agg(n=pl.len())\n\n\ndef team_final_digits(game: pl.DataFrame, team_code: str) -&gt; pl.DataFrame:\n    \"\"\"Calculate a team's proportion of digits across games (both home and away).\"\"\"\n\n    home_n = calc_n(game.filter(pl.col(\"home_team\") == team_code), \"home_score\")\n    away_n = calc_n(game.filter(pl.col(\"away_team\") == team_code), \"away_score\")\n\n    joined = (\n        home_n.join(away_n, \"final_digit\")\n        .select(\"final_digit\", n=pl.col(\"n\") + pl.col(\"n_right\"))\n        .with_columns(prop=pl.col(\"n\") / pl.col(\"n\").sum())\n    )\n\n    return joined\n\n\n# Analysis -----\n\ngames = pl.read_csv(\"./games.csv\").filter(\n    pl.col(\"game_id\") != \"2023_22_SF_KC\",\n    pl.col(\"season\") &gt;= 2015,\n)\n\n# Individual probabilities of final digits per team\nhome = team_final_digits(games, \"KC\")\naway = team_final_digits(games, \"SF\")\n\n# Cross and multiply p(digit | team=KC)p(digit | team=SF) to get\n# the joint probability p(digit_KC, digit_SF | KC, SF)\njoint = (\n    home.join(away, on=\"final_digit\", how=\"cross\")\n    .with_columns(joint=pl.col(\"prop\") * pl.col(\"prop_right\"))\n    .sort(\"final_digit\", \"final_digit_right\")\n    .pivot(values=\"joint\", columns=\"final_digit_right\", index=\"final_digit\")\n    .with_columns((cs.all().exclude(\"final_digit\") * 100).round(1))\n)\n\n# Display -----\n\n(\n    GT(joint, rowname_col=\"final_digit\")\n    .data_color(domain=[0, 4], palette=[\"red\", \"grey\", \"blue\"])\n    .tab_header(\n        \"Super Bowl Squares | Final Score Probabilities\",\n        \"Based on all NFL regular season and playoff games (2015-2023)\",\n    )\n    .tab_stubhead(\"\")\n    .tab_spanner(\"San Francisco 49ers\", cs.all())\n    .tab_stubhead(\"KC Chiefs\")\n    .tab_source_note(\n        md(\n            '&lt;span style=\"float: right;\"&gt;Source data: [Lee Sharpe, nflverse](https://github.com/nflverse/nfldata)&lt;/span&gt;'\n        )\n    )\n)\n\n\n\n\n\n  \n    Super Bowl Squares | Final Score Probabilities\n  \n  \n    Based on all NFL regular season and playoff games (2015-2023)\n  \n\n\n  KC Chiefs\n  \n    San Francisco 49ers\n  \n\n\n  0\n  1\n  2\n  3\n  4\n  5\n  6\n  7\n  8\n  9\n\n\n  \n    0\n    2.3\n    1.5\n    0.6\n    2.4\n    1.7\n    0.9\n    1.2\n    3.2\n    1.1\n    0.8\n  \n  \n    1\n    1.8\n    1.2\n    0.5\n    1.9\n    1.3\n    0.7\n    0.9\n    2.6\n    0.9\n    0.6\n  \n  \n    2\n    1.1\n    0.7\n    0.3\n    1.2\n    0.8\n    0.4\n    0.6\n    1.6\n    0.5\n    0.4\n  \n  \n    3\n    1.7\n    1.1\n    0.5\n    1.8\n    1.3\n    0.7\n    0.9\n    2.5\n    0.8\n    0.6\n  \n  \n    4\n    1.8\n    1.2\n    0.5\n    1.9\n    1.3\n    0.7\n    0.9\n    2.6\n    0.9\n    0.6\n  \n  \n    5\n    0.7\n    0.5\n    0.2\n    0.7\n    0.5\n    0.3\n    0.4\n    1.0\n    0.3\n    0.2\n  \n  \n    6\n    1.0\n    0.6\n    0.2\n    1.0\n    0.7\n    0.4\n    0.5\n    1.4\n    0.5\n    0.3\n  \n  \n    7\n    2.3\n    1.5\n    0.6\n    2.4\n    1.7\n    0.9\n    1.2\n    3.4\n    1.1\n    0.8\n  \n  \n    8\n    0.8\n    0.5\n    0.2\n    0.8\n    0.6\n    0.3\n    0.4\n    1.1\n    0.4\n    0.3\n  \n  \n    9\n    1.0\n    0.7\n    0.3\n    1.1\n    0.8\n    0.4\n    0.5\n    1.5\n    0.5\n    0.4\n  \n\n  \n  \n  \n    Source data: Lee Sharpe, nflverse"
  },
  {
    "objectID": "blog/bring-your-own-df/index.html",
    "href": "blog/bring-your-own-df/index.html",
    "title": "Great Tables is now BYODF (Bring Your Own DataFrame)",
    "section": "",
    "text": "A few months ago, we released a blog post about how much we loved the combination of Polars and Great Tables. We found that Polars lazy expression system opened up convenient ways to conditionally format tables for presentation. However, excited as we were, we were harboring a shameful secret: Great Tables enabled Polars as an optional dependency, but had a hard dependency on the alternative DataFrame library Pandas.\nWe’re happy to share that Great Tables v0.5.0 makes Pandas an optional dependency. Using Pandas DataFrames as inputs is still fully supported. The optional dependency simply allows users of one DataFrame library to not have to install the other.\nIn this post, I’ll cover three important pieces:\nThis may seem over the top, but many DataFrame implementations exist in the Python world. Enabling folks to BYODF (Bring Your Own DataFrame) is a tricky, rewarding challenge!"
  },
  {
    "objectID": "blog/bring-your-own-df/index.html#the-state-of-great-tables-dependencies",
    "href": "blog/bring-your-own-df/index.html#the-state-of-great-tables-dependencies",
    "title": "Great Tables is now BYODF (Bring Your Own DataFrame)",
    "section": "The state of Great Tables dependencies",
    "text": "The state of Great Tables dependencies\nCurrently, Great Tables has two “sizes” of libraries it depends on:\n\nSmall: utility libraries for things like datetime localization.\nBig: a lingering dependency on numpy in a few places (like nanoplots).\n\nFor small utilities, we depend on Babel, which makes it easier to say things like, “format this number as if I’m in Germany”.\nFor big dependencies, numpy should be fairly straightforward to remove (see this issue). We also still rely on Pandas for datasets in great_tables.data, but we will remove it soon (see this issue).\nRemoving dependencies like numpy and Pandas helps people who are in restricted computing environments, want a more lightweight install, or who are stuck depending on a much earlier version of a package. It also helps us keep a clean separation of concerns. Without clear boundaries, it’s too tempting to reach for things like pd.isna() in a pinch, or smear library specific versions of missingness across our code (e.g. pd.NA, np.nan, polars.NullType)."
  },
  {
    "objectID": "blog/bring-your-own-df/index.html#the-challenge-of-removing-hard-dependencies",
    "href": "blog/bring-your-own-df/index.html#the-challenge-of-removing-hard-dependencies",
    "title": "Great Tables is now BYODF (Bring Your Own DataFrame)",
    "section": "The challenge of removing hard dependencies",
    "text": "The challenge of removing hard dependencies\nRemoving hard dependencies on DataFrame libraries is worthwhile, but requires special handling for all DataFrame specific actions. To illustrate consider the Great Tables output below, which is produced from a Pandas DataFrame:\n\nimport pandas as pd\nimport polars as pl\nfrom great_tables import GT\n\ndf_pandas = pd.DataFrame({\"x\": [\"a\", \"b\"], \"y\": [1.01, 2.0]})\ndf_polars = pl.from_pandas(df_pandas)\n\nGT(df_pandas)\n\n\n\n\n\n\n  x\n  y\n\n\n  \n    a\n    1.01\n  \n  \n    b\n    2.0\n  \n\n\n\n\n\n\n        \n\n\nProducing this table includes two actions on the DataFrame:\n\nGet column names: these are used for column labels (and other things).\nGet column types: these are used for alignment (e.g. numeric column is right aligned).\n\nWhile these actions may seem simple, they require different methods for different DataFrame implementations. In this post, we’ll focus specifically on the challenge of getting column names.\n\nGetting column names\nThe code below shows the different methods required to get column names as a list from Pandas and Polars.\n\ndf_pandas.columns.tolist()  # pandas\ndf_polars.columns           # polars\n\n['x', 'y']\n\n\nNotice that the two lines of code aren’t too different—Pandas just requires an extra .tolist() piece. We could create a special function, that returns a list of names, depending on the type of the input DataFrame.\n\ndef get_column_names(data) -&gt; list[str]:\n\n    # pandas specific ----\n    if isinstance(data, pd.DataFrame):\n        return data.columns.tolist()\n\n    # polars specific ----\n    elif isinstance(data, pl.DataFrame):\n        return data.columns\n\n    raise TypeError(f\"Unsupported type {type(data)}\")\n\nThe function works great, in that we can call it on either DataFrame, but it lacks two things. The first is dependency inversion, since it requires importing both Pandas and Polars (creating a hard dependency). The second is separation of concerns, since Pandas and Polars code is mixed together. In this case adding more DataFrame implementations would create a hot stew of logic."
  },
  {
    "objectID": "blog/bring-your-own-df/index.html#how-we-made-pandas-optional",
    "href": "blog/bring-your-own-df/index.html#how-we-made-pandas-optional",
    "title": "Great Tables is now BYODF (Bring Your Own DataFrame)",
    "section": "How we made Pandas optional",
    "text": "How we made Pandas optional\nWe were able to make Pandas optional in a sane manner through two moves:\n\ndatabackend: perform isinstance checks without importing anything.\nsingledispatch: split out functions like get_column_names() into DataFrame specific versions.\n\n\nInverting dependency with databackend\nInverting dependency on DataFrame libraries means that we check whether something is a specific type of DataFrame, without using imports. This is done through the package databackend, which we copied into Great Tables.\nIt works by creating placeholder classes, which stand in for the DataFrames they’re detecting:\n\nfrom great_tables._databackend import AbstractBackend\n\n\nclass PdDataFrame(AbstractBackend):\n    _backends = [(\"pandas\", \"DataFrame\")]\n\n\nclass PlDataFrame(AbstractBackend):\n    _backends = [(\"polars\", \"DataFrame\")]\n\n\nif isinstance(df_pandas, PdDataFrame):\n    print(\"I'm a pandas DataFrame!!!\")\n\nI'm a pandas DataFrame!!!\n\n\nNote that the PdDataFrame above is able to detect a Pandas DataFrame without importing Pandas, by taking advantage of a bit of logic called a counterfactual:\n\nassumption: if df_pandas is a Pandas DataFrame, then Pandas has been imported.\ncounterfactual: if Pandas has not been imported, then df_pandas is not a Pandas DataFrame.\n\nThis lets it quickly rule out a potential Pandas object by checking whether Pandas has been imported. Since this can be done by looking inside sys.modules, no imports are required. For more on this approach, see the databackend README.\n\n\nSeparating concerns with singledispatch\nWhile databackend removes dependencies, the use of singledispatch from the built-in functools module separates out the logic for handling Polars DataFrames from the logic for Pandas DataFrames. This makes it easier to think one DataFrame at a time, and also gets us better type hinting.\nHere’s a basic example, showing the get_column_names() function re-written using singledispatch:\n\nfrom functools import singledispatch\n\n\n# define the generic function ----\n#\n@singledispatch\ndef get_column_names(data) -&gt; list[str]:\n    raise TypeError(f\"Unsupported type {type(data)}\")\n\n\n# register a pandas implementation on it ----\n#\n@get_column_names.register\ndef _(data: PdDataFrame):\n    return data.columns.tolist()\n\n\n# register a polars implementation on it ----\n#\n@get_column_names.register\ndef _(data: PlDataFrame):\n    return data.columns\n\nNote three important pieces:\n\nThe initial @singledispatch decorates def get_column_names(...). This creates a special “generic function”, which can define DataFrame specific implementations.\n@get_column_names.register implements the Pandas DataFrame.\nThe use of PdDataFrame is what signifies “run this for Pandas DataFrames”.\n\nWith the get_column_names implementations defined, we can call it like a normal function:\n\nget_column_names(df_pandas)  # pandas version\nget_column_names(df_polars)  # polars version\n\n['x', 'y']\n\n\nFor more on the benefits of singledispatch in data tooling, see the blog post Single Dispatch for Data Science Tools. For the nitty gritty on our DataFrame processing, see the Great Tables _tbl_data.py submodule."
  },
  {
    "objectID": "blog/bring-your-own-df/index.html#see-you-in-the-polarsverse",
    "href": "blog/bring-your-own-df/index.html#see-you-in-the-polarsverse",
    "title": "Great Tables is now BYODF (Bring Your Own DataFrame)",
    "section": "See you in the Polarsverse",
    "text": "See you in the Polarsverse\nThis was a long diversion into the strategy behind supporting both Pandas and Polars, but the results are worth it. Users are able to bring their DataFrame of choice without the collective baggage of every DataFrame option.\nFor more on the special things you can do with Polars expressions, see these resources:\n\nGuide: basic styling using Polars expressions\nPost: Great Tables, the Polars DataFrame Styler of Your Dreams\nThe narwhals library: a neat library for running Polars expressions on Pandas DataFrames.\n\nHope you make some stylish, publication ready tables!"
  },
  {
    "objectID": "blog/introduction-0.4.0/index.html",
    "href": "blog/introduction-0.4.0/index.html",
    "title": "Great Tables v0.4.0: Nanoplots and More",
    "section": "",
    "text": "The recent v0.4.0 release of Great Tables contains nanoplots as a major new feature. So, in this post I’ll concentrate on showing you all the things you can do with nanoplots. What are nanoplots? Well, with nanoplots you can do this:\n\n\nShow the code\nfrom great_tables import GT, md\nfrom great_tables.data import illness\nimport polars as pl\n\nillness_mini = (\n    pl.from_pandas(illness)\n    .head(10)\n    .select(\n        \"test\", values=pl.concat_str(pl.exclude(\"test\", \"units\"), separator=\" \", ignore_nulls=True)\n    )\n    .slice(1, 9)\n)\n\n(\n    GT(illness_mini, rowname_col=\"test\")\n    .fmt_nanoplot(columns=\"values\")\n    .tab_header(md(\"Partial summary of daily tests&lt;br&gt;performed on YF patient\"))\n    .tab_stubhead(label=md(\"**Test**\"))\n    .cols_label(values=md(\"*Progression*\"))\n    .cols_align(align=\"center\", columns=\"values\")\n    .tab_source_note(source_note=\"Measurements from Day 3 through to Day 8.\")\n)\n\n\n\n\n\n\n  \n    Partial summary of daily testsperformed on YF patient\n  \n\n\n  Test\n  Progression\n\n\n  \n    WBC\n    30.34.005.264.269.9210.524.830.319.04.0010.0\n  \n  \n    Neutrophils\n    27.22.004.874.727.9218.222.127.216.62.008.00\n  \n  \n    RBC\n    5.982.685.725.984.234.834.122.683.324.005.50\n  \n  \n    Hb\n    16075.015313512611575.087.095.0120160\n  \n  \n    PLT\n    30025.667.038.627.426.274.136.225.6100300\n  \n  \n    ALT\n    12.8K9.0012.8K12.6K6.43K4.26K1.62K6735129.0050.0\n  \n  \n    AST\n    23.7K15.023.7K21.4K14.7K8.69K2.19K1.14K78215.040.0\n  \n  \n    TBIL\n    1630117144137158127105163018.8\n  \n  \n    DBIL\n    144071.410594.614411883.612606.80\n  \n\n  \n  \n  \n    Measurements from Day 3 through to Day 8.\n  \n\n\n\n\n\n\n        \n\n\nWhile the emphasis here will be on the aforementioned nanoplots feature, the last two releases (v0.3.1 and v0.4.0) overall gave us a nice collection of improvements which includes:\n\nthe fmt_nanoplot() method for adding nanoplots to your table\nimproved HTML table representations in different code environments\nintegration of Polars selectors in the columns= arg of all formatting (fmt_*()) methods\nthe save() method for saving a GT table as an image file\nrendering a GT table as an HTML string though as_raw_html()\n\nNow let’s dive into the wonderful world of nanoplots!\n\nNanoplots, small interactive plots in your table\nNanoplots are small yet information-laden plots that fit nicely into table cells. They are interactive, allowing for more information to be shown on hovering (or through touch when that interaction is available). Nanoplots try to show individual data points with reasonably good visibility (space is limited, this is going in a table after all!) and the plot representations change depending on the data fed into them.\nWe can generate nanoplots via the fmt_nanoplot() method. Let’s make two nanoplots of the two different available plot types: \"line\" and \"bar\":\n\nrandom_numbers_df = pl.DataFrame(\n    {\n        \"i\": range(1, 5),\n        \"lines\": [\n            \"20 23 6 7 37 23 21 4 7 16\",\n            \"2.3 6.8 9.2 2.42 3.5 12.1 5.3 3.6 7.2 3.74\",\n            \"-12 -5 6 3.7 0 8 -7.4\",\n            \"2 0 15 7 8 10 1 24 17 13 6\",\n        ],\n    }\n).with_columns(bars=pl.col(\"lines\"))\n\n(\n    GT(random_numbers_df, rowname_col=\"i\")\n    .fmt_nanoplot(columns=\"lines\", plot_type=\"line\")\n    .fmt_nanoplot(columns=\"bars\", plot_type=\"bar\")\n)\n\n\n\n\n\n\n  \n  lines\n  bars\n\n\n  \n    1\n    37.04.0020.023.06.007.0037.023.021.04.007.0016.0\n    37.0020.023.06.007.0037.023.021.04.007.0016.0\n  \n  \n    2\n    12.12.302.306.809.202.423.5012.15.303.607.203.74\n    12.102.306.809.202.423.5012.15.303.607.203.74\n  \n  \n    3\n    8.00−12.0−12.0−5.006.003.7008.00−7.40\n    8.00−12.0−12.0−5.006.003.7008.00−7.40\n  \n  \n    4\n    24.002.00015.07.008.0010.01.0024.017.013.06.00\n    24.002.00015.07.008.0010.01.0024.017.013.06.00\n  \n\n\n\n\n\n\n        \n\n\nAs can be seen, the method accepts bundles of values per cell that are formatted as strings (with spaces between each of the values). You can also use Polars list columns as acceptable input.\n\n\nAdding reference lines and highlighted areas\nIt’s possible to add in a reference line and a reference area to individual plots. These may be useful to highlight a particular statistic (e.g., median or minimum value) or a bounded region of interest (e.g., the area between the first and third quartiles). Here is an example of how to use these options via the reference_line= and reference_area= arguments:\n\n(\n    GT(random_numbers_df, rowname_col=\"i\")\n    .fmt_nanoplot(\n        columns=\"lines\",\n        reference_line=\"mean\",\n        reference_area=[\"min\", \"q1\"]\n    )\n    .fmt_nanoplot(\n        columns=\"bars\",\n        plot_type=\"bar\",\n        reference_line=\"max\",\n        reference_area=[\"max\", \"median\"])\n)\n\n\n\n\n\n\n  \n  lines\n  bars\n\n\n  \n    1\n    16.437.04.0020.023.06.007.0037.023.021.04.007.0016.0\n    37.037.04.0020.023.06.007.0037.023.021.04.007.0016.0\n  \n  \n    2\n    5.6212.12.302.306.809.202.423.5012.15.303.607.203.74\n    12.112.12.302.306.809.202.423.5012.15.303.607.203.74\n  \n  \n    3\n    −0.968.00−12.0−12.0−5.006.003.7008.00−7.40\n    8.008.00−12.0−12.0−5.006.003.7008.00−7.40\n  \n  \n    4\n    9.3624.002.00015.07.008.0010.01.0024.017.013.06.00\n    24.024.002.00015.07.008.0010.01.0024.017.013.06.00\n  \n\n\n\n\n\n\n        \n\n\nHaving a reference line and/or area can be valuable in different situations. We make it easy by allowing you to mix-and-match numeric values and a set of keywords (these are: \"mean\", \"median\", \"min\", \"max\", \"q1\", \"q3\", \"first\", or \"last\").\n\n\nSimple bars\nWe can also have single-value bar plots and line plots. These will run in the horizontal direction and such plots are meant for easy value comparisons (which works great in tables). To make this work, give fmt_nanoplot() a column of numeric values. The following example shows how fmt_nanoplot() can be used to create single-value bar and line plots.\n\nsingle_vals_df = pl.DataFrame(\n    {\n        \"i\": range(1, 6),\n        \"bars\": [4.1, 1.3, -5.3, 0, 8.2],\n        \"lines\": [12.44, 6.34, 5.2, -8.2, 9.23]\n    }\n)\n\n(\n    GT(single_vals_df, rowname_col=\"i\")\n    .fmt_nanoplot(columns=\"bars\", plot_type=\"bar\")\n    .fmt_nanoplot(columns=\"lines\", plot_type=\"line\")\n)\n\n\n\n\n\n\n  \n  bars\n  lines\n\n\n  \n    1\n    4.10\n    12.4\n  \n  \n    2\n    1.30\n    6.34\n  \n  \n    3\n    −5.30\n    5.20\n  \n  \n    4\n    0\n    −8.20\n  \n  \n    5\n    8.20\n    9.23\n  \n\n\n\n\n\n\n        \n\n\nNotice that there is some light interactivity available here as well! When hovering over a plotted bar or line the data value will appear.\n\n\nCustomizing with nanoplot_options()\nWe provide a lot of options for customizing your nanoplots. With the nanoplot_options() helper function, it’s possible to change the look and feel for a set of nanoplots. The options= argument of fmt_nanoplot() is where you’d need to invoke that helper function. Some possibilities for customization include determining which nanoplot elements are present, changing the sizes and colors of different elements, and a whole lot more! Here’s an example where both line- and bar-based nanoplots retain their basic compositional elements, but their appearance is quite different.\n\nfrom great_tables import nanoplot_options\n\n(\n    GT(random_numbers_df)\n    .fmt_nanoplot(\n        columns=\"lines\",\n        options=nanoplot_options(\n            data_point_radius=8,\n            data_point_stroke_color=\"black\",\n            data_point_stroke_width=3,\n            data_point_fill_color=\"white\",\n            data_line_type=\"straight\",\n            data_line_stroke_color=\"green\",\n            data_line_stroke_width=5,\n            data_area_fill_color=\"green\",\n            show_data_area=False,\n        ),\n    )\n    .fmt_nanoplot(\n        columns=\"bars\",\n        plot_type=\"bar\",\n        options=nanoplot_options(\n            data_bar_stroke_color=\"brown\",\n            data_bar_fill_color=\"yellow\",\n            data_bar_negative_stroke_color=\"black\",\n            data_bar_negative_fill_color=\"blue\",\n        ),\n    )\n)\n\n\n\n\n\n\n  i\n  lines\n  bars\n\n\n  \n    1\n    37.04.0020.023.06.007.0037.023.021.04.007.0016.0\n    37.0020.023.06.007.0037.023.021.04.007.0016.0\n  \n  \n    2\n    12.12.302.306.809.202.423.5012.15.303.607.203.74\n    12.102.306.809.202.423.5012.15.303.607.203.74\n  \n  \n    3\n    8.00−12.0−12.0−5.006.003.7008.00−7.40\n    8.00−12.0−12.0−5.006.003.7008.00−7.40\n  \n  \n    4\n    24.002.00015.07.008.0010.01.0024.017.013.06.00\n    24.002.00015.07.008.0010.01.0024.017.013.06.00\n  \n\n\n\n\n\n\n        \n\n\nWe want you to have a lot of creative control for how these tiny plots are displayed. So, when you need it, nanoplot_options() is there for you!\n\n\nWrapping up\nWe’re always excited to offer new and exciting features that make summary tables fun and useful. The new nanoplots functionality is something we will continue to iterate on since there is definitely room for plotting innovation in tables for display. And there’s a lot more to nanoplots than these examples can show. For much more information on this, check out the Get Started guide on nanoplots. Please let us know through GitHub Issues whether you ran into problems with this (or any other) feature, or, if you have suggestions for improvement!"
  },
  {
    "objectID": "blog/design-philosophy/index.html",
    "href": "blog/design-philosophy/index.html",
    "title": "The Design Philosophy of Great Tables",
    "section": "",
    "text": "We’ve spent a lot of time thinking about tables. Tables—like plots—are crucial as a last step toward presenting information. There is surprising sophistication and nuance in designing effective tables. Over the past 5,000 years, they’ve evolved from simple grids to highly structured displays of data. Although we argue that the mid-1900s served as a high point, the popularization and wider accessibility of computing seemingly brought us back to the simple, ancient times.\nOkay, it’s not all that bad but the workers of data are today confronted with an all-too-familiar dilemma: copy your data into a tool like Excel to make the table, or, display an otherwise unpolished table. Through the exploration of the qualities that make tables shine, the backstory of tables as a display of data, and the issues faced today, it’s clear how we can solve the great table dilemma with Great Tables.\nTables made with computers (left to right): (1) a DataFrame printed at the console, (2) an Excel table, and (3) a Great Tables table."
  },
  {
    "objectID": "blog/design-philosophy/index.html#footnotes",
    "href": "blog/design-philosophy/index.html#footnotes",
    "title": "The Design Philosophy of Great Tables",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nTaylor, B. (2021). Lunar timekeeping in Upper Paleolithic Cave Art. PRAEHISTORIA New Series, 3(13), 215–232.↩︎\nDuke, D. W. (2002). Hipparchus’ Coordinate System. Archive for History of Exact Sciences, 56(5), 427-433.↩︎\nhttps://en.wikipedia.org/wiki/Geography_(Ptolemy)↩︎\nPalet, J. M. and Orengo, H. A., The Roman Centuriated Landscape: Conception, Genesis, and Development as Inferred from the Ager Tarraconensis Case. American Journal of Archaeology, 115(3), 383-402.↩︎\nMarchese, F. T., Exploring the Origins of Tables for Information Visualization. Proceedings of the 2011 15th International Conference on Information Visualisation, 13-15 July 2011, doi:10.1109/IV.2011.36.↩︎\nM. W. Green, The construction and implementation of the cuneiform writing system, Visible Writing, 15, 1981, 345-72.↩︎\nRobson, E., “Tables and tabular formatting in Sumer, Babylonia, and Assyria, 2500-50 BCE” in M. Campbell-Kelly, M. Croarken, R.G. Flood, and E. Robson (eds.), The History of Mathematical Tables from Sumer to Spreadsheets. Oxford: Oxford University Press, 2003, 18–47.↩︎\nhttps://site.xavier.edu/polt/typewriters/varityper.html↩︎\nManual of Tabular Presentation: An Outline of Theory and Practice in the Presentation of Statistical Data in Tables for Publication. United States. Bureau of the Census. U.S. Government Printing Office, 1949. Resource available at: https://www2.census.gov/library/publications/1949/general/tabular-presentation.pdf.↩︎"
  },
  {
    "objectID": "articles/intro.html",
    "href": "articles/intro.html",
    "title": "great_tables",
    "section": "",
    "text": "Absolutely Delightful Table-making in Python\nWith Great Tables anyone can make wonderful-looking tables in Python. The philosophy here is that we can construct a wide variety of useful tables by working with a cohesive set of table components. You can mix and match things like a header and footer, attach a stub (which contains row labels), arrange spanner labels over top of the column labels, and much more. Not only that, but you can format the cell values in a variety of awesome ways.\nIt all begins with table data in the form of a Pandas or Polars DataFrame. You then decide how to compose your output table with the elements and formatting you need for the task at hand. Finally, the table is rendered by printing it at the console, including it in an notebook environment, or rendering it inside a Quarto document.\nThe Great Tables package is designed to be both straightforward yet powerful. The emphasis is on simple methods for the everyday display table needs (but power when you need it). Here is a brief example of how to use Great Tables to create a table from the included sp500 dataset:\nThere are ten datasets provided by Great Tables: countrypops, sza, gtcars, sp500, pizzaplace, exibble, towny, metro, constants, and illness.\nAll of this tabular data is great for experimenting with the functionality available inside Great Tables and we make extensive use of these datasets in our documentation.\nBeyond the methods shown in the simple sp500-based example, there are many possible ways to create super-customized tables. Check out the documentation website to get started via introductory articles for making Great Tables. There’s a handy Reference section that has detailed help for every method and function in the package.\nLet’s talk about how to make Great Tables! There are a few locations where there is much potential for discussion.\nOne such place is in GitHub Discussions. This discussion board is especially great for Q&A, and many people have had their problems solved in there.\nAnother fine venue for discussion is in our Discord server. This is a good option for asking about the development of Great Tables, pitching ideas that may become features, and sharing your table creations!\nFinally, there is the X account. There you’ll find tweets about Great Tables (including sneak previews about in-development features) and other table-generation packages.\nThese are all great places to ask questions about how to use the package, discuss some ideas, engage with others, and much more!"
  },
  {
    "objectID": "articles/intro.html#installation",
    "href": "articles/intro.html#installation",
    "title": "great_tables",
    "section": "INSTALLATION",
    "text": "INSTALLATION\nThe Great Tables package can be installed from PyPI with:\n$ pip install great_tables\nIf you encounter a bug, have usage questions, or want to share ideas to make this package better, please feel free to file an issue."
  },
  {
    "objectID": "articles/intro.html#code-of-conduct",
    "href": "articles/intro.html#code-of-conduct",
    "title": "great_tables",
    "section": "Code of Conduct",
    "text": "Code of Conduct\nPlease note that the Great Tables project is released with a contributor code of conduct.By participating in this project you agree to abide by its terms."
  },
  {
    "objectID": "articles/intro.html#license",
    "href": "articles/intro.html#license",
    "title": "great_tables",
    "section": "📄 License",
    "text": "📄 License\nGreat Tables is licensed under the MIT license.\n© Posit Software, PBC."
  },
  {
    "objectID": "articles/intro.html#governance",
    "href": "articles/intro.html#governance",
    "title": "great_tables",
    "section": "🏛️ Governance",
    "text": "🏛️ Governance\nThis project is primarily maintained by Rich Iannone and Michael Chow. Other authors may occasionally assist with some of these duties."
  },
  {
    "objectID": "reference/md.html",
    "href": "reference/md.html",
    "title": "md",
    "section": "",
    "text": "md(text)\nInterpret input text as Markdown-formatted text.\nMarkdown can be used in certain places (e.g., source notes, table title/subtitle, etc.) and we can expect it to render to HTML. There is also the html() helper function that allows you to use raw HTML text.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntext\nstr\nThe text that is understood to contain Markdown formatting.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nText\nAn instance of the Text class is returned, where the text type is \"from_markdown\"."
  },
  {
    "objectID": "reference/md.html#parameters",
    "href": "reference/md.html#parameters",
    "title": "md",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ntext\nstr\nThe text that is understood to contain Markdown formatting.\nrequired"
  },
  {
    "objectID": "reference/md.html#returns",
    "href": "reference/md.html#returns",
    "title": "md",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nText\nAn instance of the Text class is returned, where the text type is \"from_markdown\"."
  },
  {
    "objectID": "reference/from_column.html",
    "href": "reference/from_column.html",
    "title": "from_column",
    "section": "",
    "text": "from_column(column, na_value=None, fn=None)\nSpecify that a style value should be fetched from a column in the data."
  },
  {
    "objectID": "reference/from_column.html#examples",
    "href": "reference/from_column.html#examples",
    "title": "from_column",
    "section": "Examples",
    "text": "Examples\n\nimport pandas as pd\nfrom great_tables import GT, exibble, from_column, loc, style\n\ndf = pd.DataFrame({\"x\": [1, 2], \"color\": [\"red\", \"blue\"]})\n\n(\n    GT(df)\n    .tab_style(\n        style=style.text(color=from_column(\"color\")),\n        locations=loc.body(columns=[\"x\"])\n    )\n)\n\n\n\n\n\n\n  x\n  color\n\n\n  \n    1\n    red\n  \n  \n    2\n    blue\n  \n\n\n\n\n\n\n        \n\n\nIf you are using polars, you can just pass polars expressions in directly:\n\nimport polars as pl\nfrom great_tables import GT, exibble, from_column, loc, style\n\ndf_polars = pl.from_pandas(df)\n\n(\n    GT(df_polars)\n    .tab_style(\n        style=style.text(color=pl.col(\"color\")),\n        locations=loc.body(columns=[\"x\"])\n    )\n)\n\n\n\n\n\n\n  x\n  color\n\n\n  \n    1\n    red\n  \n  \n    2\n    blue"
  },
  {
    "objectID": "reference/GT.data_color.html",
    "href": "reference/GT.data_color.html",
    "title": "GT.data_color",
    "section": "",
    "text": "GT.data_color(self, columns=None, palette=None, domain=None, na_color=None, alpha=None, reverse=False, autocolor_text=True)\nPerform data cell colorization.\nIt’s possible to add color to data cells according to their values with the data_color() method. There is a multitude of ways to perform data cell colorizing here:"
  },
  {
    "objectID": "reference/GT.data_color.html#parameters",
    "href": "reference/GT.data_color.html#parameters",
    "title": "GT.data_color",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nUnion[str, List[str], None]\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\npalette\nUnion[str, List[str], None]\nThe color palette to use. This should be a list of colors (e.g., [\"#FF0000\", \"#00FF00\", \"#0000FF\"]). A ColorBrewer palette could also be used, just supply the name (reference available in the Color palette access from ColorBrewer section). If None, then a default palette will be used.\nNone\n\n\ndomain\nUnion[List[str], List[float], List[int], None]\nThe domain of values to use for the color scheme. This can be a list of floats, integers, or strings. If None, then the domain will be inferred from the data values.\nNone\n\n\nna_color\nOptional[str]\nThe color to use for missing values. If None, then the default color (\"#808080\") will be used.\nNone\n\n\nalpha\nOptional[Union[int, float]]\nAn optional, fixed alpha transparency value that will be applied to all color palette values.\nNone\n\n\nreverse\nbool\nShould the colors computed operate in the reverse order? If True then colors that normally change from red to blue will change in the opposite direction.\nFalse\n\n\nautocolor_text\nbool\nWhether or not to automatically color the text of the data values. If True, then the text will be colored according to the background color of the cell.\nTrue"
  },
  {
    "objectID": "reference/GT.data_color.html#returns",
    "href": "reference/GT.data_color.html#returns",
    "title": "GT.data_color",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.data_color.html#color-palette-access-from-colorbrewer-and-viridis",
    "href": "reference/GT.data_color.html#color-palette-access-from-colorbrewer-and-viridis",
    "title": "GT.data_color",
    "section": "Color Palette Access From Colorbrewer And Viridis",
    "text": "Color Palette Access From Colorbrewer And Viridis\nAll palettes from the ColorBrewer package can be accessed by providing the palette name in palette=. There are 35 available palettes:\n\n\n\n\nPalette Name\nColors\nCategory\nColorblind Friendly\n\n\n\n\n1\n\"BrBG\"\n11\nDiverging\nYes\n\n\n2\n\"PiYG\"\n11\nDiverging\nYes\n\n\n3\n\"PRGn\"\n11\nDiverging\nYes\n\n\n4\n\"PuOr\"\n11\nDiverging\nYes\n\n\n5\n\"RdBu\"\n11\nDiverging\nYes\n\n\n6\n\"RdYlBu\"\n11\nDiverging\nYes\n\n\n7\n\"RdGy\"\n11\nDiverging\nNo\n\n\n8\n\"RdYlGn\"\n11\nDiverging\nNo\n\n\n9\n\"Spectral\"\n11\nDiverging\nNo\n\n\n10\n\"Dark2\"\n8\nQualitative\nYes\n\n\n11\n\"Paired\"\n12\nQualitative\nYes\n\n\n12\n\"Set1\"\n9\nQualitative\nNo\n\n\n13\n\"Set2\"\n8\nQualitative\nYes\n\n\n14\n\"Set3\"\n12\nQualitative\nNo\n\n\n15\n\"Accent\"\n8\nQualitative\nNo\n\n\n16\n\"Pastel1\"\n9\nQualitative\nNo\n\n\n17\n\"Pastel2\"\n8\nQualitative\nNo\n\n\n18\n\"Blues\"\n9\nSequential\nYes\n\n\n19\n\"BuGn\"\n9\nSequential\nYes\n\n\n20\n\"BuPu\"\n9\nSequential\nYes\n\n\n21\n\"GnBu\"\n9\nSequential\nYes\n\n\n22\n\"Greens\"\n9\nSequential\nYes\n\n\n23\n\"Greys\"\n9\nSequential\nYes\n\n\n24\n\"Oranges\"\n9\nSequential\nYes\n\n\n25\n\"OrRd\"\n9\nSequential\nYes\n\n\n26\n\"PuBu\"\n9\nSequential\nYes\n\n\n27\n\"PuBuGn\"\n9\nSequential\nYes\n\n\n28\n\"PuRd\"\n9\nSequential\nYes\n\n\n29\n\"Purples\"\n9\nSequential\nYes\n\n\n30\n\"RdPu\"\n9\nSequential\nYes\n\n\n31\n\"Reds\"\n9\nSequential\nYes\n\n\n32\n\"YlGn\"\n9\nSequential\nYes\n\n\n33\n\"YlGnBu\"\n9\nSequential\nYes\n\n\n34\n\"YlOrBr\"\n9\nSequential\nYes\n\n\n35\n\"YlOrRd\"\n9\nSequential\nYes\n\n\n\nWe can also use the viridis and associated color palettes by providing to palette= any of the following string values: \"viridis\", \"plasma\", \"inferno\", \"magma\", or \"cividis\"."
  },
  {
    "objectID": "reference/GT.data_color.html#examples",
    "href": "reference/GT.data_color.html#examples",
    "title": "GT.data_color",
    "section": "Examples",
    "text": "Examples\nThe data_color() method can be used without any supplied arguments to colorize a table. Let’s do this with the exibble dataset:\n\nimport great_tables as gt\n\ngt.GT(gt.data.exibble).data_color()\n\n\n\n\n\n\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n  row\n  group\n\n\n  \n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n    row_1\n    grp_a\n  \n  \n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n    row_2\n    grp_a\n  \n  \n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n    row_3\n    grp_a\n  \n  \n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n    row_4\n    grp_a\n  \n  \n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n    row_5\n    grp_b\n  \n  \n    \n    fig\n    six\n    2015-06-15\n    \n    2018-06-06 16:11\n    13.255\n    row_6\n    grp_b\n  \n  \n    777000.0\n    grapefruit\n    seven\n    \n    19:10\n    2018-07-07 05:22\n    \n    row_7\n    grp_b\n  \n  \n    8880000.0\n    honeydew\n    eight\n    2015-08-15\n    20:20\n    \n    0.44\n    row_8\n    grp_b\n  \n\n\n\n\n\n\n        \n\n\nWhat’s happened is that data_color() applies background colors to all cells of every column with the palette of eight colors. Numeric columns will use ‘numeric’ methodology for color scaling whereas string-based columns will use the ‘factor’ methodology. The text color undergoes an automatic modification that maximizes contrast (since autocolor_text=True by default).\nWe can target specific colors and apply color to just those columns. Let’s do that and also supply palette= values of \"red\" and \"green\".\n\ngt.GT(gt.data.exibble).data_color(\n    columns=[\"num\", \"currency\"],\n    palette=[\"red\", \"green\"]\n)\n\n\n\n\n\n\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n  row\n  group\n\n\n  \n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n    row_1\n    grp_a\n  \n  \n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n    row_2\n    grp_a\n  \n  \n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n    row_3\n    grp_a\n  \n  \n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n    row_4\n    grp_a\n  \n  \n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n    row_5\n    grp_b\n  \n  \n    \n    fig\n    six\n    2015-06-15\n    \n    2018-06-06 16:11\n    13.255\n    row_6\n    grp_b\n  \n  \n    777000.0\n    grapefruit\n    seven\n    \n    19:10\n    2018-07-07 05:22\n    \n    row_7\n    grp_b\n  \n  \n    8880000.0\n    honeydew\n    eight\n    2015-08-15\n    20:20\n    \n    0.44\n    row_8\n    grp_b\n  \n\n\n\n\n\n\n        \n\n\nWith those options in place we see that only the numeric columns num and currency received color treatments. Moreover, the palette colors were mapped to the lower and upper limits of the data in each column; interpolated colors were used for the values in between the numeric limits of the two columns.\nWe can manually set the limits of the data with the domain= argument (which is preferable in most cases). Let’s colorize just the currency column and set domain=[0, 50]. Any values that are either missing or lie outside of the domain will be colorized with the na_color= color (so we’ll set that to \"lightgray\").\n\ngt.GT(gt.data.exibble).data_color(\n    columns=\"currency\",\n    palette=[\"red\", \"green\"],\n    domain=[0, 50],\n    na_color=\"lightgray\"\n)\n\n\n\n\n\n\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n  row\n  group\n\n\n  \n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n    row_1\n    grp_a\n  \n  \n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n    row_2\n    grp_a\n  \n  \n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n    row_3\n    grp_a\n  \n  \n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n    row_4\n    grp_a\n  \n  \n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n    row_5\n    grp_b\n  \n  \n    \n    fig\n    six\n    2015-06-15\n    \n    2018-06-06 16:11\n    13.255\n    row_6\n    grp_b\n  \n  \n    777000.0\n    grapefruit\n    seven\n    \n    19:10\n    2018-07-07 05:22\n    \n    row_7\n    grp_b\n  \n  \n    8880000.0\n    honeydew\n    eight\n    2015-08-15\n    20:20\n    \n    0.44\n    row_8\n    grp_b"
  },
  {
    "objectID": "reference/vals.fmt_markdown.html",
    "href": "reference/vals.fmt_markdown.html",
    "title": "vals.fmt_markdown",
    "section": "",
    "text": "vals.fmt_markdown(x)\nFormat Markdown text.\nAny Markdown-formatted text can be transformed to HTML when using the fmt_markdown() function.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/vals.fmt_markdown.html#parameters",
    "href": "reference/vals.fmt_markdown.html#parameters",
    "title": "vals.fmt_markdown",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired"
  },
  {
    "objectID": "reference/vals.fmt_markdown.html#returns",
    "href": "reference/vals.fmt_markdown.html#returns",
    "title": "vals.fmt_markdown",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/GT.fmt_scientific.html",
    "href": "reference/GT.fmt_scientific.html",
    "title": "GT.fmt_scientific",
    "section": "",
    "text": "GT.fmt_scientific(self, columns=None, rows=None, decimals=2, n_sigfig=None, drop_trailing_zeros=False, drop_trailing_dec_mark=True, scale_by=1, exp_style='x10n', pattern='{x}', sep_mark=',', dec_mark='.', force_sign_m=False, force_sign_n=False, locale=None)\nFormat values to scientific notation.\nWith numeric values in a table, we can perform formatting so that the targeted values are rendered in scientific notation, where extremely large or very small numbers can be expressed in a more practical fashion. Here, numbers are written in the form of a mantissa (m) and an exponent (n) with the construction m x 10^n or mEn. The mantissa component is a number between 1 and 10. For instance, 2.5 x 10^9 can be used to represent the value 2,500,000,000 in scientific notation. In a similar way, 0.00000012 can be expressed as 1.2 x 10^-7. Due to its ability to describe numbers more succinctly and its ease of calculation, scientific notation is widely employed in scientific and technical domains.\nWe have fine control over the formatting task, with the following options:"
  },
  {
    "objectID": "reference/GT.fmt_scientific.html#parameters",
    "href": "reference/GT.fmt_scientific.html#parameters",
    "title": "GT.fmt_scientific",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in targeted columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\ndecimals\nint\nThe decimals values corresponds to the exact number of decimal places to use. A value such as 2.34 can, for example, be formatted with 0 decimal places and it would result in \"2\". With 4 decimal places, the formatted value becomes \"2.3400\". The trailing zeros can be removed with drop_trailing_zeros=True.\n2\n\n\nn_sigfig\nOptional[int]\nA option to format numbers to n significant figures. By default, this is None and thus number values will be formatted according to the number of decimal places set via decimals. If opting to format according to the rules of significant figures, n_sigfig must be a number greater than or equal to 1. Any values passed to the decimals and drop_trailing_zeros arguments will be ignored.\nNone\n\n\ndrop_trailing_zeros\nbool\nA boolean value that allows for removal of trailing zeros (those redundant zeros after the decimal mark).\nFalse\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nscale_by\nfloat\nAll numeric values will be multiplied by the scale_by value before undergoing formatting. Since the default value is 1, no values will be changed unless a different multiplier value is supplied.\n1\n\n\nexp_style\nstr\nStyle of formatting to use for the scientific notation formatting. By default this is \"x10n\" but other options include using a single letter (e.g., \"e\", \"E\", etc.), a letter followed by a \"1\" to signal a minimum digit width of one, or \"low-ten\" for using a stylized \"10\" marker.\n'x10n'\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign_m\nbool\nShould the plus sign be shown for positive values of the mantissa (first component)? This would effectively show a sign for all values except zero on the first numeric component of the notation. If so, use True (the default for this is False), where only negative numbers will display a sign.\nFalse\n\n\nforce_sign_n\nbool\nShould the plus sign be shown for positive values of the exponent (second component)? This would effectively show a sign for all values except zero on the second numeric component of the notation. If so, use True (the default for this is False), where only negative numbers will display a sign.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/GT.fmt_scientific.html#returns",
    "href": "reference/GT.fmt_scientific.html#returns",
    "title": "GT.fmt_scientific",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.fmt_scientific.html#adapting-output-to-a-specific-locale",
    "href": "reference/GT.fmt_scientific.html#adapting-output-to-a-specific-locale",
    "title": "GT.fmt_scientific",
    "section": "Adapting Output To A Specific Locale",
    "text": "Adapting Output To A Specific Locale\nThis formatting method can adapt outputs according to a provided locale value. Examples include \"en\" for English (United States) and \"fr\" for French (France). The use of a valid locale ID here means separator and decimal marks will be correct for the given locale. Should any values be provided in sep_mark or dec_mark, they will be overridden by the locale’s preferred values.\nNote that a locale value provided here will override any global locale setting performed in GT()’s own locale argument (it is settable there as a value received by all other methods that have a locale argument)."
  },
  {
    "objectID": "reference/GT.fmt_scientific.html#examples",
    "href": "reference/GT.fmt_scientific.html#examples",
    "title": "GT.fmt_scientific",
    "section": "Examples",
    "text": "Examples\nFor this example, we’ll use the exibble dataset as the input table. With the fmt_scientific() method, we’ll format the num column to contain values in scientific formatting.\n\nfrom great_tables import GT, exibble\n\n(\n    GT(exibble)\n    .fmt_scientific(columns=\"num\")\n)\n\n\n\n\n\n\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n  row\n  group\n\n\n  \n    1.11 × 10−1\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n    row_1\n    grp_a\n  \n  \n    2.22\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n    row_2\n    grp_a\n  \n  \n    3.33 × 101\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n    row_3\n    grp_a\n  \n  \n    4.44 × 102\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n    row_4\n    grp_a\n  \n  \n    5.55 × 103\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n    row_5\n    grp_b\n  \n  \n    \n    fig\n    six\n    2015-06-15\n    \n    2018-06-06 16:11\n    13.255\n    row_6\n    grp_b\n  \n  \n    7.77 × 105\n    grapefruit\n    seven\n    \n    19:10\n    2018-07-07 05:22\n    \n    row_7\n    grp_b\n  \n  \n    8.88 × 106\n    honeydew\n    eight\n    2015-08-15\n    20:20\n    \n    0.44\n    row_8\n    grp_b"
  },
  {
    "objectID": "reference/GT.fmt_scientific.html#see-also",
    "href": "reference/GT.fmt_scientific.html#see-also",
    "title": "GT.fmt_scientific",
    "section": "See Also",
    "text": "See Also\nThe functional version of this method, val_fmt_scientific(), allows you to format a single numerical value (or a list of them)."
  },
  {
    "objectID": "reference/GT.cols_move_to_end.html",
    "href": "reference/GT.cols_move_to_end.html",
    "title": "GT.cols_move_to_end",
    "section": "",
    "text": "GT.cols_move_to_end(data, columns)\nMove one or more columns to the end.\nWe can easily move set of columns to the beginning of the column series and we only need to specify which columns. It’s possible to do this upstream of Great Tables, however, it is easier with this method and it presents less possibility for error. The ordering of the columns that are moved to the end is preserved (same with the ordering of all other columns in the table)."
  },
  {
    "objectID": "reference/GT.cols_move_to_end.html#parameters",
    "href": "reference/GT.cols_move_to_end.html#parameters",
    "title": "GT.cols_move_to_end",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nrequired"
  },
  {
    "objectID": "reference/GT.cols_move_to_end.html#returns",
    "href": "reference/GT.cols_move_to_end.html#returns",
    "title": "GT.cols_move_to_end",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.cols_move_to_end.html#examples",
    "href": "reference/GT.cols_move_to_end.html#examples",
    "title": "GT.cols_move_to_end",
    "section": "Examples",
    "text": "Examples\nFor this example, we’ll use a portion of the countrypops dataset to create a simple table. Let’s move the year column, which is the middle column, to the end of the column series with the cols_move_to_end() method.\n\nfrom great_tables import GT\nfrom great_tables.data import countrypops\n\ncountrypops_mini = countrypops.loc[countrypops[\"country_name\"] == \"Benin\"][\n    [\"country_name\", \"year\", \"population\"]\n].tail(5)\n\nGT(countrypops_mini).cols_move_to_end(columns=\"year\")\n\n\n\n\n\n\n  country_name\n  population\n  year\n\n\n  \n    Benin\n    11940683\n    2018\n  \n  \n    Benin\n    12290444\n    2019\n  \n  \n    Benin\n    12643123\n    2020\n  \n  \n    Benin\n    12996895\n    2021\n  \n  \n    Benin\n    13352864\n    2022\n  \n\n\n\n\n\n\n        \n\n\nWe can also move multiple columns at a time. With the same countrypops-based table (countrypops_mini), let’s move both the year and country_name columns to the end of the column series.\nGT(countrypops_mini).cols_move_to_end(columns=[“year”, “country_name”])"
  },
  {
    "objectID": "reference/GT.html",
    "href": "reference/GT.html",
    "title": "GT",
    "section": "",
    "text": "GT(self, data, rowname_col=None, groupname_col=None, auto_align=True, id=None, locale=None)\nCreate a Great Tables object.\nThe GT() class creates the GT object when provided with tabular data. Using this class is the the first step in a typical Great Tables workflow. Once we have this object, we can take advantage of numerous methods to get the desired display table for publication.\nThere are a few table structuring options we can consider at this stage. We can choose to create a table stub containing row labels through the use of the rowname_col= argument. Further to this, row groups can be created with the groupname_col= argument. Both arguments take the name of a column in the input table data. Typically, the data in the groupname_col= column will consist of categorical text whereas the data in the rowname_col= column will often contain unique labels (perhaps being unique across the entire table or unique only within the different row groups)."
  },
  {
    "objectID": "reference/GT.html#parameters",
    "href": "reference/GT.html#parameters",
    "title": "GT",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata\nAny\nA DataFrame object.\nrequired\n\n\nrowname_col\nstr | None\nThe column name in the input data= table to use as row labels to be placed in the table stub.\nNone\n\n\ngroupname_col\nstr | None\nThe column name in the input data= table to use as group labels for generation of row groups.\nNone\n\n\nauto_align\nbool\nOptionally have column data be aligned depending on the content contained in each column of the input data=.\nTrue\n\n\nid\nstr | None\nBy default (with None) the table ID will be a random, ten-letter string as generated through internal use of the random_id() function. A custom table ID can be used here by providing a string.\nNone\n\n\nlocale\nstr | None\nAn optional locale identifier that can be set as the default locale for all functions that take a locale argument. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/GT.html#returns",
    "href": "reference/GT.html#returns",
    "title": "GT",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nA GT object is returned."
  },
  {
    "objectID": "reference/GT.html#examples",
    "href": "reference/GT.html#examples",
    "title": "GT",
    "section": "Examples",
    "text": "Examples\nLet’s use the exibble dataset for the next few examples, we’ll learn how to make simple output tables with the GT() class. The most basic thing to do is to just use GT() with the dataset as the input.\n\nfrom great_tables import GT, exibble\n\nGT(exibble)\n\n\n\n\n\n\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n  row\n  group\n\n\n  \n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n    row_1\n    grp_a\n  \n  \n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n    row_2\n    grp_a\n  \n  \n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n    row_3\n    grp_a\n  \n  \n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n    row_4\n    grp_a\n  \n  \n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n    row_5\n    grp_b\n  \n  \n    \n    fig\n    six\n    2015-06-15\n    \n    2018-06-06 16:11\n    13.255\n    row_6\n    grp_b\n  \n  \n    777000.0\n    grapefruit\n    seven\n    \n    19:10\n    2018-07-07 05:22\n    \n    row_7\n    grp_b\n  \n  \n    8880000.0\n    honeydew\n    eight\n    2015-08-15\n    20:20\n    \n    0.44\n    row_8\n    grp_b\n  \n\n\n\n\n\n\n        \n\n\nThis dataset has the row and group columns. The former contains unique values that are ideal for labeling rows, and this often happens in what is called the ‘stub’ (a reserved area that serves to label rows). With the GT() class, we can immediately place the contents of the row column into the stub column. To do this, we use the rowname_col= argument with the appropriate column name.\n\nfrom great_tables import GT, exibble\n\nGT(exibble, rowname_col=\"row\")\n\n\n\n\n\n\n  \n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n  group\n\n\n  \n    row_1\n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n    grp_a\n  \n  \n    row_2\n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n    grp_a\n  \n  \n    row_3\n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n    grp_a\n  \n  \n    row_4\n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n    grp_a\n  \n  \n    row_5\n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n    grp_b\n  \n  \n    row_6\n    \n    fig\n    six\n    2015-06-15\n    \n    2018-06-06 16:11\n    13.255\n    grp_b\n  \n  \n    row_7\n    777000.0\n    grapefruit\n    seven\n    \n    19:10\n    2018-07-07 05:22\n    \n    grp_b\n  \n  \n    row_8\n    8880000.0\n    honeydew\n    eight\n    2015-08-15\n    20:20\n    \n    0.44\n    grp_b\n  \n\n\n\n\n\n\n        \n\n\nThis sets up a table with a stub, the row labels are placed within the stub column, and a vertical dividing line has been placed on the right-hand side.\nThe group column contains categorical values that are ideal for grouping rows. We can use the groupname_col= argument to place these values into row groups.\n\nfrom great_tables import GT, exibble\n\nGT(exibble, rowname_col=\"row\", groupname_col=\"group\")\n\n\n\n\n\n\n  \n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n  \n  \n    row_2\n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n  \n  \n    row_4\n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n  \n  \n    grp_b\n  \n  \n    row_5\n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n  \n  \n    row_6\n    \n    fig\n    six\n    2015-06-15\n    \n    2018-06-06 16:11\n    13.255\n  \n  \n    row_7\n    777000.0\n    grapefruit\n    seven\n    \n    19:10\n    2018-07-07 05:22\n    \n  \n  \n    row_8\n    8880000.0\n    honeydew\n    eight\n    2015-08-15\n    20:20\n    \n    0.44\n  \n\n\n\n\n\n\n        \n\n\nBy default, values in the body of a table (and their column labels) are automatically aligned. The alignment is governed by the types of values in a column. If you’d like to disable this form of auto-alignment, the auto_align=False option can be taken.\n\nfrom great_tables import GT, exibble\n\nGT(exibble, rowname_col=\"row\", auto_align=False)\n\n\n\n\n\n\n  \n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n  group\n\n\n  \n    row_1\n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n    grp_a\n  \n  \n    row_2\n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n    grp_a\n  \n  \n    row_3\n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n    grp_a\n  \n  \n    row_4\n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n    grp_a\n  \n  \n    row_5\n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n    grp_b\n  \n  \n    row_6\n    \n    fig\n    six\n    2015-06-15\n    \n    2018-06-06 16:11\n    13.255\n    grp_b\n  \n  \n    row_7\n    777000.0\n    grapefruit\n    seven\n    \n    19:10\n    2018-07-07 05:22\n    \n    grp_b\n  \n  \n    row_8\n    8880000.0\n    honeydew\n    eight\n    2015-08-15\n    20:20\n    \n    0.44\n    grp_b\n  \n\n\n\n\n\n\n        \n\n\nWhat you’ll get from that is center-alignment of all table body values and all column labels. Note that row labels in the the stub are still left-aligned; and auto_align= has no effect on alignment within the table stub.\nHowever which way you generate the initial table object, you can modify it with a huge variety of methods to further customize the presentation. Formatting body cells is commonly done with the family of formatting methods (e.g., fmt_number(), fmt_date(), etc.). The package supports formatting with internationalization (‘i18n’ features) and so locale-aware methods all come with a locale= argument. To avoid having to use that argument repeatedly, the GT() class has its own locale= argument. Setting a locale in that will make it available globally. Here’s an example of how that works in practice when setting locale = \"fr\" in GT() prior to using formatting methods:\n\nfrom great_tables import GT, exibble\n\n(\n    GT(exibble, rowname_col=\"row\", locale=\"fr\")\n    .fmt_currency(columns=\"currency\")\n    .fmt_scientific(columns=\"num\")\n    .fmt_date(columns=\"date\", date_style=\"day_month_year\")\n)\n\n\n\n\n\n\n  \n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n  group\n\n\n  \n    row_1\n    1.11 × 10−1\n    apricot\n    one\n    15 January 2015\n    13:35\n    2018-01-01 02:22\n    $49.95\n    grp_a\n  \n  \n    row_2\n    2.22\n    banana\n    two\n    15 February 2015\n    14:40\n    2018-02-02 14:33\n    $17.95\n    grp_a\n  \n  \n    row_3\n    3.33 × 101\n    coconut\n    three\n    15 March 2015\n    15:45\n    2018-03-03 03:44\n    $1.39\n    grp_a\n  \n  \n    row_4\n    4.44 × 102\n    durian\n    four\n    15 April 2015\n    16:50\n    2018-04-04 15:55\n    $65,100.00\n    grp_a\n  \n  \n    row_5\n    5.55 × 103\n    \n    five\n    15 May 2015\n    17:55\n    2018-05-05 04:00\n    $1,325.81\n    grp_b\n  \n  \n    row_6\n    \n    fig\n    six\n    15 June 2015\n    \n    2018-06-06 16:11\n    $13.26\n    grp_b\n  \n  \n    row_7\n    7.77 × 105\n    grapefruit\n    seven\n    \n    19:10\n    2018-07-07 05:22\n    \n    grp_b\n  \n  \n    row_8\n    8.88 × 106\n    honeydew\n    eight\n    15 August 2015\n    20:20\n    \n    $0.44\n    grp_b\n  \n\n\n\n\n\n\n        \n\n\nIn this example, the fmt_currency(), fmt_scientific(), and fmt_date() methods understand that the locale for this table is \"fr\" (French), so the appropriate formatting for that locale is apparent in the currency, num, and date columns."
  },
  {
    "objectID": "reference/GT.sub_missing.html",
    "href": "reference/GT.sub_missing.html",
    "title": "GT.sub_missing",
    "section": "",
    "text": "GT.sub_missing(self, columns=None, rows=None, missing_text=None)\nSubstitute missing values in the table body.\nWherever there is missing data (i.e., None values) customizable content may present better than the standard representation of missing values that would otherwise appear. The sub_missing() method allows for this replacement through its missing_text= argument. And by not supplying anything to missing_text=, an em dash will serve as a default indicator of missingness."
  },
  {
    "objectID": "reference/GT.sub_missing.html#parameters",
    "href": "reference/GT.sub_missing.html#parameters",
    "title": "GT.sub_missing",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should be scanned for missing values. The default is all rows, resulting in all rows in all targeted columns being considered for this substitution. Alternatively, we can supply a list of row indices.\nNone\n\n\nmissing_text\nstr | Text | None\nThe text to be used in place of missing values in the rendered table. We can optionally use the md() or html() helper functions to style the text as Markdown or to retain HTML elements in the text.\nNone"
  },
  {
    "objectID": "reference/GT.sub_missing.html#returns",
    "href": "reference/GT.sub_missing.html#returns",
    "title": "GT.sub_missing",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.sub_missing.html#examples",
    "href": "reference/GT.sub_missing.html#examples",
    "title": "GT.sub_missing",
    "section": "Examples",
    "text": "Examples\nUsing a subset of the exibble dataset, let’s create a new table. The missing values in two selections of columns will be given different variations of replacement text (across two separate calls of sub_missing()).\n\nfrom great_tables import GT, md, html, exibble\nimport polars as pl\nimport polars.selectors as cs\n\nexibble_mini = pl.from_pandas(exibble).drop(\"row\", \"group\", \"fctr\").slice(4, 8)\n\n(\n    GT(exibble_mini)\n    .sub_missing(\n        columns=[\"num\", \"char\"],\n        missing_text=\"missing\"\n    )\n    .sub_missing(\n        columns=cs.contains((\"date\", \"time\")) | cs.by_name(\"currency\"),\n        missing_text=\"nothing\"\n    )\n)\n\n\n\n\n\n\n  num\n  char\n  date\n  time\n  datetime\n  currency\n\n\n  \n    5550.0\n    missing\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n  \n  \n    missing\n    fig\n    2015-06-15\n    nothing\n    2018-06-06 16:11\n    13.255\n  \n  \n    777000.0\n    grapefruit\n    nothing\n    19:10\n    2018-07-07 05:22\n    nothing\n  \n  \n    8880000.0\n    honeydew\n    2015-08-15\n    20:20\n    nothing\n    0.44"
  },
  {
    "objectID": "reference/GT.opt_horizontal_padding.html",
    "href": "reference/GT.opt_horizontal_padding.html",
    "title": "GT.opt_horizontal_padding",
    "section": "",
    "text": "GT.opt_horizontal_padding(self, scale=1.0)\nOption to scale the horizontal padding of the table.\nThis method allows us to scale the horizontal padding of the table by a factor of scale. The default value is 1.0 and this method serves as a convenient shortcut for gt.tab_options( heading_padding_horizontal=&lt;new_val&gt;, column_labels_padding_horizontal=&lt;new_val&gt;, data_row_padding_horizontal=&lt;new_val&gt;, row_group_padding_horizontal=&lt;new_val&gt;, source_notes_padding_horizontal=&lt;new_val&gt;)."
  },
  {
    "objectID": "reference/GT.opt_horizontal_padding.html#parameters",
    "href": "reference/GT.opt_horizontal_padding.html#parameters",
    "title": "GT.opt_horizontal_padding",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nscale\nfloat\nThe factor by which to scale the horizontal padding. The default value is 1.0. A value less than 1.0 will reduce the padding, and a value greater than 1.0 will increase the padding. The value must be between 0 and 3.\n1.0"
  },
  {
    "objectID": "reference/GT.opt_horizontal_padding.html#returns",
    "href": "reference/GT.opt_horizontal_padding.html#returns",
    "title": "GT.opt_horizontal_padding",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.opt_horizontal_padding.html#examples",
    "href": "reference/GT.opt_horizontal_padding.html#examples",
    "title": "GT.opt_horizontal_padding",
    "section": "Examples",
    "text": "Examples\nUsing select columns from the exibble dataset, let’s create a table with a number of components added. Following that, we’ll scale the horizontal padding of the table by a factor of 3 using the opt_horizontal_padding() method.\n\nfrom great_tables import GT, exibble, md\n\ngt_tbl = (\n    GT(\n        exibble[[\"num\", \"char\", \"currency\", \"row\", \"group\"]],\n        rowname_col=\"row\",\n        groupname_col=\"group\"\n    )\n    .tab_header(\n        title=md(\"Data listing from **exibble**\"),\n        subtitle=md(\"`exibble` is a **Great Tables** dataset.\")\n    )\n    .fmt_number(columns=\"num\")\n    .fmt_currency(columns=\"currency\")\n    .tab_source_note(source_note=\"This is only a subset of the dataset.\")\n)\n\ngt_tbl.opt_horizontal_padding(scale=3)\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nThe overall effect of scaling the horizontal padding is that the table will appear wider or and there will added buffer space between the table elements. The overall look of the table will be more spacious and neigboring pieces of text will be less cramped.\nLet’s go the other way and scale the horizontal padding of the table by a factor of 0.5 using the opt_horizontal_padding() method.\n\ngt_tbl.opt_horizontal_padding(scale=0.5)\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nWhat you get in this case is more condensed text across the horizontal axis. This may not always be desired when cells consist mainly of text, but it could be useful when the table is more visual and the cells are filled with graphics or other non-textual elements."
  },
  {
    "objectID": "reference/vals.fmt_number.html",
    "href": "reference/vals.fmt_number.html",
    "title": "vals.fmt_number",
    "section": "",
    "text": "vals.fmt_number(x, decimals=2, n_sigfig=None, drop_trailing_zeros=False, drop_trailing_dec_mark=True, use_seps=True, scale_by=1, compact=False, pattern='{x}', sep_mark=',', dec_mark='.', force_sign=False, locale=None)\nFormat numeric values.\nWith numeric values in a list, we can perform number-based formatting so that the values are rendered with some level of precision. The following major options are available:\n\ndecimals: choice of the number of decimal places, option to drop trailing zeros, and a choice of the decimal symbol\ndigit grouping separators: options to enable/disable digit separators and provide a choice of separator symbol\nscaling: we can choose to scale targeted values by a multiplier value\nlarge-number suffixing: larger figures (thousands, millions, etc.) can be autoscaled and decorated with the appropriate suffixes\npattern: option to use a text pattern for decoration of the formatted values\nlocale-based formatting: providing a locale ID will result in number formatting specific to the chosen locale\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\ndecimals\nint\nThe decimals values corresponds to the exact number of decimal places to use. A value such as 2.34 can, for example, be formatted with 0 decimal places and it would result in \"2\". With 4 decimal places, the formatted value becomes \"2.3400\". The trailing zeros can be removed with drop_trailing_zeros=True. If you always need decimals = 0, the val_fmt_integer() function should be considered.\n2\n\n\nn_sigfig\nOptional[int]\nA option to format numbers to n significant figures. By default, this is None and thus number values will be formatted according to the number of decimal places set via decimals. If opting to format according to the rules of significant figures, n_sigfig must be a number greater than or equal to 1. Any values passed to the decimals and drop_trailing_zeros arguments will be ignored.\nNone\n\n\ndrop_trailing_zeros\nbool\nA boolean value that allows for removal of trailing zeros (those redundant zeros after the decimal mark).\nFalse\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\nscale_by\nfloat\nAll numeric values will be multiplied by the scale_by value before undergoing formatting. Since the default value is 1, no values will be changed unless a different multiplier value is supplied.\n1\n\n\ncompact\nbool\nA boolean value that allows for compact formatting of numeric values. Values will be scaled and decorated with the appropriate suffixes (e.g., 1230 becomes 1.23K, and 1230000 becomes 1.23M). The compact option is False by default.\nFalse\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/vals.fmt_number.html#parameters",
    "href": "reference/vals.fmt_number.html#parameters",
    "title": "vals.fmt_number",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\ndecimals\nint\nThe decimals values corresponds to the exact number of decimal places to use. A value such as 2.34 can, for example, be formatted with 0 decimal places and it would result in \"2\". With 4 decimal places, the formatted value becomes \"2.3400\". The trailing zeros can be removed with drop_trailing_zeros=True. If you always need decimals = 0, the val_fmt_integer() function should be considered.\n2\n\n\nn_sigfig\nOptional[int]\nA option to format numbers to n significant figures. By default, this is None and thus number values will be formatted according to the number of decimal places set via decimals. If opting to format according to the rules of significant figures, n_sigfig must be a number greater than or equal to 1. Any values passed to the decimals and drop_trailing_zeros arguments will be ignored.\nNone\n\n\ndrop_trailing_zeros\nbool\nA boolean value that allows for removal of trailing zeros (those redundant zeros after the decimal mark).\nFalse\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\nscale_by\nfloat\nAll numeric values will be multiplied by the scale_by value before undergoing formatting. Since the default value is 1, no values will be changed unless a different multiplier value is supplied.\n1\n\n\ncompact\nbool\nA boolean value that allows for compact formatting of numeric values. Values will be scaled and decorated with the appropriate suffixes (e.g., 1230 becomes 1.23K, and 1230000 becomes 1.23M). The compact option is False by default.\nFalse\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/vals.fmt_number.html#returns",
    "href": "reference/vals.fmt_number.html#returns",
    "title": "vals.fmt_number",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/GT.fmt_roman.html",
    "href": "reference/GT.fmt_roman.html",
    "title": "GT.fmt_roman",
    "section": "",
    "text": "GT.fmt_roman(self, columns=None, rows=None, case='upper', pattern='{x}')\nFormat values as Roman numerals.\nWith numeric values in a gt table we can transform those to Roman numerals, rounding values as necessary."
  },
  {
    "objectID": "reference/GT.fmt_roman.html#parameters",
    "href": "reference/GT.fmt_roman.html#parameters",
    "title": "GT.fmt_roman",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in targeted columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\ncase\nstr\nShould Roman numerals should be rendered as uppercase (\"upper\") or lowercase (\"lower\") letters? By default, this is set to \"upper\".\n'upper'\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'"
  },
  {
    "objectID": "reference/GT.fmt_roman.html#returns",
    "href": "reference/GT.fmt_roman.html#returns",
    "title": "GT.fmt_roman",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.fmt_roman.html#examples",
    "href": "reference/GT.fmt_roman.html#examples",
    "title": "GT.fmt_roman",
    "section": "Examples",
    "text": "Examples\nLet’s first create a DataFrame containing small numeric values and then introduce that to GT(). We’ll then format the roman column to appear as Roman numerals with the fmt_roman() method.\n\nimport pandas as pd\nfrom great_tables import GT\n\nnumbers_tbl = pd.DataFrame({\"arabic\": [1, 8, 24, 85], \"roman\": [1, 8, 24, 85]})\n\n(\n    GT(numbers_tbl, rowname_col=\"arabic\")\n    .fmt_roman(columns=\"roman\")\n)\n\n\n\n\n\n\n  \n  roman\n\n\n  \n    1\n    I\n  \n  \n    8\n    VIII\n  \n  \n    24\n    XXIV\n  \n  \n    85\n    LXXXV"
  },
  {
    "objectID": "reference/GT.fmt_roman.html#see-also",
    "href": "reference/GT.fmt_roman.html#see-also",
    "title": "GT.fmt_roman",
    "section": "See Also",
    "text": "See Also\nThe functional version of this method, val_fmt_roman(), allows you to format a single numerical value (or a list of them)."
  },
  {
    "objectID": "reference/vals.fmt_scientific.html",
    "href": "reference/vals.fmt_scientific.html",
    "title": "vals.fmt_scientific",
    "section": "",
    "text": "vals.fmt_scientific(x, decimals=2, n_sigfig=None, drop_trailing_zeros=False, drop_trailing_dec_mark=True, scale_by=1, exp_style='x10n', pattern='{x}', sep_mark=',', dec_mark='.', force_sign_m=False, force_sign_n=False, locale=None)\nFormat values to scientific notation.\nWith numeric values in a list, we can perform formatting so that the input values are rendered in scientific notation, where extremely large or very small numbers can be expressed in a more practical fashion. Here, numbers are written in the form of a mantissa (m) and an exponent (n) with the construction m x 10^n or mEn. The mantissa component is a number between 1 and 10. For instance, 2.5 x 10^9 can be used to represent the value 2,500,000,000 in scientific notation. In a similar way, 0.00000012 can be expressed as 1.2 x 10^-7. Due to its ability to describe numbers more succinctly and its ease of calculation, scientific notation is widely employed in scientific and technical domains.\nWe have fine control over the formatting task, with the following options:\n\ndecimals: choice of the number of decimal places, option to drop trailing zeros, and a choice of the decimal symbol\nscaling: we can choose to scale targeted values by a multiplier value\npattern: option to use a text pattern for decoration of the formatted values\nlocale-based formatting: providing a locale ID will result in formatting specific to the chosen locale\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\ndecimals\nint\nThe decimals values corresponds to the exact number of decimal places to use. A value such as 2.34 can, for example, be formatted with 0 decimal places and it would result in \"2\". With 4 decimal places, the formatted value becomes \"2.3400\". The trailing zeros can be removed with drop_trailing_zeros=True.\n2\n\n\nn_sigfig\nOptional[int]\nA option to format numbers to n significant figures. By default, this is None and thus number values will be formatted according to the number of decimal places set via decimals. If opting to format according to the rules of significant figures, n_sigfig must be a number greater than or equal to 1. Any values passed to the decimals and drop_trailing_zeros arguments will be ignored.\nNone\n\n\ndrop_trailing_zeros\nbool\nA boolean value that allows for removal of trailing zeros (those redundant zeros after the decimal mark).\nFalse\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nscale_by\nfloat\nAll numeric values will be multiplied by the scale_by value before undergoing formatting. Since the default value is 1, no values will be changed unless a different multiplier value is supplied.\n1\n\n\nexp_style\nstr\nStyle of formatting to use for the scientific notation formatting. By default this is \"x10n\" but other options include using a single letter (e.g., \"e\", \"E\", etc.), a letter followed by a \"1\" to signal a minimum digit width of one, or \"low-ten\" for using a stylized \"10\" marker.\n'x10n'\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign_m\nbool\nShould the plus sign be shown for positive values of the mantissa (first component)? This would effectively show a sign for all values except zero on the first numeric component of the notation. If so, use True (the default for this is False), where only negative numbers will display a sign.\nFalse\n\n\nforce_sign_n\nbool\nShould the plus sign be shown for positive values of the exponent (second component)? This would effectively show a sign for all values except zero on the second numeric component of the notation. If so, use True (the default for this is False), where only negative numbers will display a sign.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/vals.fmt_scientific.html#parameters",
    "href": "reference/vals.fmt_scientific.html#parameters",
    "title": "vals.fmt_scientific",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\ndecimals\nint\nThe decimals values corresponds to the exact number of decimal places to use. A value such as 2.34 can, for example, be formatted with 0 decimal places and it would result in \"2\". With 4 decimal places, the formatted value becomes \"2.3400\". The trailing zeros can be removed with drop_trailing_zeros=True.\n2\n\n\nn_sigfig\nOptional[int]\nA option to format numbers to n significant figures. By default, this is None and thus number values will be formatted according to the number of decimal places set via decimals. If opting to format according to the rules of significant figures, n_sigfig must be a number greater than or equal to 1. Any values passed to the decimals and drop_trailing_zeros arguments will be ignored.\nNone\n\n\ndrop_trailing_zeros\nbool\nA boolean value that allows for removal of trailing zeros (those redundant zeros after the decimal mark).\nFalse\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nscale_by\nfloat\nAll numeric values will be multiplied by the scale_by value before undergoing formatting. Since the default value is 1, no values will be changed unless a different multiplier value is supplied.\n1\n\n\nexp_style\nstr\nStyle of formatting to use for the scientific notation formatting. By default this is \"x10n\" but other options include using a single letter (e.g., \"e\", \"E\", etc.), a letter followed by a \"1\" to signal a minimum digit width of one, or \"low-ten\" for using a stylized \"10\" marker.\n'x10n'\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign_m\nbool\nShould the plus sign be shown for positive values of the mantissa (first component)? This would effectively show a sign for all values except zero on the first numeric component of the notation. If so, use True (the default for this is False), where only negative numbers will display a sign.\nFalse\n\n\nforce_sign_n\nbool\nShould the plus sign be shown for positive values of the exponent (second component)? This would effectively show a sign for all values except zero on the second numeric component of the notation. If so, use True (the default for this is False), where only negative numbers will display a sign.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/vals.fmt_scientific.html#returns",
    "href": "reference/vals.fmt_scientific.html#returns",
    "title": "vals.fmt_scientific",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/system_fonts.html",
    "href": "reference/system_fonts.html",
    "title": "system_fonts",
    "section": "",
    "text": "system_fonts(name='system-ui')\nGet a themed font stack that works well across systems.\nA font stack can be obtained from system_fonts() using one of various keywords such as \"system-ui\", \"old-style\", and \"humanist\" (there are 15 in total) representing a themed set of fonts. These sets comprise a font family that has been tested to work across a wide range of computer systems."
  },
  {
    "objectID": "reference/system_fonts.html#parameters",
    "href": "reference/system_fonts.html#parameters",
    "title": "system_fonts",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nname\nFontStackName\nThe name of a font stack. Must be drawn from the set of \"system-ui\" (the default), \"transitional\", \"old-style\", \"humanist\", \"geometric-humanist\", \"classical-humanist\", \"neo-grotesque\", \"monospace-slab-serif\", \"monospace-code\", \"industrial\", \"rounded-sans\", \"slab-serif\", \"antique\", \"didone\", and \"handwritten\".\n'system-ui'"
  },
  {
    "objectID": "reference/system_fonts.html#returns",
    "href": "reference/system_fonts.html#returns",
    "title": "system_fonts",
    "section": "Returns",
    "text": "Returns\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nList[str]\nA list of font names that make up the font stack."
  },
  {
    "objectID": "reference/system_fonts.html#the-font-stacks-and-the-individual-fonts-used-by-platform",
    "href": "reference/system_fonts.html#the-font-stacks-and-the-individual-fonts-used-by-platform",
    "title": "system_fonts",
    "section": "The Font Stacks And The Individual Fonts Used By Platform",
    "text": "The Font Stacks And The Individual Fonts Used By Platform\n\nSystem UI (\"system-ui\")\nfont-family: system-ui, sans-serif;\nThe operating system interface’s default typefaces are known as system UI fonts. They contain a variety of font weights, are quite readable at small sizes, and are perfect for UI elements. These typefaces serve as a great starting point for text in data tables and so this font stack is the default for Great Tables.\n\n\nTransitional (\"transitional\")\nfont-family: Charter, 'Bitstream Charter', 'Sitka Text', Cambria, serif;\nThe Enlightenment saw the development of transitional typefaces, which combine Old Style and Modern typefaces. Times New Roman, a transitional typeface created for the Times of London newspaper, is among the most well-known instances of this style.\n\n\nOld Style (\"old-style\")\nfont-family: 'Iowan Old Style', 'Palatino Linotype', 'URW Palladio L', P052, serif;\nOld style typefaces were created during the Renaissance and are distinguished by diagonal stress, a lack of contrast between thick and thin strokes, and rounded serifs. Garamond is among the most well-known instances of an antique typeface.\n\n\nHumanist (\"humanist\")\nfont-family: Seravek, 'Gill Sans Nova', Ubuntu, Calibri, 'DejaVu Sans', source-sans-pro, sans-serif;\nLow contrast between thick and thin strokes and organic, calligraphic forms are traits of humanist typefaces. These typefaces, which draw their inspiration from Renaissance calligraphy, are frequently regarded as being more readable and easier to read than other sans serif typefaces.\n\n\nGeometric Humanist (\"geometric-humanist\")\nfont-family: Avenir, Montserrat, Corbel, 'URW Gothic', source-sans-pro, sans-serif;\nClean, geometric forms and consistent stroke widths are characteristics of geometric humanist typefaces. These typefaces, which are frequently used for headlines and other display purposes, are frequently thought to be contemporary and slick in appearance. A well-known example of this classification is Futura.\n\n\nClassical Humanist (\"classical-humanist\")\nfont-family: Optima, Candara, 'Noto Sans', source-sans-pro, sans-serif;\nThe way the strokes gradually widen as they approach the stroke terminals without ending in a serif is what distinguishes classical humanist typefaces. The stone carving on Renaissance-era tombstones and classical Roman capitals served as inspiration for these typefaces.\n\n\nNeo-Grotesque (\"neo-grotesque\")\nfont-family: Inter, Roboto, 'Helvetica Neue', 'Arial Nova', 'Nimbus Sans', Arial, sans-serif;\nNeo-grotesque typefaces are a form of sans serif that originated in the late 19th and early 20th centuries. They are distinguished by their crisp, geometric shapes and regular stroke widths. Helvetica is among the most well-known examples of a Neo-grotesque typeface.\n\n\nMonospace Slab Serif (\"monospace-slab-serif\")\nfont-family: 'Nimbus Mono PS', 'Courier New', monospace;\nMonospace slab serif typefaces are distinguished by their fixed-width letters, which are the same width irrespective of their shape, and their straightforward, geometric forms. For reports, tabular work, and technical documentation, this technique is used to simulate typewriter output.\n\n\nMonospace Code (\"monospace-code\")\nfont-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', Menlo, Consolas, 'DejaVu Sans Mono', monospace;\nSpecifically created for use in programming and other technical applications, monospace code typefaces are used in these fields. These typefaces are distinguished by their clear, readable forms and monospaced design, which ensures that all letters and characters are the same width.\n\n\nIndustrial (\"industrial\")\nfont-family: Bahnschrift, 'DIN Alternate', 'Franklin Gothic Medium', 'Nimbus Sans Narrow', sans-serif-condensed, sans-serif;\nThe development of industrial typefaces began in the late 19th century and was greatly influenced by the industrial and technological advancements of the time. Industrial typefaces are distinguished by their strong sans serif letterforms, straightforward appearance, and use of geometric shapes and straight lines.\n\n\nRounded Sans (\"rounded-sans\")\nfont-family: ui-rounded, 'Hiragino Maru Gothic ProN', Quicksand, Comfortaa, Manjari, 'Arial Rounded MT', 'Arial Rounded MT Bold', Calibri, source-sans-pro, sans-serif;\nThe rounded, curved letterforms that define rounded typefaces give them a softer, friendlier appearance. The typeface’s rounded edges give it a more natural and playful feel, making it appropriate for use in casual or kid-friendly designs. Since the 1950s, the rounded sans-serif design has gained popularity and is still frequently used in branding, graphic design, and other fields.\n\n\nSlab Serif (\"slab-serif\")\nfont-family: Rockwell, 'Rockwell Nova', 'Roboto Slab', 'DejaVu Serif', 'Sitka Small', serif;\nSlab Serif typefaces are distinguished by the thick, block-like serifs that appear at the ends of each letterform. Typically, these serifs are unbracketed, which means that they do not have any curved or tapered transitions to the letter’s main stroke.\n\n\nAntique (\"antique\")\nfont-family: Superclarendon, 'Bookman Old Style', 'URW Bookman', 'URW Bookman L', 'Georgia Pro', Georgia, serif;\nSerif typefaces that were popular in the 19th century include antique typefaces, also referred to as Egyptians. They are distinguished by their thick, uniform stroke weight and block-like serifs. The typeface Clarendon is a highly regarded example of this style and Superclarendon is a modern take on that revered typeface.\n\n\nDidone (\"didone\")\nfont-family: Didot, 'Bodoni MT', 'Noto Serif Display', 'URW Palladio L', P052, Sylfaen, serif;\nDidone typefaces, also referred to as Modern typefaces, are distinguished by their vertical stress, sharp contrast between thick and thin strokes, and hairline serifs without bracketing. The Didone style first appeared in the late 18th century and became well-known in the early 19th century. Bodoni and Didot are two of the most well-known typefaces in this category.\n\n\nHandwritten (\"handwritten\")\nfont-family: 'Segoe Print', 'Bradley Hand', Chilanka, TSCu_Comic, casual, cursive;\nThe appearance and feel of handwriting are replicated by handwritten typefaces. Although there are a wide variety of handwriting styles, this font stack tends to use a more casual and commonplace style. In regards to these types of fonts in tables, one can say that any table having a handwritten font will evoke a feeling of gleefulness."
  },
  {
    "objectID": "reference/system_fonts.html#examples",
    "href": "reference/system_fonts.html#examples",
    "title": "system_fonts",
    "section": "Examples",
    "text": "Examples\nUsing select columns from the exibble dataset, let’s create a table with a number of components added. Following that, we’ll set a font for the entire table using the tab_options() method with the table_font_names parameter. Instead of passing a list of font names, we’ll use the system_fonts() helper function to get a font stack. In this case, we’ll use the \"industrial\" font stack.\n\nfrom great_tables import GT, exibble, md, system_fonts\n\n(\n  GT(\n    exibble[[\"num\", \"char\", \"currency\", \"row\", \"group\"]],\n    rowname_col=\"row\",\n    groupname_col=\"group\"\n  )\n  .tab_header(\n    title=md(\"Data listing from **exibble**\"),\n    subtitle=md(\"`exibble` is a **Great Tables** dataset.\")\n  )\n  .fmt_number(columns=\"num\")\n  .fmt_currency(columns=\"currency\")\n  .tab_source_note(source_note=\"This is only a subset of the dataset.\")\n  .opt_align_table_header(align=\"left\")\n  .tab_options(table_font_names=system_fonts(\"industrial\"))\n)\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nInvoking the system_fonts() helper function with the \"industrial\" argument will return a list of font names that make up the font stack. This is exactly the type of input that the table_font_names parameter requires."
  },
  {
    "objectID": "reference/GT.fmt_datetime.html",
    "href": "reference/GT.fmt_datetime.html",
    "title": "GT.fmt_datetime",
    "section": "",
    "text": "GT.fmt_datetime(self, columns=None, rows=None, date_style='iso', time_style='iso', sep=' ', pattern='{x}', locale=None)\nFormat values as datetimes.\nFormat input values to datetime values using one of 17 preset date styles and one of 5 preset time styles. Input can be in the form of datetime values, or strings in the ISO 8601 forms of YYYY-MM-DD HH:MM:SS or YYYY-MM-DD."
  },
  {
    "objectID": "reference/GT.fmt_datetime.html#parameters",
    "href": "reference/GT.fmt_datetime.html#parameters",
    "title": "GT.fmt_datetime",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in targeted columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\ndate_style\nDateStyle\nThe date style to use. By default this is the short name \"iso\" which corresponds to ISO 8601 date formatting. There are 41 date styles in total and their short names can be viewed using info_date_style().\n'iso'\n\n\ntime_style\nTimeStyle\nThe time style to use. By default this is the short name \"iso\" which corresponds to how times are formatted within ISO 8601 datetime values. There are 5 time styles in total and their short names can be viewed using info_time_style().\n'iso'"
  },
  {
    "objectID": "reference/GT.fmt_datetime.html#formatting-with-the-date_style-and-time_style-arguments",
    "href": "reference/GT.fmt_datetime.html#formatting-with-the-date_style-and-time_style-arguments",
    "title": "GT.fmt_datetime",
    "section": "Formatting With The Date_Style And Time_Style Arguments",
    "text": "Formatting With The Date_Style And Time_Style Arguments\nWe need to supply a preset date style to the date_style argument and a preset time style to the time_style argument. The date styles are numerous and can handle localization to any supported locale. The following table provides a listing of all date styles and their output values (corresponding to an input date of 2000-02-29 14:35:00).\n\n\n\n\nDate Style\nOutput\n\n\n\n\n1\n\"iso\"\n\"2000-02-29\"\n\n\n2\n\"wday_month_day_year\"\n\"Tuesday, February 29, 2000\"\n\n\n3\n\"wd_m_day_year\"\n\"Tue, Feb 29, 2000\"\n\n\n4\n\"wday_day_month_year\"\n\"Tuesday 29 February 2000\"\n\n\n5\n\"month_day_year\"\n\"February 29, 2000\"\n\n\n6\n\"m_day_year\"\n\"Feb 29, 2000\"\n\n\n7\n\"day_m_year\"\n\"29 Feb 2000\"\n\n\n8\n\"day_month_year\"\n\"29 February 2000\"\n\n\n9\n\"day_month\"\n\"29 February\"\n\n\n10\n\"day_m\"\n\"29 Feb\"\n\n\n11\n\"year\"\n\"2000\"\n\n\n12\n\"month\"\n\"February\"\n\n\n13\n\"day\"\n\"29\"\n\n\n14\n\"year.mn.day\"\n\"2000/02/29\"\n\n\n15\n\"y.mn.day\"\n\"00/02/29\"\n\n\n16\n\"year_week\"\n\"2000-W09\"\n\n\n17\n\"year_quarter\"\n\"2000-Q1\"\n\n\n\nThe time styles are numerous and can handle localization to any supported locale. The following table provides a listing of all time styles and their output values (corresponding to an input time of 2000-02-29 14:35:00).\n\n\n\n\nTime Style\nOutput\nNotes\n\n\n\n\n1\n\"iso\"\n\"14:35:00\"\nISO 8601, 24h\n\n\n2\n\"iso-short\"\n\"14:35\"\nISO 8601, 24h\n\n\n3\n\"h_m_s_p\"\n\"2:35:00 PM\"\n12h\n\n\n4\n\"h_m_p\"\n\"2:35 PM\"\n12h\n\n\n5\n\"h_p\"\n\"2 PM\"\n12h\n\n\n\nWe can use the info_date_style() and info_time_style() functions within the console to view similar tables of date and time styles with example output."
  },
  {
    "objectID": "reference/GT.fmt_datetime.html#returns",
    "href": "reference/GT.fmt_datetime.html#returns",
    "title": "GT.fmt_datetime",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.fmt_datetime.html#examples",
    "href": "reference/GT.fmt_datetime.html#examples",
    "title": "GT.fmt_datetime",
    "section": "Examples",
    "text": "Examples\nLet’s use the exibble dataset to create a simple, two-column table (keeping only the date and time columns). With the fmt_datetime() method, we’ll format the date column to display dates formatted with the \"month_day_year\" date style and the time column to display times formatted with the \"h_m_s_p\" time style.\n\nfrom great_tables import GT, exibble\n\nexibble_mini = exibble[[\"date\", \"time\"]]\n\n(\n    GT(exibble_mini)\n    .fmt_datetime(\n        columns=\"date\",\n        date_style=\"month_day_year\",\n        time_style=\"h_m_s_p\"\n    )\n)\n\n\n\n\n\n\n  date\n  time\n\n\n  \n    January 15, 2015 12:00:00 AM\n    13:35\n  \n  \n    February 15, 2015 12:00:00 AM\n    14:40\n  \n  \n    March 15, 2015 12:00:00 AM\n    15:45\n  \n  \n    April 15, 2015 12:00:00 AM\n    16:50\n  \n  \n    May 15, 2015 12:00:00 AM\n    17:55\n  \n  \n    June 15, 2015 12:00:00 AM\n    \n  \n  \n    \n    19:10\n  \n  \n    August 15, 2015 12:00:00 AM\n    20:20"
  },
  {
    "objectID": "reference/vals.fmt_integer.html",
    "href": "reference/vals.fmt_integer.html",
    "title": "vals.fmt_integer",
    "section": "",
    "text": "vals.fmt_integer(x, use_seps=True, scale_by=1, compact=False, pattern='{x}', sep_mark=',', force_sign=False, locale=None)\nFormat values as integers.\nWith numeric values in a list, we can perform number-based formatting so that the input values are always rendered as integer values. The following major options are available:\nWe can have fine control over integer formatting with the following options:\n\ndigit grouping separators: options to enable/disable digit separators and provide a choice of separator symbol\nscaling: we can choose to scale targeted values by a multiplier value\nlarge-number suffixing: larger figures (thousands, millions, etc.) can be autoscaled and decorated with the appropriate suffixes\npattern: option to use a text pattern for decoration of the formatted values\nlocale-based formatting: providing a locale ID will result in number formatting specific to the chosen locale\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\nscale_by\nfloat\nAll numeric values will be multiplied by the scale_by value before undergoing formatting. Since the default value is 1, no values will be changed unless a different multiplier value is supplied.\n1\n\n\ncompact\nbool\nA boolean value that allows for compact formatting of numeric values. Values will be scaled and decorated with the appropriate suffixes (e.g., 1230 becomes 1K, and 1230000 becomes 1M). The compact option is False by default.\nFalse\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/vals.fmt_integer.html#parameters",
    "href": "reference/vals.fmt_integer.html#parameters",
    "title": "vals.fmt_integer",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\nscale_by\nfloat\nAll numeric values will be multiplied by the scale_by value before undergoing formatting. Since the default value is 1, no values will be changed unless a different multiplier value is supplied.\n1\n\n\ncompact\nbool\nA boolean value that allows for compact formatting of numeric values. Values will be scaled and decorated with the appropriate suffixes (e.g., 1230 becomes 1K, and 1230000 becomes 1M). The compact option is False by default.\nFalse\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/vals.fmt_integer.html#returns",
    "href": "reference/vals.fmt_integer.html#returns",
    "title": "vals.fmt_integer",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/html.html",
    "href": "reference/html.html",
    "title": "html",
    "section": "",
    "text": "html(text)\nInterpret input text as HTML-formatted text.\nFor certain pieces of text (like in column labels or table headings) we may want to express them as raw HTML. In fact, with HTML, anything goes so it can be much more than just text. The html() function will guard the input HTML against escaping, so, your HTML tags will come through as HTML when rendered.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntext\nstr\nThe text that is understood to contain HTML formatting.\nrequired\n\n\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nText\nAn instance of the Text class is returned, where the text type is \"html\"."
  },
  {
    "objectID": "reference/html.html#parameters",
    "href": "reference/html.html#parameters",
    "title": "html",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ntext\nstr\nThe text that is understood to contain HTML formatting.\nrequired"
  },
  {
    "objectID": "reference/html.html#returns",
    "href": "reference/html.html#returns",
    "title": "html",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nText\nAn instance of the Text class is returned, where the text type is \"html\"."
  },
  {
    "objectID": "reference/GT.fmt_currency.html",
    "href": "reference/GT.fmt_currency.html",
    "title": "GT.fmt_currency",
    "section": "",
    "text": "GT.fmt_currency(self, columns=None, rows=None, currency=None, use_subunits=True, decimals=None, drop_trailing_dec_mark=True, use_seps=True, scale_by=1, pattern='{x}', sep_mark=',', dec_mark='.', force_sign=False, placement='left', incl_space=False, locale=None)\nFormat values as currencies.\nWith numeric values in a gt table, we can perform currency-based formatting with the fmt_currency() method. This supports both automatic formatting with a three-letter currency code. We have fine control over the conversion from numeric values to currency values, where we could take advantage of the following options:"
  },
  {
    "objectID": "reference/GT.fmt_currency.html#parameters",
    "href": "reference/GT.fmt_currency.html#parameters",
    "title": "GT.fmt_currency",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in targeted columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\ncurrency\nOptional[str]\nThe currency to use for the numeric value. This input can be supplied as a 3-letter currency code (e.g., \"USD\" for U.S. Dollars, \"EUR\" for the Euro currency).\nNone\n\n\nuse_subunits\nbool\nAn option for whether the subunits portion of a currency value should be displayed. For example, with an input value of 273.81, the default formatting will produce \"$273.81\". Removing the subunits (with use_subunits = False) will give us \"$273\".\nTrue\n\n\ndecimals\nOptional[int]\nThe decimals values corresponds to the exact number of decimal places to use. This value is optional as a currency has an intrinsic number of decimal places (i.e., the subunits). A value such as 2.34 can, for example, be formatted with 0 decimal places and if the currency used is \"USD\" it would result in \"$2\". With 4 decimal places, the formatted value becomes \"$2.3400\".\nNone\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\nscale_by\nfloat\nAll numeric values will be multiplied by the scale_by value before undergoing formatting. Since the default value is 1, no values will be changed unless a different multiplier value is supplied.\n1\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nplacement\nstr\nThe placement of the currency symbol. This can be either be \"left\" (as in \"$450\") or \"right\" (which yields \"450$\").\n'left'\n\n\nincl_space\nbool\nAn option for whether to include a space between the value and the currency symbol. The default is to not introduce a space character.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/GT.fmt_currency.html#returns",
    "href": "reference/GT.fmt_currency.html#returns",
    "title": "GT.fmt_currency",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.fmt_currency.html#adapting-output-to-a-specific-locale",
    "href": "reference/GT.fmt_currency.html#adapting-output-to-a-specific-locale",
    "title": "GT.fmt_currency",
    "section": "Adapting Output To A Specific Locale",
    "text": "Adapting Output To A Specific Locale\nThis formatting method can adapt outputs according to a provided locale value. Examples include \"en\" for English (United States) and \"fr\" for French (France). The use of a valid locale ID here means separator and decimal marks will be correct for the given locale. Should any values be provided in sep_mark or dec_mark, they will be overridden by the locale’s preferred values. In addition to number formatting, providing a locale value and not providing a currency allows Great Tables to obtain the currency code from the locale’s territory.\nNote that a locale value provided here will override any global locale setting performed in GT()’s own locale argument (it is settable there as a value received by all other methods that have a locale argument)."
  },
  {
    "objectID": "reference/GT.fmt_currency.html#examples",
    "href": "reference/GT.fmt_currency.html#examples",
    "title": "GT.fmt_currency",
    "section": "Examples",
    "text": "Examples\nLet’s use the exibble dataset to create a table. With the fmt_currency() method, we’ll format the currency column to display monetary values.\n\nfrom great_tables import GT, exibble\n\n(\n    GT(exibble)\n    .fmt_currency(\n        columns=\"currency\",\n        decimals=3,\n        use_seps=False\n    )\n)\n\n\n\n\n\n\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n  row\n  group\n\n\n  \n    0.1111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    $49.950\n    row_1\n    grp_a\n  \n  \n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    $17.950\n    row_2\n    grp_a\n  \n  \n    33.33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    $1.390\n    row_3\n    grp_a\n  \n  \n    444.4\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    $65100.000\n    row_4\n    grp_a\n  \n  \n    5550.0\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    $1325.810\n    row_5\n    grp_b\n  \n  \n    \n    fig\n    six\n    2015-06-15\n    \n    2018-06-06 16:11\n    $13.255\n    row_6\n    grp_b\n  \n  \n    777000.0\n    grapefruit\n    seven\n    \n    19:10\n    2018-07-07 05:22\n    \n    row_7\n    grp_b\n  \n  \n    8880000.0\n    honeydew\n    eight\n    2015-08-15\n    20:20\n    \n    $0.440\n    row_8\n    grp_b"
  },
  {
    "objectID": "reference/GT.fmt_currency.html#see-also",
    "href": "reference/GT.fmt_currency.html#see-also",
    "title": "GT.fmt_currency",
    "section": "See Also",
    "text": "See Also\nThe functional version of this method, val_fmt_currency(), allows you to format a single numerical value (or a list of them)."
  },
  {
    "objectID": "reference/GT.tab_stubhead.html",
    "href": "reference/GT.tab_stubhead.html",
    "title": "GT.tab_stubhead",
    "section": "",
    "text": "GT.tab_stubhead(self, label)\nAdd label text to the stubhead.\nAdd a label to the stubhead of a table. The stubhead is the lone element that is positioned left of the column labels, and above the stub. If a stub does not exist, then there is no stubhead (so no change will be made when using this method in that case). We have the flexibility to use Markdown formatting for the stubhead label (through use of the md() helper function). Furthermore, we can use HTML for the stubhead label so long as we also use the html() helper function."
  },
  {
    "objectID": "reference/GT.tab_stubhead.html#parameters",
    "href": "reference/GT.tab_stubhead.html#parameters",
    "title": "GT.tab_stubhead",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nlabel\nUnion[str, Text]\nThe text to be used as the stubhead label. We can optionally use the md() and html() helper functions to style the text as Markdown or to retain HTML elements in the text.\nrequired"
  },
  {
    "objectID": "reference/GT.tab_stubhead.html#returns",
    "href": "reference/GT.tab_stubhead.html#returns",
    "title": "GT.tab_stubhead",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.tab_stubhead.html#examples",
    "href": "reference/GT.tab_stubhead.html#examples",
    "title": "GT.tab_stubhead",
    "section": "Examples",
    "text": "Examples\nUsing a small subset of the gtcars dataset, we can create a table with row labels. Since we have row labels in the stub (via use of rowname_col=\"model\" in the GT() call) we have a stubhead, so, let’s add a stubhead label (\"car\") with the tab_stubhead() method to describe what’s in the stub.\n\nfrom great_tables import GT\nfrom great_tables.data import gtcars\n\ngtcars_mini = gtcars[[\"model\", \"year\", \"hp\", \"trq\"]].head(5)\n\n(\n    GT(gtcars_mini, rowname_col=\"model\")\n    .tab_stubhead(label=\"car\")\n)\n\n\n\n\n\n\n  car\n  year\n  hp\n  trq\n\n\n  \n    GT\n    2017.0\n    647.0\n    550.0\n  \n  \n    458 Speciale\n    2015.0\n    597.0\n    398.0\n  \n  \n    458 Spider\n    2015.0\n    562.0\n    398.0\n  \n  \n    458 Italia\n    2014.0\n    562.0\n    398.0\n  \n  \n    488 GTB\n    2016.0\n    661.0\n    561.0\n  \n\n\n\n\n\n\n        \n\n\nWe can also use Markdown formatting for the stubhead label. In this example, we’ll use md(\"*Car*\") to make the label italicized.\n\nfrom great_tables import GT, md\nfrom great_tables.data import gtcars\n\n(\n    GT(gtcars_mini, rowname_col=\"model\")\n    .tab_stubhead(label=md(\"*Car*\"))\n)\n\n\n\n\n\n\n  Car\n  year\n  hp\n  trq\n\n\n  \n    GT\n    2017.0\n    647.0\n    550.0\n  \n  \n    458 Speciale\n    2015.0\n    597.0\n    398.0\n  \n  \n    458 Spider\n    2015.0\n    562.0\n    398.0\n  \n  \n    458 Italia\n    2014.0\n    562.0\n    398.0\n  \n  \n    488 GTB\n    2016.0\n    661.0\n    561.0"
  },
  {
    "objectID": "reference/GT.opt_table_outline.html",
    "href": "reference/GT.opt_table_outline.html",
    "title": "GT.opt_table_outline",
    "section": "",
    "text": "GT.opt_table_outline(self, style='solid', width='3px', color='#D3D3D3')\nOption to wrap an outline around the entire table.\nThe opt_table_outline() method puts an outline of consistent style=, width=, and color= around the entire table. It’ll write over any existing outside lines so long as the width= value is larger that of the existing lines. The default value of style= (\"solid\") will draw a solid outline, whereas using \"none\" will remove any present outline.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nstyle\nstr\nThe style of the table outline. The default value is \"solid\". The valid values are \"solid\", \"dashed\", \"dotted\", and \"none\".\n'solid'\n\n\nwidth\nstr\nThe width of the table outline. The default value is \"3px\". The value must be in pixels and it must be an integer value.\n'3px'\n\n\ncolor\nstr\nThe color of the table outline, where the default is \"#D3D3D3\". The value must either a hexadecimal color code or a color name.\n'#D3D3D3'\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.opt_table_outline.html#parameters",
    "href": "reference/GT.opt_table_outline.html#parameters",
    "title": "GT.opt_table_outline",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nstyle\nstr\nThe style of the table outline. The default value is \"solid\". The valid values are \"solid\", \"dashed\", \"dotted\", and \"none\".\n'solid'\n\n\nwidth\nstr\nThe width of the table outline. The default value is \"3px\". The value must be in pixels and it must be an integer value.\n'3px'\n\n\ncolor\nstr\nThe color of the table outline, where the default is \"#D3D3D3\". The value must either a hexadecimal color code or a color name.\n'#D3D3D3'"
  },
  {
    "objectID": "reference/GT.opt_table_outline.html#returns",
    "href": "reference/GT.opt_table_outline.html#returns",
    "title": "GT.opt_table_outline",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.fmt_time.html",
    "href": "reference/GT.fmt_time.html",
    "title": "GT.fmt_time",
    "section": "",
    "text": "GT.fmt_time(self, columns=None, rows=None, time_style='iso', pattern='{x}', locale=None)\nFormat values as times.\nFormat input values to time values using one of 5 preset time styles. Input can be in the form of time values, or strings in the ISO 8601 forms of HH:MM:SS or YYYY-MM-DD HH:MM:SS."
  },
  {
    "objectID": "reference/GT.fmt_time.html#parameters",
    "href": "reference/GT.fmt_time.html#parameters",
    "title": "GT.fmt_time",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in targeted columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\ntime_style\nTimeStyle\nThe time style to use. By default this is the short name \"iso\" which corresponds to how times are formatted within ISO 8601 datetime values. There are 5 time styles in total and their short names can be viewed using info_time_style().\n'iso'\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/GT.fmt_time.html#formatting-with-the-time_style-argument",
    "href": "reference/GT.fmt_time.html#formatting-with-the-time_style-argument",
    "title": "GT.fmt_time",
    "section": "Formatting With The Time_Style Argument",
    "text": "Formatting With The Time_Style Argument\nWe need to supply a preset time style to the time_style argument. The time styles are numerous and can handle localization to any supported locale. The following table provides a listing of all time styles and their output values (corresponding to an input time of 14:35:00).\n\n\n\n\nTime Style\nOutput\nNotes\n\n\n\n\n1\n\"iso\"\n\"14:35:00\"\nISO 8601, 24h\n\n\n2\n\"iso-short\"\n\"14:35\"\nISO 8601, 24h\n\n\n3\n\"h_m_s_p\"\n\"2:35:00 PM\"\n12h\n\n\n4\n\"h_m_p\"\n\"2:35 PM\"\n12h\n\n\n5\n\"h_p\"\n\"2 PM\"\n12h\n\n\n\nWe can use the info_time_style() function within the console to view a similar table of time styles with example output."
  },
  {
    "objectID": "reference/GT.fmt_time.html#returns",
    "href": "reference/GT.fmt_time.html#returns",
    "title": "GT.fmt_time",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.fmt_time.html#adapting-output-to-a-specific-locale",
    "href": "reference/GT.fmt_time.html#adapting-output-to-a-specific-locale",
    "title": "GT.fmt_time",
    "section": "Adapting Output To A Specific Locale",
    "text": "Adapting Output To A Specific Locale\nThis formatting method can adapt outputs according to a provided locale value. Examples include \"en\" for English (United States) and \"fr\" for French (France). Note that a locale value provided here will override any global locale setting performed in GT()’s own locale argument (it is settable there as a value received by all other methods that have a locale argument)."
  },
  {
    "objectID": "reference/GT.fmt_time.html#examples",
    "href": "reference/GT.fmt_time.html#examples",
    "title": "GT.fmt_time",
    "section": "Examples",
    "text": "Examples\nLet’s use the exibble dataset to create a simple, two-column table (keeping only the date and time columns). With the fmt_time() method, we’ll format the time column to display times formatted with the \"h_m_s_p\" time style.\n\nfrom great_tables import GT, exibble\n\nexibble_mini = exibble[[\"date\", \"time\"]]\n\n(\n    GT(exibble_mini)\n    .fmt_time(columns=\"time\", time_style=\"h_m_s_p\")\n)\n\n\n\n\n\n\n  date\n  time\n\n\n  \n    2015-01-15\n    1:35:00 PM\n  \n  \n    2015-02-15\n    2:40:00 PM\n  \n  \n    2015-03-15\n    3:45:00 PM\n  \n  \n    2015-04-15\n    4:50:00 PM\n  \n  \n    2015-05-15\n    5:55:00 PM\n  \n  \n    2015-06-15\n    \n  \n  \n    \n    7:10:00 PM\n  \n  \n    2015-08-15\n    8:20:00 PM"
  },
  {
    "objectID": "reference/GT.fmt_time.html#see-also",
    "href": "reference/GT.fmt_time.html#see-also",
    "title": "GT.fmt_time",
    "section": "See Also",
    "text": "See Also\nThe functional version of this method, val_fmt_time(), allows you to format a single numerical value (or a list of them)."
  },
  {
    "objectID": "reference/vals.fmt_date.html",
    "href": "reference/vals.fmt_date.html",
    "title": "vals.fmt_date",
    "section": "",
    "text": "vals.fmt_date(x, date_style='iso', pattern='{x}', locale=None)\nFormat values as dates.\nFormat input values to time values using one of 17 preset date styles. Input can be in the form of date type or as a ISO-8601 string (in the form of YYYY-MM-DD HH:MM:SS or YYYY-MM-DD).\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\ndate_style\nDateStyle\nThe date style to use. By default this is the short name \"iso\" which corresponds to ISO 8601 date formatting. There are 41 date styles in total and their short names can be viewed using info_date_style().\n'iso'\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone\n\n\n\n\n\n\nWe need to supply a preset date style to the date_style argument. The date styles are numerous and can handle localization to any supported locale. The following table provides a listing of all date styles and their output values (corresponding to an input date of 2000-02-29).\n\n\n\n\nDate Style\nOutput\n\n\n\n\n1\n\"iso\"\n\"2000-02-29\"\n\n\n2\n\"wday_month_day_year\"\n\"Tuesday, February 29, 2000\"\n\n\n3\n\"wd_m_day_year\"\n\"Tue, Feb 29, 2000\"\n\n\n4\n\"wday_day_month_year\"\n\"Tuesday 29 February 2000\"\n\n\n5\n\"month_day_year\"\n\"February 29, 2000\"\n\n\n6\n\"m_day_year\"\n\"Feb 29, 2000\"\n\n\n7\n\"day_m_year\"\n\"29 Feb 2000\"\n\n\n8\n\"day_month_year\"\n\"29 February 2000\"\n\n\n9\n\"day_month\"\n\"29 February\"\n\n\n10\n\"day_m\"\n\"29 Feb\"\n\n\n11\n\"year\"\n\"2000\"\n\n\n12\n\"month\"\n\"February\"\n\n\n13\n\"day\"\n\"29\"\n\n\n14\n\"year.mn.day\"\n\"2000/02/29\"\n\n\n15\n\"y.mn.day\"\n\"00/02/29\"\n\n\n16\n\"year_week\"\n\"2000-W09\"\n\n\n17\n\"year_quarter\"\n\"2000-Q1\"\n\n\n\nWe can use the info_date_style() function within the console to view a similar table of date styles with example output.\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/vals.fmt_date.html#parameters",
    "href": "reference/vals.fmt_date.html#parameters",
    "title": "vals.fmt_date",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\ndate_style\nDateStyle\nThe date style to use. By default this is the short name \"iso\" which corresponds to ISO 8601 date formatting. There are 41 date styles in total and their short names can be viewed using info_date_style().\n'iso'\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/vals.fmt_date.html#formatting-with-the-date_style-argument",
    "href": "reference/vals.fmt_date.html#formatting-with-the-date_style-argument",
    "title": "vals.fmt_date",
    "section": "",
    "text": "We need to supply a preset date style to the date_style argument. The date styles are numerous and can handle localization to any supported locale. The following table provides a listing of all date styles and their output values (corresponding to an input date of 2000-02-29).\n\n\n\n\nDate Style\nOutput\n\n\n\n\n1\n\"iso\"\n\"2000-02-29\"\n\n\n2\n\"wday_month_day_year\"\n\"Tuesday, February 29, 2000\"\n\n\n3\n\"wd_m_day_year\"\n\"Tue, Feb 29, 2000\"\n\n\n4\n\"wday_day_month_year\"\n\"Tuesday 29 February 2000\"\n\n\n5\n\"month_day_year\"\n\"February 29, 2000\"\n\n\n6\n\"m_day_year\"\n\"Feb 29, 2000\"\n\n\n7\n\"day_m_year\"\n\"29 Feb 2000\"\n\n\n8\n\"day_month_year\"\n\"29 February 2000\"\n\n\n9\n\"day_month\"\n\"29 February\"\n\n\n10\n\"day_m\"\n\"29 Feb\"\n\n\n11\n\"year\"\n\"2000\"\n\n\n12\n\"month\"\n\"February\"\n\n\n13\n\"day\"\n\"29\"\n\n\n14\n\"year.mn.day\"\n\"2000/02/29\"\n\n\n15\n\"y.mn.day\"\n\"00/02/29\"\n\n\n16\n\"year_week\"\n\"2000-W09\"\n\n\n17\n\"year_quarter\"\n\"2000-Q1\"\n\n\n\nWe can use the info_date_style() function within the console to view a similar table of date styles with example output."
  },
  {
    "objectID": "reference/vals.fmt_date.html#returns",
    "href": "reference/vals.fmt_date.html#returns",
    "title": "vals.fmt_date",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/GT.tab_options.html",
    "href": "reference/GT.tab_options.html",
    "title": "GT.tab_options",
    "section": "",
    "text": "GT.tab_options(self, container_width=None, container_height=None, container_overflow_x=None, container_overflow_y=None, table_width=None, table_layout=None, table_margin_left=None, table_margin_right=None, table_background_color=None, table_font_names=None, table_font_size=None, table_font_weight=None, table_font_style=None, table_font_color=None, table_font_color_light=None, table_border_top_style=None, table_border_top_width=None, table_border_top_color=None, table_border_bottom_style=None, table_border_bottom_width=None, table_border_bottom_color=None, table_border_left_style=None, table_border_left_width=None, table_border_left_color=None, table_border_right_style=None, table_border_right_width=None, table_border_right_color=None, heading_background_color=None, heading_align=None, heading_title_font_size=None, heading_title_font_weight=None, heading_subtitle_font_size=None, heading_subtitle_font_weight=None, heading_padding=None, heading_padding_horizontal=None, heading_border_bottom_style=None, heading_border_bottom_width=None, heading_border_bottom_color=None, heading_border_lr_style=None, heading_border_lr_width=None, heading_border_lr_color=None, column_labels_background_color=None, column_labels_font_size=None, column_labels_font_weight=None, column_labels_text_transform=None, column_labels_padding=None, column_labels_padding_horizontal=None, column_labels_vlines_style=None, column_labels_vlines_width=None, column_labels_vlines_color=None, column_labels_border_top_style=None, column_labels_border_top_width=None, column_labels_border_top_color=None, column_labels_border_bottom_style=None, column_labels_border_bottom_width=None, column_labels_border_bottom_color=None, column_labels_border_lr_style=None, column_labels_border_lr_width=None, column_labels_border_lr_color=None, column_labels_hidden=None, row_group_background_color=None, row_group_font_size=None, row_group_font_weight=None, row_group_text_transform=None, row_group_padding=None, row_group_padding_horizontal=None, row_group_border_top_style=None, row_group_border_top_width=None, row_group_border_top_color=None, row_group_border_bottom_style=None, row_group_border_bottom_width=None, row_group_border_bottom_color=None, row_group_border_left_style=None, row_group_border_left_width=None, row_group_border_left_color=None, row_group_border_right_style=None, row_group_border_right_width=None, row_group_border_right_color=None, row_group_as_column=None, table_body_hlines_style=None, table_body_hlines_width=None, table_body_hlines_color=None, table_body_vlines_style=None, table_body_vlines_width=None, table_body_vlines_color=None, table_body_border_top_style=None, table_body_border_top_width=None, table_body_border_top_color=None, table_body_border_bottom_style=None, table_body_border_bottom_width=None, table_body_border_bottom_color=None, stub_background_color=None, stub_font_size=None, stub_font_weight=None, stub_text_transform=None, stub_border_style=None, stub_border_width=None, stub_border_color=None, stub_row_group_font_size=None, stub_row_group_font_weight=None, stub_row_group_text_transform=None, stub_row_group_border_style=None, stub_row_group_border_width=None, stub_row_group_border_color=None, data_row_padding=None, data_row_padding_horizontal=None, source_notes_background_color=None, source_notes_font_size=None, source_notes_padding=None, source_notes_padding_horizontal=None, source_notes_border_bottom_style=None, source_notes_border_bottom_width=None, source_notes_border_bottom_color=None, source_notes_border_lr_style=None, source_notes_border_lr_width=None, source_notes_border_lr_color=None, source_notes_multiline=None, source_notes_sep=None)\nModify the table output options.\nModify the options available in a table. These options are named by the components, the subcomponents, and the element that can adjusted."
  },
  {
    "objectID": "reference/GT.tab_options.html#parameters",
    "href": "reference/GT.tab_options.html#parameters",
    "title": "GT.tab_options",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncontainer_width\nOptional[str]\nThe width of the table’s container. Can be specified as a single-length character with units of pixels or as a percentage. If provided as a scalar numeric value, it is assumed that the value is given in units of pixels.\nNone\n\n\ncontainer_height\nOptional[str]\nThe height of the table’s container.\nNone\n\n\ncontainer_overflow_x\nOptional[str]\nAn option to enable scrolling in the horizontal direction when the table content overflows the container dimensions. Using True (the default) means that horizontal scrolling is enabled to view the entire table in those directions. With False, the table may be clipped if the table width or height exceeds the container_width.\nNone\n\n\ncontainer_overflow_y\nOptional[str]\nAn option to enable scrolling in the vertical direction when the table content overflows. Same rules apply as for container_overflow_x; the dependency here is that of the table height (container_height).\nNone\n\n\ntable_width\nOptional[str]\nThe width of the table. Can be specified as a string with units of pixels or as a percentage. If provided as a numeric value, it is assumed that the value is given in units of pixels.\nNone\n\n\ntable_layout\nOptional[str]\nThe value for the table-layout CSS style in the HTML output context. By default, this is \"fixed\" but another valid option is \"auto\".\nNone\n\n\ntable_margin_left\nOptional[str]\nThe size of the margins on the left of the table within the container. Can be specified as a single-length value with units of pixels or as a percentage. If provided as a numeric value, it is assumed that the value is given in units of pixels. Using table_margin_left will overwrite any values set by table_align.\nNone\n\n\ntable_margin_right\nOptional[str]\nThe size of the margins on the right of the table within the container. Same rules apply as for table_margin_left. Using table_margin_right will overwrite any values set by table_align.\nNone\n\n\ntable_background_color\nOptional[str]\nThe background color for the table. A color name or a hexadecimal color code should be provided.\nNone\n\n\ntable_font_names\nOptional[Union[str, List[str]]]\nThe names of the fonts used for the table. This should be provided as a list of font names. If the first font isn’t available, then the next font is tried (and so on).\nNone\n\n\ntable_font_size\nOptional[str]\nThe font size for the table. Can be specified as a string with units of pixels or as a percentage. If provided as a numeric value, it is assumed that the value is given in units of pixels.\nNone\n\n\ntable_font_weight\nOptional[str]\nThe font weight of the table. Can be a text-based keyword such as \"normal\", \"bold\", \"lighter\", \"bolder\", or, a numeric value between 1 and 1000, inclusive. Note that only variable fonts may support the numeric mapping of weight.\nNone\n\n\ntable_font_style\nOptional[str]\nThe font style for the table. Can be one of either \"normal\", \"italic\", or \"oblique\".\nNone\n\n\ntable_font_color\nOptional[str]\nThe text color used throughout the table. A color name or a hexadecimal color code should be provided.\nNone\n\n\ntable_font_color_light\nOptional[str]\nThe text color used throughout the table when the background color is dark. A color name or a hexadecimal color code should be provided.\nNone\n\n\ntable_border_top_style\nOptional[str]\nThe style of the table’s absolute top border. Can be one of either \"solid\", \"dotted\", \"dashed\", \"double\", \"groove\", \"ridge\", \"inset\", or \"outset\".\nNone\n\n\ntable_border_top_width\nOptional[str]\nThe width of the table’s absolute top border. Can be specified as a string with units of pixels or as a percentage. If provided as a numeric value, it is assumed that the value is given in units of pixels.\nNone\n\n\ntable_border_top_color\nOptional[str]\nThe color of the table’s absolute top border. A color name or a hexadecimal color code should be provided.\nNone\n\n\ntable_border_bottom_style\nOptional[str]\nThe style of the table’s absolute bottom border.\nNone\n\n\ntable_border_bottom_width\nOptional[str]\nThe width of the table’s absolute bottom border.\nNone\n\n\ntable_border_bottom_color\nOptional[str]\nThe color of the table’s absolute bottom border.\nNone\n\n\ntable_border_left_style\nOptional[str]\nThe style of the table’s absolute left border.\nNone\n\n\ntable_border_left_width\nOptional[str]\nThe width of the table’s absolute left border.\nNone\n\n\ntable_border_left_color\nOptional[str]\nThe color of the table’s absolute left border.\nNone\n\n\ntable_border_right_style\nOptional[str]\nThe style of the table’s absolute right border.\nNone\n\n\ntable_border_right_width\nOptional[str]\nThe width of the table’s absolute right border.\nNone\n\n\ntable_border_right_color\nOptional[str]\nThe color of the table’s absolute right border.\nNone\n\n\nheading_background_color\nOptional[str]\nThe background color for the heading. A color name or a hexadecimal color code should be provided.\nNone\n\n\nheading_align\nOptional[str]\nControls the horizontal alignment of the heading title and subtitle. We can either use \"center\", \"left\", or \"right\".\nNone\n\n\nheading_title_font_size\nOptional[str]\nThe font size for the heading title element.\nNone\n\n\nheading_title_font_weight\nOptional[str]\nThe font weight of the heading title.\nNone\n\n\nheading_subtitle_font_size\nOptional[str]\nThe font size for the heading subtitle element.\nNone\n\n\nheading_subtitle_font_weight\nOptional[str]\nThe font weight of the heading subtitle.\nNone\n\n\nheading_padding\nOptional[str]\nThe amount of vertical padding to incorporate in the heading (title and subtitle). Can be specified as a string with units of pixels or as a percentage. If provided as a numeric value, it is assumed that the value is given in units of pixels.\nNone\n\n\nheading_padding_horizontal\nOptional[str]\nThe amount of horizontal padding to incorporate in the heading (title and subtitle). Can be specified as a string with units of pixels or as a percentage. If provided as a numeric value, it is assumed that the value is given in units of pixels.\nNone\n\n\nheading_border_bottom_style\nOptional[str]\nThe style of the header’s bottom border.\nNone\n\n\nheading_border_bottom_width\nOptional[str]\nThe width of the header’s bottom border. If the width of this border is larger, then it will be the visible border.\nNone\n\n\nheading_border_bottom_color\nOptional[str]\nThe color of the header’s bottom border.\nNone\n\n\nheading_border_lr_style\nOptional[str]\nThe style of the left and right borders of the heading location.\nNone\n\n\nheading_border_lr_width\nOptional[str]\nThe width of the left and right borders of the heading location. If the width of this border is larger, then it will be the visible border.\nNone\n\n\nheading_border_lr_color\nOptional[str]\nThe color of the left and right borders of the heading location.\nNone\n\n\ncolumn_labels_background_color\nOptional[str]\nThe background color for the column labels. A color name or a hexadecimal color code should be provided.\nNone\n\n\ncolumn_labels_font_size\nOptional[str]\nThe font size to use for all column labels.\nNone\n\n\ncolumn_labels_font_weight\nOptional[str]\nThe font weight of the table’s column labels.\nNone\n\n\ncolumn_labels_text_transform\nOptional[str]\nThe text transformation for the column labels. Either of the \"uppercase\", \"lowercase\", or \"capitalize\" keywords can be used.\nNone\n\n\ncolumn_labels_padding\nOptional[str]\nThe amount of vertical padding to incorporate in the column_labels (this includes the column spanners).\nNone\n\n\ncolumn_labels_padding_horizontal\nOptional[str]\nThe amount of horizontal padding to incorporate in the column_labels (this includes the column spanners).\nNone\n\n\ncolumn_labels_vlines_style\nOptional[str]\nThe style of all vertical lines (‘vlines’) of the column_labels.\nNone\n\n\ncolumn_labels_vlines_width\nOptional[str]\nThe width of all vertical lines (‘vlines’) of the column_labels.\nNone\n\n\ncolumn_labels_vlines_color\nOptional[str]\nThe color of all vertical lines (‘vlines’) of the column_labels.\nNone\n\n\ncolumn_labels_border_top_style\nOptional[str]\nThe style of the top border of the column_labels location.\nNone\n\n\ncolumn_labels_border_top_width\nOptional[str]\nThe width of the top border of the column_labels location. If the width of this border is larger, then it will be the visible border.\nNone\n\n\ncolumn_labels_border_top_color\nOptional[str]\nThe color of the top border of the column_labels location.\nNone\n\n\ncolumn_labels_border_bottom_style\nOptional[str]\nThe style of the bottom border of the column_labels location.\nNone\n\n\ncolumn_labels_border_bottom_width\nOptional[str]\nThe width of the bottom border of the column_labels location. If the width of this border is larger, then it will be the visible border.\nNone\n\n\ncolumn_labels_border_bottom_color\nOptional[str]\nThe color of the bottom border of the column_labels location.\nNone\n\n\ncolumn_labels_border_lr_style\nOptional[str]\nThe style of the left and right borders of the column_labels location.\nNone\n\n\ncolumn_labels_border_lr_width\nOptional[str]\nThe width of the left and right borders of the column_labels location. If the width of this border is larger, then it will be the visible border.\nNone\n\n\ncolumn_labels_border_lr_color\nOptional[str]\nThe color of the left and right borders of the column_labels location.\nNone\n\n\ncolumn_labels_hidden\nOptional[bool]\nAn option to hide the column labels. If providing True then the entire column_labels location won’t be seen and the table header (if present) will collapse downward.\nNone\n\n\nrow_group_background_color\nOptional[str]\nThe background color for the row group labels. A color name or a hexadecimal color code should be provided.\nNone\n\n\nrow_group_font_weight\nOptional[str]\nThe font weight for all row group labels present in the table.\nNone\n\n\nrow_group_font_size\nOptional[str]\nThe font size to use for all row group labels.\nNone\n\n\nrow_group_padding\nOptional[str]\nThe amount of vertical padding to incorporate in the row group labels.\nNone\n\n\nrow_group_border_top_style\nOptional[str]\nThe style of the top border of the row_group location.\nNone\n\n\nrow_group_border_top_width\nOptional[str]\nThe width of the top border of the row_group location. If the width of this border is larger, then it will be the visible border.\nNone\n\n\nrow_group_border_top_color\nOptional[str]\nThe color of the top border of the row_group location.\nNone\n\n\nrow_group_border_bottom_style\nOptional[str]\nThe style of the bottom border of the row_group location.\nNone\n\n\nrow_group_border_bottom_width\nOptional[str]\nThe width of the bottom border of the row_group location. If the width of this border is larger, then it will be the visible border.\nNone\n\n\nrow_group_border_bottom_color\nOptional[str]\nThe color of the bottom border of the row_group location.\nNone\n\n\nrow_group_border_left_style\nOptional[str]\nThe style of the left border of the row_group location.\nNone\n\n\nrow_group_border_left_width\nOptional[str]\nThe width of the left border of the row_group location. If the width of this border is larger, then it will be the visible border.\nNone\n\n\nrow_group_border_left_color\nOptional[str]\nThe color of the left border of the row_group location.\nNone\n\n\nrow_group_border_right_style\nOptional[str]\nThe style of the right border of the row_group location.\nNone\n\n\nrow_group_border_right_width\nOptional[str]\nThe width of the right border of the row_group location. If the width of this border is\nNone\n\n\nrow_group_border_right_color\nOptional[str]\nThe color of the right border of the row_group location.\nNone\n\n\nrow_group_as_column\nOptional[bool]\nAn option to render the row group labels as a column. If True, then the row group labels will be rendered as a column to the left of the table body. If False, then the row group labels will be rendered as a separate row above the grouping of rows.\nNone\n\n\ntable_body_hlines_style\nOptional[str]\nThe style of all horizontal lines (‘hlines’) in the table_body.\nNone\n\n\ntable_body_hlines_width\nOptional[str]\nThe width of all horizontal lines (‘hlines’) in the table_body.\nNone\n\n\ntable_body_hlines_color\nOptional[str]\nThe color of all horizontal lines (‘hlines’) in the table_body.\nNone\n\n\ntable_body_vlines_style\nOptional[str]\nThe style of all vertical lines (‘vlines’) in the table_body.\nNone\n\n\ntable_body_vlines_width\nOptional[str]\nThe width of all vertical lines (‘vlines’) in the table_body.\nNone\n\n\ntable_body_vlines_color\nOptional[str]\nThe color of all vertical lines (‘vlines’) in the table_body.\nNone\n\n\ntable_body_border_top_style\nOptional[str]\nThe style of the top border of the table_body location.\nNone\n\n\ntable_body_border_top_width\nOptional[str]\nThe width of the top border of the table_body location. If the width of this border is larger, then it will be the visible border.\nNone\n\n\ntable_body_border_top_color\nOptional[str]\nThe color of the top border of the table_body location.\nNone\n\n\ntable_body_border_bottom_style\nOptional[str]\nThe style of the bottom border of the table_body location.\nNone\n\n\ntable_body_border_bottom_width\nOptional[str]\nThe width of the bottom border of the table_body location. If the width of this border\nNone\n\n\ntable_body_border_bottom_color\nOptional[str]\nThe color of the bottom border of the table_body location.\nNone\n\n\nstub_background_color\nOptional[str]\nThe background color for the stub. A color name or a hexadecimal color code should be provided.\nNone\n\n\nstub_font_size\nOptional[str]\nThe font size to use for all row labels present in the table stub.\nNone\n\n\nstub_font_weight\nOptional[str]\nThe font weight for all row labels present in the table stub.\nNone\n\n\nstub_text_transform\nOptional[str]\nThe text transformation for the row labels present in the table stub.\nNone\n\n\nstub_border_style\nOptional[str]\nThe style of the vertical border of the table stub.\nNone\n\n\nstub_border_width\nOptional[str]\nThe width of the vertical border of the table stub.\nNone\n\n\nstub_border_color\nOptional[str]\nThe color of the vertical border of the table stub.\nNone\n\n\nstub_row_group_font_size\nOptional[str]\nThe font size for the row group column in the stub.\nNone\n\n\nstub_row_group_font_weight\nOptional[str]\nThe font weight for the row group column in the stub.\nNone\n\n\nstub_row_group_text_transform\nOptional[str]\nThe text transformation for the row group column in the stub.\nNone\n\n\nstub_row_group_border_style\nOptional[str]\nThe style of the vertical border of the row group column in the stub.\nNone\n\n\nstub_row_group_border_width\nOptional[str]\nThe width of the vertical border of the row group column in the stub.\nNone\n\n\nstub_row_group_border_color\nOptional[str]\nThe color of the vertical border of the row group column in the stub.\nNone\n\n\ndata_row_padding\nOptional[str]\nThe amount of vertical padding to incorporate in the body/stub rows.\nNone\n\n\ndata_row_padding_horizontal\nOptional[str]\nThe amount of horizontal padding to incorporate in the body/stub rows.\nNone\n\n\nsource_notes_background_color\nOptional[str]\nThe background color for the source notes. A color name or a hexadecimal color code should be provided.\nNone\n\n\nsource_notes_font_size\nOptional[str]\nThe font size to use for all source note text.\nNone\n\n\nsource_notes_padding\nOptional[str]\nThe amount of vertical padding to incorporate in the source notes.\nNone\n\n\nsource_notes_padding_horizontal\nOptional[str]\nThe amount of horizontal padding to incorporate in the source notes.\nNone\n\n\nsource_notes_multiline\nOptional[bool]\nAn option to either put source notes in separate lines (the default, or True) or render them as a continuous line of text with source_notes_sep providing the separator (by default \" \") between notes.\nNone\n\n\nsource_notes_sep\nOptional[str]\nThe separating characters between adjacent source notes when rendered as a continuous line of text (when source_notes_multiline is False). The default value is a single space character (\" \").\nNone\n\n\nsource_notes_border_bottom_style\nOptional[str]\nThe style of the bottom border of the source_notes location.\nNone\n\n\nsource_notes_border_bottom_width\nOptional[str]\nThe width of the bottom border of the source_notes location. If the width of this border is larger, then it will be the visible border.\nNone\n\n\nsource_notes_border_bottom_color\nOptional[str]\nThe color of the bottom border of the source_notes location.\nNone\n\n\nsource_notes_border_lr_style\nOptional[str]\nThe style of the left and right borders of the source_notes location.\nNone\n\n\nsource_notes_border_lr_width\nOptional[str]\nThe width of the left and right borders of the source_notes location. If the width of this border is larger, then it will be the visible border.\nNone\n\n\nsource_notes_border_lr_color\nOptional[str]\nThe color of the left and right borders of the source_notes location.\nNone"
  },
  {
    "objectID": "reference/GT.tab_options.html#returns",
    "href": "reference/GT.tab_options.html#returns",
    "title": "GT.tab_options",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.tab_options.html#examples",
    "href": "reference/GT.tab_options.html#examples",
    "title": "GT.tab_options",
    "section": "Examples",
    "text": "Examples\nUsing select columns from the exibble dataset, let’s create a new table with a number of table components added. We can use this object going forward to demonstrate some of the features available in the tab_options() method.\n\nfrom great_tables import GT, exibble, md\n\ngt_tbl = (\n  GT(\n    exibble[[\"num\", \"char\", \"currency\", \"row\", \"group\"]],\n    rowname_col=\"row\",\n    groupname_col=\"group\"\n  )\n  .tab_header(\n    title=md(\"Data listing from **exibble**\"),\n    subtitle=md(\"`exibble` is a **Great Tables** dataset.\")\n  )\n  .fmt_number(columns=\"num\")\n  .fmt_currency(columns=\"currency\")\n  .tab_source_note(source_note=\"This is only a subset of the dataset.\")\n)\n\ngt_tbl\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nWe can modify the table width to be set as \"100%“. In effect, this spans the table to entirely fill the content width area. This is done with the table_width option.\n\ngt_tbl.tab_options(table_width=\"100%\")\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nWith the table_background_color option, we can modify the table’s background color. Here, we want that to be \"lightcyan\".\n\ngt_tbl.tab_options(table_background_color=\"lightcyan\")\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nThe data rows of a table typically take up the most physical space but we have some control over the extent of that. With the data_row_padding option, it’s possible to modify the top and bottom padding of data rows. We’ll do just that in the following example, reducing the padding to a value of \"3px\".\n\ngt_tbl.tab_options(data_row_padding=\"3px\")\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nThe size of the title and the subtitle text in the header of the table can be altered with the heading_title_font_size and heading_subtitle_font_size options. Here, we’ll use the \"small\" and \"x-small\" keyword values.\n\ngt_tbl.tab_options(heading_title_font_size=\"small\", heading_subtitle_font_size=\"x-small\")\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset."
  },
  {
    "objectID": "reference/GT.fmt_number.html",
    "href": "reference/GT.fmt_number.html",
    "title": "GT.fmt_number",
    "section": "",
    "text": "GT.fmt_number(self, columns=None, rows=None, decimals=2, n_sigfig=None, drop_trailing_zeros=False, drop_trailing_dec_mark=True, use_seps=True, scale_by=1, compact=False, pattern='{x}', sep_mark=',', dec_mark='.', force_sign=False, locale=None)\nFormat numeric values.\nWith numeric values within a table’s body cells, we can perform number-based formatting so that the targeted values are rendered with a higher consideration for tabular presentation. Furthermore, there is finer control over numeric formatting with the following options:"
  },
  {
    "objectID": "reference/GT.fmt_number.html#parameters",
    "href": "reference/GT.fmt_number.html#parameters",
    "title": "GT.fmt_number",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in targeted columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\ndecimals\nint\nThe decimals values corresponds to the exact number of decimal places to use. A value such as 2.34 can, for example, be formatted with 0 decimal places and it would result in \"2\". With 4 decimal places, the formatted value becomes \"2.3400\". The trailing zeros can be removed with drop_trailing_zeros=True. If you always need decimals = 0, the fmt_integer() method should be considered.\n2\n\n\nn_sigfig\nOptional[int]\nA option to format numbers to n significant figures. By default, this is None and thus number values will be formatted according to the number of decimal places set via decimals. If opting to format according to the rules of significant figures, n_sigfig must be a number greater than or equal to 1. Any values passed to the decimals and drop_trailing_zeros arguments will be ignored.\nNone\n\n\ndrop_trailing_zeros\nbool\nA boolean value that allows for removal of trailing zeros (those redundant zeros after the decimal mark).\nFalse\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\nscale_by\nfloat\nAll numeric values will be multiplied by the scale_by value before undergoing formatting. Since the default value is 1, no values will be changed unless a different multiplier value is supplied.\n1\n\n\ncompact\nbool\nA boolean value that allows for compact formatting of numeric values. Values will be scaled and decorated with the appropriate suffixes (e.g., 1230 becomes 1.23K, and 1230000 becomes 1.23M). The compact option is False by default.\nFalse\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/GT.fmt_number.html#returns",
    "href": "reference/GT.fmt_number.html#returns",
    "title": "GT.fmt_number",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.fmt_number.html#adapting-output-to-a-specific-locale",
    "href": "reference/GT.fmt_number.html#adapting-output-to-a-specific-locale",
    "title": "GT.fmt_number",
    "section": "Adapting Output To A Specific Locale",
    "text": "Adapting Output To A Specific Locale\nThis formatting method can adapt outputs according to a provided locale value. Examples include \"en\" for English (United States) and \"fr\" for French (France). The use of a valid locale ID here means separator and decimal marks will be correct for the given locale. Should any values be provided in sep_mark or dec_mark, they will be overridden by the locale’s preferred values.\nNote that a locale value provided here will override any global locale setting performed in GT()’s own locale argument (it is settable there as a value received by all other methods that have a locale argument)."
  },
  {
    "objectID": "reference/GT.fmt_number.html#examples",
    "href": "reference/GT.fmt_number.html#examples",
    "title": "GT.fmt_number",
    "section": "Examples",
    "text": "Examples\nLet’s use the exibble dataset to create a table. With the fmt_number() method, we’ll format the num column to have three decimal places (with decimals=3) and omit the use of digit separators (with use_seps=False).\n\nfrom great_tables import GT, exibble\n\n(\n    GT(exibble)\n    .fmt_number(columns=\"num\", decimals=3, use_seps=False)\n)\n\n\n\n\n\n\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n  row\n  group\n\n\n  \n    0.111\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n    row_1\n    grp_a\n  \n  \n    2.222\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n    row_2\n    grp_a\n  \n  \n    33.330\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n    row_3\n    grp_a\n  \n  \n    444.400\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n    row_4\n    grp_a\n  \n  \n    5550.000\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n    row_5\n    grp_b\n  \n  \n    nan\n    fig\n    six\n    2015-06-15\n    \n    2018-06-06 16:11\n    13.255\n    row_6\n    grp_b\n  \n  \n    777000.000\n    grapefruit\n    seven\n    \n    19:10\n    2018-07-07 05:22\n    \n    row_7\n    grp_b\n  \n  \n    8880000.000\n    honeydew\n    eight\n    2015-08-15\n    20:20\n    \n    0.44\n    row_8\n    grp_b"
  },
  {
    "objectID": "reference/GT.fmt_number.html#see-also",
    "href": "reference/GT.fmt_number.html#see-also",
    "title": "GT.fmt_number",
    "section": "See Also",
    "text": "See Also\nThe fmt_integer() method might be more useful if you really need to format numeric values to appear as integers (i.e., no decimals will be shown and input values are rounded as necessary). Need to do numeric formatting on a value or list of values? Take a look at the functional version of this method: val_fmt_number()."
  },
  {
    "objectID": "reference/GT.fmt_integer.html",
    "href": "reference/GT.fmt_integer.html",
    "title": "GT.fmt_integer",
    "section": "",
    "text": "GT.fmt_integer(self, columns=None, rows=None, use_seps=True, scale_by=1, compact=False, pattern='{x}', sep_mark=',', force_sign=False, locale=None)\nFormat values as integers.\nWith numeric values in one or more table columns, we can perform number-based formatting so that the targeted values are always rendered as integer values.\nWe can have fine control over integer formatting with the following options:"
  },
  {
    "objectID": "reference/GT.fmt_integer.html#parameters",
    "href": "reference/GT.fmt_integer.html#parameters",
    "title": "GT.fmt_integer",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in targeted columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\nscale_by\nfloat\nAll numeric values will be multiplied by the scale_by value before undergoing formatting. Since the default value is 1, no values will be changed unless a different multiplier value is supplied.\n1\n\n\ncompact\nbool\nA boolean value that allows for compact formatting of numeric values. Values will be scaled and decorated with the appropriate suffixes (e.g., 1230 becomes 1K, and 1230000 becomes 1M). The compact option is False by default.\nFalse\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/GT.fmt_integer.html#returns",
    "href": "reference/GT.fmt_integer.html#returns",
    "title": "GT.fmt_integer",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.fmt_integer.html#adapting-output-to-a-specific-locale",
    "href": "reference/GT.fmt_integer.html#adapting-output-to-a-specific-locale",
    "title": "GT.fmt_integer",
    "section": "Adapting Output To A Specific Locale",
    "text": "Adapting Output To A Specific Locale\nThis formatting method can adapt outputs according to a provided locale value. Examples include \"en\" for English (United States) and \"fr\" for French (France). The use of a valid locale ID here means separator marks will be correct for the given locale. Should any value be provided in sep_mark, it will be overridden by the locale’s preferred value.\nNote that a locale value provided here will override any global locale setting performed in GT()’s own locale argument (it is settable there as a value received by all other methods that have a locale argument)."
  },
  {
    "objectID": "reference/GT.fmt_integer.html#examples",
    "href": "reference/GT.fmt_integer.html#examples",
    "title": "GT.fmt_integer",
    "section": "Examples",
    "text": "Examples\nFor this example, we’ll use the exibble dataset as the input table. With the fmt_integer() method, we’ll format the num column as integer values having no digit separators (with the use_seps=False option).\n\nfrom great_tables import GT, exibble\n\n(\n    GT(exibble)\n    .fmt_integer(columns=\"num\", use_seps=False)\n)\n\n\n\n\n\n\n  num\n  char\n  fctr\n  date\n  time\n  datetime\n  currency\n  row\n  group\n\n\n  \n    0\n    apricot\n    one\n    2015-01-15\n    13:35\n    2018-01-01 02:22\n    49.95\n    row_1\n    grp_a\n  \n  \n    2\n    banana\n    two\n    2015-02-15\n    14:40\n    2018-02-02 14:33\n    17.95\n    row_2\n    grp_a\n  \n  \n    33\n    coconut\n    three\n    2015-03-15\n    15:45\n    2018-03-03 03:44\n    1.39\n    row_3\n    grp_a\n  \n  \n    444\n    durian\n    four\n    2015-04-15\n    16:50\n    2018-04-04 15:55\n    65100.0\n    row_4\n    grp_a\n  \n  \n    5550\n    \n    five\n    2015-05-15\n    17:55\n    2018-05-05 04:00\n    1325.81\n    row_5\n    grp_b\n  \n  \n    \n    fig\n    six\n    2015-06-15\n    \n    2018-06-06 16:11\n    13.255\n    row_6\n    grp_b\n  \n  \n    777000\n    grapefruit\n    seven\n    \n    19:10\n    2018-07-07 05:22\n    \n    row_7\n    grp_b\n  \n  \n    8880000\n    honeydew\n    eight\n    2015-08-15\n    20:20\n    \n    0.44\n    row_8\n    grp_b"
  },
  {
    "objectID": "reference/GT.fmt_integer.html#see-also",
    "href": "reference/GT.fmt_integer.html#see-also",
    "title": "GT.fmt_integer",
    "section": "See Also",
    "text": "See Also\nThe fmt_number() method might be more of what you need if you’d like decimal values in your outputs. Need to do integer-based formatting on a value or list of values? Take a look at the functional version of this method: val_fmt_integer()."
  },
  {
    "objectID": "reference/GT.opt_vertical_padding.html",
    "href": "reference/GT.opt_vertical_padding.html",
    "title": "GT.opt_vertical_padding",
    "section": "",
    "text": "GT.opt_vertical_padding(self, scale=1.0)\nOption to scale the vertical padding of the table.\nThis method allows us to scale the vertical padding of the table by a factor of scale. The default value is 1.0 and this method serves as a convenient shortcut for gt.tab_options(heading_padding=&lt;new_val&gt;, column_labels_padding=&lt;new_val&gt;, data_row_padding=&lt;new_val&gt;, row_group_padding=&lt;new_val&gt;, source_notes_padding=&lt;new_val&gt;)."
  },
  {
    "objectID": "reference/GT.opt_vertical_padding.html#parameters",
    "href": "reference/GT.opt_vertical_padding.html#parameters",
    "title": "GT.opt_vertical_padding",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nscale\nfloat\nThe factor by which to scale the vertical padding. The default value is 1.0. A value less than 1.0 will reduce the padding, and a value greater than 1.0 will increase the padding. The value must be between 0 and 3.\n1.0"
  },
  {
    "objectID": "reference/GT.opt_vertical_padding.html#returns",
    "href": "reference/GT.opt_vertical_padding.html#returns",
    "title": "GT.opt_vertical_padding",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.opt_vertical_padding.html#examples",
    "href": "reference/GT.opt_vertical_padding.html#examples",
    "title": "GT.opt_vertical_padding",
    "section": "Examples",
    "text": "Examples\nUsing select columns from the exibble dataset, let’s create a table with a number of components added. Following that, we’ll scale the vertical padding of the table by a factor of 3 using the opt_vertical_padding() method.\n\nfrom great_tables import GT, exibble, md\n\ngt_tbl = (\n    GT(\n        exibble[[\"num\", \"char\", \"currency\", \"row\", \"group\"]],\n        rowname_col=\"row\",\n        groupname_col=\"group\"\n    )\n    .tab_header(\n        title=md(\"Data listing from **exibble**\"),\n        subtitle=md(\"`exibble` is a **Great Tables** dataset.\")\n    )\n    .fmt_number(columns=\"num\")\n    .fmt_currency(columns=\"currency\")\n    .tab_source_note(source_note=\"This is only a subset of the dataset.\")\n)\n\ngt_tbl.opt_vertical_padding(scale=3)\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nNow that’s a tall table! The overall effect of scaling the vertical padding is that the table will appear taller and there will be more buffer space between the table elements. A value of 3 is pretty extreme and is likely to be too much in most cases, so, feel free to experiment with different values when looking to increase the vertical padding.\nLet’s go the other way (using a value less than 1) and try to condense the content vertically with a scale factor of 0.5. This will reduce the top and bottom padding globally and make the table appear more compact.\n\ngt_tbl.opt_vertical_padding(scale=0.5)\n\n\n\n\n\n  \n    Data listing from exibble\n  \n  \n    exibble is a Great Tables dataset.\n  \n\n\n  \n  num\n  char\n  currency\n\n\n  \n    grp_a\n  \n  \n    row_1\n    0.11\n    apricot\n    $49.95\n  \n  \n    row_2\n    2.22\n    banana\n    $17.95\n  \n  \n    row_3\n    33.33\n    coconut\n    $1.39\n  \n  \n    row_4\n    444.40\n    durian\n    $65,100.00\n  \n  \n    grp_b\n  \n  \n    row_5\n    5,550.00\n    \n    $1,325.81\n  \n  \n    row_6\n    nan\n    fig\n    $13.26\n  \n  \n    row_7\n    777,000.00\n    grapefruit\n    \n  \n  \n    row_8\n    8,880,000.00\n    honeydew\n    $0.44\n  \n\n  \n  \n  \n    This is only a subset of the dataset.\n  \n\n\n\n\n\n\n        \n\n\nA value of 0.5 provides a reasonable amount of vertical padding and the table will appear more compact. This is useful when space is limited and, in such a situation, this is a practical solution to that problem."
  },
  {
    "objectID": "reference/nanoplot_options.html",
    "href": "reference/nanoplot_options.html",
    "title": "nanoplot_options",
    "section": "",
    "text": "nanoplot_options(data_point_radius=None, data_point_stroke_color=None, data_point_stroke_width=None, data_point_fill_color=None, data_line_type=None, data_line_stroke_color=None, data_line_stroke_width=None, data_area_fill_color=None, data_bar_stroke_color=None, data_bar_stroke_width=None, data_bar_fill_color=None, data_bar_negative_stroke_color=None, data_bar_negative_stroke_width=None, data_bar_negative_fill_color=None, reference_line_color=None, reference_area_fill_color=None, vertical_guide_stroke_color=None, vertical_guide_stroke_width=None, show_data_points=None, show_data_line=None, show_data_area=None, show_reference_line=None, show_reference_area=None, show_vertical_guides=None, show_y_axis_guide=None, interactive_data_values=None, y_val_fmt_fn=None, y_axis_fmt_fn=None, y_ref_line_fmt_fn=None, currency=None)\nHelper for setting the options for a nanoplot.\nWhen using cols_nanoplot(), the defaults for the generated nanoplots can be modified with nanoplot_options() within the options= argument.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ndata_point_radius\nOptional[Union[int, List[int]]]\nThe data_point_radius= option lets you set the radius for each of the data points. By default this is set to 10. Individual radius values can be set by using a list of numeric values; however, the list provided must match the number of data points.\nNone\n\n\ndata_point_stroke_color\nOptional[Union[str, List[str]]]\nThe default stroke color of the data points is \"#FFFFFF\" (\"white\"). This works well when there is a visible data line combined with data points with a darker fill color. The stroke color can be modified with data_point_stroke_color= for all data points by supplying a single color value. With a list of colors, each data point’s stroke color can be changed (ensure that the list length matches the number of data points).\nNone\n\n\ndata_point_stroke_width\nOptional[Union[int, List[int]]]\nThe width of the outside stroke for the data points can be modified with the data_point_stroke_width= option. By default, a value of 4 (as in ‘4px’) is used.\nNone\n\n\ndata_point_fill_color\nOptional[Union[str, List[str]]]\nBy default, all data points have a fill color of \"#FF0000\" (\"red\"). This can be changed for all data points by providing a different color to data_point_fill_color=. And, a list of different colors can be supplied so long as the length is equal to the number of data points; the fill color values will be applied in order of left to right.\nNone\n\n\ndata_line_type\nOptional[str]\nThis can accept either \"curved\" or \"straight\". Curved lines are recommended when the nanoplot has less than 30 points and data points are evenly spaced. In most other cases, straight lines might present better.\nNone\n\n\ndata_line_stroke_color\nOptional[str]\nThe color of the data line can be modified from its default \"#4682B4\" (\"steelblue\") color by supplying a color to the data_line_stroke_color= option.\nNone\n\n\ndata_line_stroke_width\nOptional[int]\nThe width of the connecting data line can be modified with data_line_stroke_width=. By default, a value of 4 (as in ‘4px’) is used.\nNone\n\n\ndata_area_fill_color\nOptional[str]\nThe fill color for the area that bounds the data points in line plot. The default is \"#FF0000\" (\"red\") but can be changed by providing a color value to data_area_fill_color=.\nNone\n\n\ndata_bar_stroke_color\nOptional[Union[str, List[str]]]\nThe color of the stroke used for the data bars can be modified from its default \"#3290CC\" color by supplying a color to data_bar_stroke_color=.\nNone\n\n\ndata_bar_stroke_width\nOptional[Union[int, List[int]]]\nThe width of the stroke used for the data bars can be modified with the data_bar_stroke_width= option. By default, a value of 4 (as in ‘4px’) is used.\nNone\n\n\ndata_bar_fill_color\nOptional[Union[str, List[str]]]\nBy default, all data bars have a fill color of \"#3FB5FF\". This can be changed for all data bars by providing a different color to data_bar_fill_color=. And, a list of different colors can be supplied so long as the length is equal to the number of data bars; the fill color values will be applied in order of left to right.\nNone\n\n\ndata_bar_negative_stroke_color\nOptional[str]\nThe color of the stroke used for the data bars that have negative values. The default color is \"#CC3243\" but this can be changed by supplying a color value to the data_bar_negative_stroke_color= option.\nNone\n\n\ndata_bar_negative_stroke_width\nOptional[int]\nThe width of the stroke used for negative value data bars. This has the same default as data_bar_stroke_width= with a value of 4 (as in ‘4px’). This can be changed by giving a numeric value to the data_bar_negative_stroke_width= option.\nNone\n\n\ndata_bar_negative_fill_color\nOptional[str]\nBy default, all negative data bars have a fill color of \"#D75A68\". This can however be changed by providing a color value to data_bar_negative_fill_color=.\nNone\n\n\nreference_line_color\nOptional[str]\nThe reference line will have a color of \"#75A8B0\" if it is set to appear. This color can be changed by providing a single color value to reference_line_color=.\nNone\n\n\nreference_area_fill_color\nOptional[str]\nIf a reference area has been defined and is visible it has by default a fill color of \"#A6E6F2\". This can be modified by declaring a color value in the reference_area_fill_color= option.\nNone\n\n\nvertical_guide_stroke_color\nOptional[str]\nVertical guides appear when hovering in the vicinity of data points. Their default color is \"#911EB4\" (a strong magenta color) and a fill opacity value of 0.4 is automatically applied to this. However, the base color can be changed with the vertical_guide_stroke_color= option.\nNone\n\n\nvertical_guide_stroke_width\nOptional[int]\nThe vertical guide’s stroke width, by default, is relatively large at 12 (this is ‘12px’). This is modifiable by setting a different value with vertical_guide_stroke_width=.\nNone\n\n\nshow_data_points\nOptional[bool]\nBy default, all data points in a nanoplot are shown but this layer can be hidden by setting show_data_points= to False.\nNone\n\n\nshow_data_line\nOptional[bool]\nThe data line connects data points together and it is shown by default. This data line layer can be hidden by setting show_data_line= to False.\nNone\n\n\nshow_data_area\nOptional[bool]\nThe data area layer is adjacent to the data points and the data line. It is shown by default but can be hidden with show_data_area=False.\nNone\n\n\nshow_reference_line\nOptional[bool]\nThe layer with a horizontal reference line appears underneath that of the data points and the data line. Like vertical guides, hovering over a reference will show its value. The reference line (if available) is shown by default but can be hidden by setting show_reference_line= to False.\nNone\n\n\nshow_reference_area\nOptional[bool]\nThe reference area appears at the very bottom of the layer stack, if it is available (i.e., defined in cols_nanoplot()). It will be shown in the default case but can be hidden by using show_reference_area=False.\nNone\n\n\nshow_vertical_guides\nOptional[bool]\nVertical guides appear when hovering over data points. This hidden layer is active by default but can be deactivated by using show_vertical_guides=False.\nNone\n\n\nshow_y_axis_guide\nOptional[bool]\nThe y-axis guide will appear when hovering over the far left side of a nanoplot. This hidden layer is active by default but can be deactivated by using show_y_axis_guide=False.\nNone\n\n\ninteractive_data_values\nOptional[bool]\nBy default, numeric data values will be shown only when the user interacts with certain regions of a nanoplot. This is because the values may be numerous (i.e., clutter the display when all are visible) and it can be argued that the values themselves are secondary to the presentation. However, for some types of plots (like horizontal bar plots), a persistent display of values alongside the plot marks may be desirable. By setting interactive_data_values=False we can opt for always displaying the data values alongside the plot components.\nNone\n\n\ny_val_fmt_fn\nOptional[Callable[…, str]]\nIf providing a function to y_val_fmt_fn=, customized formatting of the y values associated with the data points/bars is possible.\nNone\n\n\ny_axis_fmt_fn\nOptional[Callable[…, str]]\nA function supplied to y_axis_fmt_fn= will result in customized formatting of the y-axis label values.\nNone\n\n\ny_ref_line_fmt_fn\nOptional[Callable[…, str]]\nProviding a function for y_ref_line_fmt_fn= yields customized formatting of the reference line (if present).\nNone\n\n\ncurrency\nOptional[str]\nIf the values are to be displayed as currency values, supply either: (1) a 3-letter currency code (e.g., \"USD\" for U.S. Dollars, \"EUR\" for the Euro currency), or (2) a common currency name (e.g., \"dollar\", \"pound\", \"yen\", etc.).\nNone"
  },
  {
    "objectID": "reference/nanoplot_options.html#parameters",
    "href": "reference/nanoplot_options.html#parameters",
    "title": "nanoplot_options",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ndata_point_radius\nOptional[Union[int, List[int]]]\nThe data_point_radius= option lets you set the radius for each of the data points. By default this is set to 10. Individual radius values can be set by using a list of numeric values; however, the list provided must match the number of data points.\nNone\n\n\ndata_point_stroke_color\nOptional[Union[str, List[str]]]\nThe default stroke color of the data points is \"#FFFFFF\" (\"white\"). This works well when there is a visible data line combined with data points with a darker fill color. The stroke color can be modified with data_point_stroke_color= for all data points by supplying a single color value. With a list of colors, each data point’s stroke color can be changed (ensure that the list length matches the number of data points).\nNone\n\n\ndata_point_stroke_width\nOptional[Union[int, List[int]]]\nThe width of the outside stroke for the data points can be modified with the data_point_stroke_width= option. By default, a value of 4 (as in ‘4px’) is used.\nNone\n\n\ndata_point_fill_color\nOptional[Union[str, List[str]]]\nBy default, all data points have a fill color of \"#FF0000\" (\"red\"). This can be changed for all data points by providing a different color to data_point_fill_color=. And, a list of different colors can be supplied so long as the length is equal to the number of data points; the fill color values will be applied in order of left to right.\nNone\n\n\ndata_line_type\nOptional[str]\nThis can accept either \"curved\" or \"straight\". Curved lines are recommended when the nanoplot has less than 30 points and data points are evenly spaced. In most other cases, straight lines might present better.\nNone\n\n\ndata_line_stroke_color\nOptional[str]\nThe color of the data line can be modified from its default \"#4682B4\" (\"steelblue\") color by supplying a color to the data_line_stroke_color= option.\nNone\n\n\ndata_line_stroke_width\nOptional[int]\nThe width of the connecting data line can be modified with data_line_stroke_width=. By default, a value of 4 (as in ‘4px’) is used.\nNone\n\n\ndata_area_fill_color\nOptional[str]\nThe fill color for the area that bounds the data points in line plot. The default is \"#FF0000\" (\"red\") but can be changed by providing a color value to data_area_fill_color=.\nNone\n\n\ndata_bar_stroke_color\nOptional[Union[str, List[str]]]\nThe color of the stroke used for the data bars can be modified from its default \"#3290CC\" color by supplying a color to data_bar_stroke_color=.\nNone\n\n\ndata_bar_stroke_width\nOptional[Union[int, List[int]]]\nThe width of the stroke used for the data bars can be modified with the data_bar_stroke_width= option. By default, a value of 4 (as in ‘4px’) is used.\nNone\n\n\ndata_bar_fill_color\nOptional[Union[str, List[str]]]\nBy default, all data bars have a fill color of \"#3FB5FF\". This can be changed for all data bars by providing a different color to data_bar_fill_color=. And, a list of different colors can be supplied so long as the length is equal to the number of data bars; the fill color values will be applied in order of left to right.\nNone\n\n\ndata_bar_negative_stroke_color\nOptional[str]\nThe color of the stroke used for the data bars that have negative values. The default color is \"#CC3243\" but this can be changed by supplying a color value to the data_bar_negative_stroke_color= option.\nNone\n\n\ndata_bar_negative_stroke_width\nOptional[int]\nThe width of the stroke used for negative value data bars. This has the same default as data_bar_stroke_width= with a value of 4 (as in ‘4px’). This can be changed by giving a numeric value to the data_bar_negative_stroke_width= option.\nNone\n\n\ndata_bar_negative_fill_color\nOptional[str]\nBy default, all negative data bars have a fill color of \"#D75A68\". This can however be changed by providing a color value to data_bar_negative_fill_color=.\nNone\n\n\nreference_line_color\nOptional[str]\nThe reference line will have a color of \"#75A8B0\" if it is set to appear. This color can be changed by providing a single color value to reference_line_color=.\nNone\n\n\nreference_area_fill_color\nOptional[str]\nIf a reference area has been defined and is visible it has by default a fill color of \"#A6E6F2\". This can be modified by declaring a color value in the reference_area_fill_color= option.\nNone\n\n\nvertical_guide_stroke_color\nOptional[str]\nVertical guides appear when hovering in the vicinity of data points. Their default color is \"#911EB4\" (a strong magenta color) and a fill opacity value of 0.4 is automatically applied to this. However, the base color can be changed with the vertical_guide_stroke_color= option.\nNone\n\n\nvertical_guide_stroke_width\nOptional[int]\nThe vertical guide’s stroke width, by default, is relatively large at 12 (this is ‘12px’). This is modifiable by setting a different value with vertical_guide_stroke_width=.\nNone\n\n\nshow_data_points\nOptional[bool]\nBy default, all data points in a nanoplot are shown but this layer can be hidden by setting show_data_points= to False.\nNone\n\n\nshow_data_line\nOptional[bool]\nThe data line connects data points together and it is shown by default. This data line layer can be hidden by setting show_data_line= to False.\nNone\n\n\nshow_data_area\nOptional[bool]\nThe data area layer is adjacent to the data points and the data line. It is shown by default but can be hidden with show_data_area=False.\nNone\n\n\nshow_reference_line\nOptional[bool]\nThe layer with a horizontal reference line appears underneath that of the data points and the data line. Like vertical guides, hovering over a reference will show its value. The reference line (if available) is shown by default but can be hidden by setting show_reference_line= to False.\nNone\n\n\nshow_reference_area\nOptional[bool]\nThe reference area appears at the very bottom of the layer stack, if it is available (i.e., defined in cols_nanoplot()). It will be shown in the default case but can be hidden by using show_reference_area=False.\nNone\n\n\nshow_vertical_guides\nOptional[bool]\nVertical guides appear when hovering over data points. This hidden layer is active by default but can be deactivated by using show_vertical_guides=False.\nNone\n\n\nshow_y_axis_guide\nOptional[bool]\nThe y-axis guide will appear when hovering over the far left side of a nanoplot. This hidden layer is active by default but can be deactivated by using show_y_axis_guide=False.\nNone\n\n\ninteractive_data_values\nOptional[bool]\nBy default, numeric data values will be shown only when the user interacts with certain regions of a nanoplot. This is because the values may be numerous (i.e., clutter the display when all are visible) and it can be argued that the values themselves are secondary to the presentation. However, for some types of plots (like horizontal bar plots), a persistent display of values alongside the plot marks may be desirable. By setting interactive_data_values=False we can opt for always displaying the data values alongside the plot components.\nNone\n\n\ny_val_fmt_fn\nOptional[Callable[…, str]]\nIf providing a function to y_val_fmt_fn=, customized formatting of the y values associated with the data points/bars is possible.\nNone\n\n\ny_axis_fmt_fn\nOptional[Callable[…, str]]\nA function supplied to y_axis_fmt_fn= will result in customized formatting of the y-axis label values.\nNone\n\n\ny_ref_line_fmt_fn\nOptional[Callable[…, str]]\nProviding a function for y_ref_line_fmt_fn= yields customized formatting of the reference line (if present).\nNone\n\n\ncurrency\nOptional[str]\nIf the values are to be displayed as currency values, supply either: (1) a 3-letter currency code (e.g., \"USD\" for U.S. Dollars, \"EUR\" for the Euro currency), or (2) a common currency name (e.g., \"dollar\", \"pound\", \"yen\", etc.).\nNone"
  },
  {
    "objectID": "reference/GT.fmt_bytes.html",
    "href": "reference/GT.fmt_bytes.html",
    "title": "GT.fmt_bytes",
    "section": "",
    "text": "GT.fmt_bytes(self, columns=None, rows=None, standard='decimal', decimals=1, n_sigfig=None, drop_trailing_zeros=True, drop_trailing_dec_mark=True, use_seps=True, pattern='{x}', sep_mark=',', dec_mark='.', force_sign=False, incl_space=True, locale=None)\nFormat values as bytes.\nWith numeric values in a table, we can transform those to values of bytes with human readable units. The fmt_bytes() method allows for the formatting of byte sizes to either of two common representations: (1) with decimal units (powers of 1000, examples being \"kB\" and \"MB\"), and (2) with binary units (powers of 1024, examples being \"KiB\" and \"MiB\"). It is assumed the input numeric values represent the number of bytes and automatic truncation of values will occur. The numeric values will be scaled to be in the range of 1 to &lt;1000 and then decorated with the correct unit symbol according to the standard chosen. For more control over the formatting of byte sizes, we can use the following options:"
  },
  {
    "objectID": "reference/GT.fmt_bytes.html#parameters",
    "href": "reference/GT.fmt_bytes.html#parameters",
    "title": "GT.fmt_bytes",
    "section": "Parameters",
    "text": "Parameters\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolumns\nSelectExpr\nThe columns to target. Can either be a single column name or a series of column names provided in a list.\nNone\n\n\nrows\nUnion[int, List[int], None]\nIn conjunction with columns=, we can specify which of their rows should undergo formatting. The default is all rows, resulting in all rows in targeted columns being formatted. Alternatively, we can supply a list of row indices.\nNone\n\n\nstandard\nstr\nThe form of expressing large byte sizes is divided between: (1) decimal units (powers of 1000; e.g., \"kB\" and \"MB\"), and (2) binary units (powers of 1024; e.g., \"KiB\" and \"MiB\"). The default is to use decimal units with the \"decimal\" option. The alternative is to use binary units with the \"binary\" option.\n'decimal'\n\n\ndecimals\nint\nThis corresponds to the exact number of decimal places to use. A value such as 2.34 can, for example, be formatted with 0 decimal places and it would result in \"2\". With 4 decimal places, the formatted value becomes \"2.3400\". The trailing zeros can be removed with drop_trailing_zeros=True.\n1\n\n\ndrop_trailing_zeros\nbool\nA boolean value that allows for removal of trailing zeros (those redundant zeros after the decimal mark).\nTrue\n\n\ndrop_trailing_dec_mark\nbool\nA boolean value that determines whether decimal marks should always appear even if there are no decimal digits to display after formatting (e.g., 23 becomes 23. if False). By default trailing decimal marks are not shown.\nTrue\n\n\nuse_seps\nbool\nThe use_seps option allows for the use of digit group separators. The type of digit group separator is set by sep_mark and overridden if a locale ID is provided to locale. This setting is True by default.\nTrue\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nsep_mark\nstr\nThe string to use as a separator between groups of digits. For example, using sep_mark=\",\" with a value of 1000 would result in a formatted value of \"1,000\". This argument is ignored if a locale is supplied (i.e., is not None).\n','\n\n\ndec_mark\nstr\nThe string to be used as the decimal mark. For example, using dec_mark=\",\" with the value 0.152 would result in a formatted value of \"0,152\"). This argument is ignored if a locale is supplied (i.e., is not None).\n'.'\n\n\nforce_sign\nbool\nShould the positive sign be shown for positive values (effectively showing a sign for all values except zero)? If so, use True for this option. The default is False, where only negative numbers will display a minus sign. This option is disregarded when using accounting notation with accounting = True.\nFalse\n\n\nincl_space\nbool\nAn option for whether to include a space between the value and the currency symbol. The default is to not introduce a space character.\nTrue\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/GT.fmt_bytes.html#returns",
    "href": "reference/GT.fmt_bytes.html#returns",
    "title": "GT.fmt_bytes",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.fmt_bytes.html#adapting-output-to-a-specific-locale",
    "href": "reference/GT.fmt_bytes.html#adapting-output-to-a-specific-locale",
    "title": "GT.fmt_bytes",
    "section": "Adapting Output To A Specific Locale",
    "text": "Adapting Output To A Specific Locale\nThis formatting method can adapt outputs according to a provided locale value. Examples include \"en\" for English (United States) and \"fr\" for French (France). The use of a valid locale ID here means separator and decimal marks will be correct for the given locale. Should any values be provided in sep_mark or dec_mark, they will be overridden by the locale’s preferred values.\nNote that a locale value provided here will override any global locale setting performed in GT()’s own locale argument (it is settable there as a value received by all other methods that have a locale argument)."
  },
  {
    "objectID": "reference/GT.fmt_bytes.html#examples",
    "href": "reference/GT.fmt_bytes.html#examples",
    "title": "GT.fmt_bytes",
    "section": "Examples",
    "text": "Examples\nLet’s use a single column from the exibble dataset and create a new table. We’ll format the num column to display as byte sizes in the decimal standard through use of the fmt_bytes() method.\n\nfrom great_tables import GT, exibble\n\n(\n    GT(exibble[[\"num\"]])\n    .fmt_bytes(columns=\"num\", standard=\"decimal\")\n)\n\n\n\n\n\n\n  num\n\n\n  \n    0 B\n  \n  \n    2 B\n  \n  \n    33 B\n  \n  \n    444 B\n  \n  \n    5.5 kB\n  \n  \n    \n  \n  \n    777 kB\n  \n  \n    8.9 MB"
  },
  {
    "objectID": "reference/GT.fmt_bytes.html#see-also",
    "href": "reference/GT.fmt_bytes.html#see-also",
    "title": "GT.fmt_bytes",
    "section": "See Also",
    "text": "See Also\nThe functional version of this method, val_fmt_bytes(), allows you to format a single numerical value (or a list of them)."
  },
  {
    "objectID": "reference/index.html",
    "href": "reference/index.html",
    "title": "API Reference",
    "section": "",
    "text": "All tables created in Great Tables begin by using GT(). With this class, we supply the input data table and some basic options for creating a stub and row groups (with the rowname_col= and groupname_col= arguments).\n\n\n\nGT\nCreate a Great Tables object.\n\n\n\n\n\n\nA table can contain a few useful components for conveying additional information. These include a header (with a titles and subtitle), a footer (with source notes), and additional areas for labels (row group labels, column spanner labels, the stubhead label). We can perform styling on targeted table locations with the tab_style() method.\n\n\n\nGT.tab_header\nAdd a table header.\n\n\nGT.tab_spanner\nInsert a spanner above a selection of column headings.\n\n\nGT.tab_stubhead\nAdd label text to the stubhead.\n\n\nGT.tab_source_note\nAdd a source note citation.\n\n\nGT.tab_style\nAdd custom style to one or more cells\n\n\nGT.tab_options\nModify the table output options.\n\n\n\n\n\n\nColumns of data can be formatted with the fmt_*() methods. We can specify the rows of these columns quite precisely with the rows argument. We get to apply these methods exactly once to each data cell (last call wins). Need to do custom formatting? Use the fmt() method and define your own formatter.\n\n\n\nGT.fmt_number\nFormat numeric values.\n\n\nGT.fmt_integer\nFormat values as integers.\n\n\nGT.fmt_percent\nFormat values as a percentage.\n\n\nGT.fmt_scientific\nFormat values to scientific notation.\n\n\nGT.fmt_currency\nFormat values as currencies.\n\n\nGT.fmt_bytes\nFormat values as bytes.\n\n\nGT.fmt_roman\nFormat values as Roman numerals.\n\n\nGT.fmt_date\nFormat values as dates.\n\n\nGT.fmt_time\nFormat values as times.\n\n\nGT.fmt_datetime\nFormat values as datetimes.\n\n\nGT.fmt_markdown\nFormat Markdown text.\n\n\nGT.fmt_image\nFormat image paths to generate images in cells.\n\n\nGT.fmt_nanoplot\nFormat data for nanoplot visualizations.\n\n\nGT.fmt\nSet a column format with a formatter function.\n\n\nGT.data_color\nPerform data cell colorization.\n\n\nGT.sub_missing\nSubstitute missing values in the table body.\n\n\nGT.sub_zero\nSubstitute zero values in the table body.\n\n\n\n\n\n\nThe cols_*() methods allow for modifications that act on entire columns. This includes alignment of the data in columns (cols_align()), hiding columns from view (cols_hide()), re-labeling the column labels (cols_label()), and moving columns around (with the cols_move*() methods).\n\n\n\nGT.cols_align\nSet the alignment of one or more columns.\n\n\nGT.cols_width\nSet the widths of columns.\n\n\nGT.cols_label\nRelabel one or more columns.\n\n\nGT.cols_move\nMove one or more columns.\n\n\nGT.cols_move_to_start\nMove one or more columns to the start.\n\n\nGT.cols_move_to_end\nMove one or more columns to the end.\n\n\nGT.cols_hide\nHide one or more columns.\n\n\n\n\n\n\nLocation targeting is a powerful feature of Great Tables. It allows for the precise selection of table locations for styling (using the tab_style() method). The styling classes allow for the specification of the styling properties to be applied to the targeted locations.\n\n\n\nloc.body\nA location specification for targeting data cells in the table body.\n\n\nstyle.fill\nA style specification for the background fill of targeted cells.\n\n\nstyle.text\nA style specification for cell text.\n\n\nstyle.borders\nA style specification for cell borders.\n\n\n\n\n\n\nAn assortment of helper functions is available in the Great Tables package. The md() and html() helper functions can used during label creation with the tab_header(), tab_spanner(), tab_stubhead(), and tab_source_note() methods.\n\n\n\nmd\nInterpret input text as Markdown-formatted text.\n\n\nhtml\nInterpret input text as HTML-formatted text.\n\n\nfrom_column\nSpecify that a style value should be fetched from a column in the data.\n\n\nsystem_fonts\nGet a themed font stack that works well across systems.\n\n\nnanoplot_options\nHelper for setting the options for a nanoplot.\n\n\n\n\n\n\nWith the opt_*() functions, we have an easy way to set commonly-used table options without having to use tab_options() directly.\n\n\n\nGT.opt_align_table_header\nOption to align the table header.\n\n\nGT.opt_all_caps\nOption to use all caps in select table locations.\n\n\nGT.opt_vertical_padding\nOption to scale the vertical padding of the table.\n\n\nGT.opt_horizontal_padding\nOption to scale the horizontal padding of the table.\n\n\nGT.opt_table_outline\nOption to wrap an outline around the entire table.\n\n\nGT.opt_stylize\nStylize your table with a colorful look.\n\n\n\n\n\n\nThere may come a day when you need to export a table to some specific format. A great method for that is save(), which allows us to save the table as a standalone image file. You can also get the table code as an HTML fragment with the as_raw_html() method.\n\n\n\nGT.save\nSave a table as an image file or a PDF document.\n\n\nGT.as_raw_html\nGet the HTML content of a GT object.\n\n\n\n\n\n\nIf you have single values (or lists of them) in need of formatting, we have a set of val_fmt_*() functions that have been adapted from the corresponding fmt_*() methods.\n\n\n\nvals.fmt_number\nFormat numeric values.\n\n\nvals.fmt_integer\nFormat values as integers.\n\n\nvals.fmt_scientific\nFormat values to scientific notation.\n\n\nvals.fmt_percent\nFormat values as a percentage.\n\n\nvals.fmt_currency\nFormat values as currencies.\n\n\nvals.fmt_roman\nFormat values as Roman numerals.\n\n\nvals.fmt_bytes\nFormat values as bytes.\n\n\nvals.fmt_date\nFormat values as dates.\n\n\nvals.fmt_time\nFormat values as times.\n\n\nvals.fmt_markdown\nFormat Markdown text.\n\n\n\n\n\n\nThe Great Tables package is equipped with ten datasets that come in all shapes and sizes. Many examples thoughout the help docs use these datasets to quickly demonstrate the awesome features of the package!\n\n\n\ndata.countrypops\nYearly populations of countries from 1960 to 2022.\n\n\ndata.sza\nTwice hourly solar zenith angles by month & latitude.\n\n\ndata.gtcars\nDeluxe automobiles from the 2014-2017 period.\n\n\ndata.sp500\nDaily S&P 500 Index data from 1950 to 2015.\n\n\ndata.pizzaplace\nA year of pizza sales from a pizza place.\n\n\ndata.exibble\nA toy example table for testing with great_tables: exibble.\n\n\ndata.towny\nPopulations of all municipalities in Ontario from 1996 to 2021.\n\n\ndata.metro\nThe stations of the Paris Metro.\n\n\ndata.constants\nThe fundamental physical constants.\n\n\ndata.illness\nLab tests for one suffering from an illness."
  },
  {
    "objectID": "reference/index.html#table-creation",
    "href": "reference/index.html#table-creation",
    "title": "API Reference",
    "section": "",
    "text": "All tables created in Great Tables begin by using GT(). With this class, we supply the input data table and some basic options for creating a stub and row groups (with the rowname_col= and groupname_col= arguments).\n\n\n\nGT\nCreate a Great Tables object."
  },
  {
    "objectID": "reference/index.html#creating-or-modifying-parts-of-a-table",
    "href": "reference/index.html#creating-or-modifying-parts-of-a-table",
    "title": "API Reference",
    "section": "",
    "text": "A table can contain a few useful components for conveying additional information. These include a header (with a titles and subtitle), a footer (with source notes), and additional areas for labels (row group labels, column spanner labels, the stubhead label). We can perform styling on targeted table locations with the tab_style() method.\n\n\n\nGT.tab_header\nAdd a table header.\n\n\nGT.tab_spanner\nInsert a spanner above a selection of column headings.\n\n\nGT.tab_stubhead\nAdd label text to the stubhead.\n\n\nGT.tab_source_note\nAdd a source note citation.\n\n\nGT.tab_style\nAdd custom style to one or more cells\n\n\nGT.tab_options\nModify the table output options."
  },
  {
    "objectID": "reference/index.html#formatting-column-data",
    "href": "reference/index.html#formatting-column-data",
    "title": "API Reference",
    "section": "",
    "text": "Columns of data can be formatted with the fmt_*() methods. We can specify the rows of these columns quite precisely with the rows argument. We get to apply these methods exactly once to each data cell (last call wins). Need to do custom formatting? Use the fmt() method and define your own formatter.\n\n\n\nGT.fmt_number\nFormat numeric values.\n\n\nGT.fmt_integer\nFormat values as integers.\n\n\nGT.fmt_percent\nFormat values as a percentage.\n\n\nGT.fmt_scientific\nFormat values to scientific notation.\n\n\nGT.fmt_currency\nFormat values as currencies.\n\n\nGT.fmt_bytes\nFormat values as bytes.\n\n\nGT.fmt_roman\nFormat values as Roman numerals.\n\n\nGT.fmt_date\nFormat values as dates.\n\n\nGT.fmt_time\nFormat values as times.\n\n\nGT.fmt_datetime\nFormat values as datetimes.\n\n\nGT.fmt_markdown\nFormat Markdown text.\n\n\nGT.fmt_image\nFormat image paths to generate images in cells.\n\n\nGT.fmt_nanoplot\nFormat data for nanoplot visualizations.\n\n\nGT.fmt\nSet a column format with a formatter function.\n\n\nGT.data_color\nPerform data cell colorization.\n\n\nGT.sub_missing\nSubstitute missing values in the table body.\n\n\nGT.sub_zero\nSubstitute zero values in the table body."
  },
  {
    "objectID": "reference/index.html#modifying-columns",
    "href": "reference/index.html#modifying-columns",
    "title": "API Reference",
    "section": "",
    "text": "The cols_*() methods allow for modifications that act on entire columns. This includes alignment of the data in columns (cols_align()), hiding columns from view (cols_hide()), re-labeling the column labels (cols_label()), and moving columns around (with the cols_move*() methods).\n\n\n\nGT.cols_align\nSet the alignment of one or more columns.\n\n\nGT.cols_width\nSet the widths of columns.\n\n\nGT.cols_label\nRelabel one or more columns.\n\n\nGT.cols_move\nMove one or more columns.\n\n\nGT.cols_move_to_start\nMove one or more columns to the start.\n\n\nGT.cols_move_to_end\nMove one or more columns to the end.\n\n\nGT.cols_hide\nHide one or more columns."
  },
  {
    "objectID": "reference/index.html#location-targeting-and-styling-classes",
    "href": "reference/index.html#location-targeting-and-styling-classes",
    "title": "API Reference",
    "section": "",
    "text": "Location targeting is a powerful feature of Great Tables. It allows for the precise selection of table locations for styling (using the tab_style() method). The styling classes allow for the specification of the styling properties to be applied to the targeted locations.\n\n\n\nloc.body\nA location specification for targeting data cells in the table body.\n\n\nstyle.fill\nA style specification for the background fill of targeted cells.\n\n\nstyle.text\nA style specification for cell text.\n\n\nstyle.borders\nA style specification for cell borders."
  },
  {
    "objectID": "reference/index.html#helper-functions",
    "href": "reference/index.html#helper-functions",
    "title": "API Reference",
    "section": "",
    "text": "An assortment of helper functions is available in the Great Tables package. The md() and html() helper functions can used during label creation with the tab_header(), tab_spanner(), tab_stubhead(), and tab_source_note() methods.\n\n\n\nmd\nInterpret input text as Markdown-formatted text.\n\n\nhtml\nInterpret input text as HTML-formatted text.\n\n\nfrom_column\nSpecify that a style value should be fetched from a column in the data.\n\n\nsystem_fonts\nGet a themed font stack that works well across systems.\n\n\nnanoplot_options\nHelper for setting the options for a nanoplot."
  },
  {
    "objectID": "reference/index.html#table-options",
    "href": "reference/index.html#table-options",
    "title": "API Reference",
    "section": "",
    "text": "With the opt_*() functions, we have an easy way to set commonly-used table options without having to use tab_options() directly.\n\n\n\nGT.opt_align_table_header\nOption to align the table header.\n\n\nGT.opt_all_caps\nOption to use all caps in select table locations.\n\n\nGT.opt_vertical_padding\nOption to scale the vertical padding of the table.\n\n\nGT.opt_horizontal_padding\nOption to scale the horizontal padding of the table.\n\n\nGT.opt_table_outline\nOption to wrap an outline around the entire table.\n\n\nGT.opt_stylize\nStylize your table with a colorful look."
  },
  {
    "objectID": "reference/index.html#export",
    "href": "reference/index.html#export",
    "title": "API Reference",
    "section": "",
    "text": "There may come a day when you need to export a table to some specific format. A great method for that is save(), which allows us to save the table as a standalone image file. You can also get the table code as an HTML fragment with the as_raw_html() method.\n\n\n\nGT.save\nSave a table as an image file or a PDF document.\n\n\nGT.as_raw_html\nGet the HTML content of a GT object."
  },
  {
    "objectID": "reference/index.html#value-formatting-functions",
    "href": "reference/index.html#value-formatting-functions",
    "title": "API Reference",
    "section": "",
    "text": "If you have single values (or lists of them) in need of formatting, we have a set of val_fmt_*() functions that have been adapted from the corresponding fmt_*() methods.\n\n\n\nvals.fmt_number\nFormat numeric values.\n\n\nvals.fmt_integer\nFormat values as integers.\n\n\nvals.fmt_scientific\nFormat values to scientific notation.\n\n\nvals.fmt_percent\nFormat values as a percentage.\n\n\nvals.fmt_currency\nFormat values as currencies.\n\n\nvals.fmt_roman\nFormat values as Roman numerals.\n\n\nvals.fmt_bytes\nFormat values as bytes.\n\n\nvals.fmt_date\nFormat values as dates.\n\n\nvals.fmt_time\nFormat values as times.\n\n\nvals.fmt_markdown\nFormat Markdown text."
  },
  {
    "objectID": "reference/index.html#built-in-datasets",
    "href": "reference/index.html#built-in-datasets",
    "title": "API Reference",
    "section": "",
    "text": "The Great Tables package is equipped with ten datasets that come in all shapes and sizes. Many examples thoughout the help docs use these datasets to quickly demonstrate the awesome features of the package!\n\n\n\ndata.countrypops\nYearly populations of countries from 1960 to 2022.\n\n\ndata.sza\nTwice hourly solar zenith angles by month & latitude.\n\n\ndata.gtcars\nDeluxe automobiles from the 2014-2017 period.\n\n\ndata.sp500\nDaily S&P 500 Index data from 1950 to 2015.\n\n\ndata.pizzaplace\nA year of pizza sales from a pizza place.\n\n\ndata.exibble\nA toy example table for testing with great_tables: exibble.\n\n\ndata.towny\nPopulations of all municipalities in Ontario from 1996 to 2021.\n\n\ndata.metro\nThe stations of the Paris Metro.\n\n\ndata.constants\nThe fundamental physical constants.\n\n\ndata.illness\nLab tests for one suffering from an illness."
  },
  {
    "objectID": "reference/data.illness.html",
    "href": "reference/data.illness.html",
    "title": "data.illness",
    "section": "",
    "text": "data.illness\nLab tests for one suffering from an illness.\nA dataset with artificial daily lab data for a patient with Yellow Fever (YF). The table comprises laboratory findings for the patient from day 3 of illness onset until day 9 (after which the patient died). YF viral DNA was found in serum samples from day 3, where the viral load reached 14,000 copies per mL. Several medical interventions were taken to help the patient, including the administration of fresh frozen plasma, platelets, red cells, and coagulation factor VIII. The patient also received advanced support treatment in the form of mechanical ventilation and plasmapheresis. Though the patient’s temperature remained stable during their illness, unfortunately, the patient’s condition did not improve. On days 7 and 8, the patient’s health declined further, with symptoms such as nosebleeds, gastrointestinal bleeding, and hematoma.\nThe various tests are identified in the test column. The following listing provides the full names of any abbreviations seen in that column.\n\n\"WBC\": white blood cells.\n\"RBC\": red blood cells.\n\"Hb\": hemoglobin.\n\"PLT\": platelets.\n\"ALT\": alanine aminotransferase.\n\"AST\": aspartate aminotransferase.\n\"TBIL\": total bilirubin.\n\"DBIL\": direct bilirubin.\n\"NH3\": hydrogen nitride.\n\"PT\": prothrombin time.\n\"APTT\": activated partial thromboplastin time.\n\"PTA\": prothrombin time activity.\n\"DD\": D-dimer.\n\"FDP\": fibrinogen degradation products.\n\"LDH\": lactate dehydrogenase.\n\"HBDH\": hydroxybutyrate dehydrogenase.\n\"CK\": creatine kinase.\n\"CKMB\": the MB fraction of creatine kinase.\n\"BNP\": B-type natriuetic peptide.\n\"MYO\": myohemoglobin.\n\"TnI\": troponin inhibitory.\n\"CREA\": creatinine.\n\"BUN\": blood urea nitrogen.\n\"AMY\": amylase.\n\"LPS\": lipase.\n\"K\": kalium.\n\"Na\": sodium.\n\"Cl\": chlorine.\n\"Ca\": calcium.\n\"P\": phosphorus.\n\"Lac\": lactate, blood.\n\"CRP\": c-reactive protein.\n\"PCT\": procalcitonin.\n\"IL-6\": interleukin-6.\n\"CD3+CD4+\": CD4+T lymphocytes.\n\"CD3+CD8+\": CD8+T lymphocytes.\n\n\n\nThis is a dataset with 39 rows and 11 columns.\n\ntest: The name of the test.\nunits: The measurement units for the test.\nday_3, day_4, day_5, day_6, day_7, day_8, day_9: Measurement values associated with each test administered from days 3 to 9. A missing value indicates that the test could not be performed that day.\nnorm_l, norm_u: Lower and upper bounds for the normal range associated with the test."
  },
  {
    "objectID": "reference/data.illness.html#details",
    "href": "reference/data.illness.html#details",
    "title": "data.illness",
    "section": "",
    "text": "This is a dataset with 39 rows and 11 columns.\n\ntest: The name of the test.\nunits: The measurement units for the test.\nday_3, day_4, day_5, day_6, day_7, day_8, day_9: Measurement values associated with each test administered from days 3 to 9. A missing value indicates that the test could not be performed that day.\nnorm_l, norm_u: Lower and upper bounds for the normal range associated with the test."
  },
  {
    "objectID": "reference/vals.fmt_time.html",
    "href": "reference/vals.fmt_time.html",
    "title": "vals.fmt_time",
    "section": "",
    "text": "vals.fmt_time(x, time_style='iso', pattern='{x}', locale=None)\nFormat values as times.\nFormat input values to time values using one of 5 preset time styles. Input can be in the form of time values, or strings in the ISO 8601 forms of HH:MM:SS or YYYY-MM-DD HH:MM:SS.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\ntime_style\nTimeStyle\nThe time style to use. By default this is the short name \"iso\" which corresponds to how times are formatted within ISO 8601 datetime values. There are 5 time styles in total and their short names can be viewed using info_time_style().\n'iso'\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone\n\n\n\n\n\n\nWe need to supply a preset time style to the time_style argument. The time styles are numerous and can handle localization to any supported locale. The following table provides a listing of all time styles and their output values (corresponding to an input time of 14:35:00).\n\n\n\n\nTime Style\nOutput\nNotes\n\n\n\n\n1\n\"iso\"\n\"14:35:00\"\nISO 8601, 24h\n\n\n2\n\"iso-short\"\n\"14:35\"\nISO 8601, 24h\n\n\n3\n\"h_m_s_p\"\n\"2:35:00 PM\"\n12h\n\n\n4\n\"h_m_p\"\n\"2:35 PM\"\n12h\n\n\n5\n\"h_p\"\n\"2 PM\"\n12h\n\n\n\nWe can use the info_time_style() function within the console to view a similar table of time styles with example output.\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/vals.fmt_time.html#parameters",
    "href": "reference/vals.fmt_time.html#parameters",
    "title": "vals.fmt_time",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nx\nUnion[Any, List[Any], SeriesLike]\nA list of values to be formatted.\nrequired\n\n\ntime_style\nTimeStyle\nThe time style to use. By default this is the short name \"iso\" which corresponds to how times are formatted within ISO 8601 datetime values. There are 5 time styles in total and their short names can be viewed using info_time_style().\n'iso'\n\n\npattern\nstr\nA formatting pattern that allows for decoration of the formatted value. The formatted value is represented by the {x} (which can be used multiple times, if needed) and all other characters will be interpreted as string literals.\n'{x}'\n\n\nlocale\nUnion[str, None]\nAn optional locale identifier that can be used for formatting values according the locale’s rules. Examples include \"en\" for English (United States) and \"fr\" for French (France).\nNone"
  },
  {
    "objectID": "reference/vals.fmt_time.html#formatting-with-the-time_style-argument",
    "href": "reference/vals.fmt_time.html#formatting-with-the-time_style-argument",
    "title": "vals.fmt_time",
    "section": "",
    "text": "We need to supply a preset time style to the time_style argument. The time styles are numerous and can handle localization to any supported locale. The following table provides a listing of all time styles and their output values (corresponding to an input time of 14:35:00).\n\n\n\n\nTime Style\nOutput\nNotes\n\n\n\n\n1\n\"iso\"\n\"14:35:00\"\nISO 8601, 24h\n\n\n2\n\"iso-short\"\n\"14:35\"\nISO 8601, 24h\n\n\n3\n\"h_m_s_p\"\n\"2:35:00 PM\"\n12h\n\n\n4\n\"h_m_p\"\n\"2:35 PM\"\n12h\n\n\n5\n\"h_p\"\n\"2 PM\"\n12h\n\n\n\nWe can use the info_time_style() function within the console to view a similar table of time styles with example output."
  },
  {
    "objectID": "reference/vals.fmt_time.html#returns",
    "href": "reference/vals.fmt_time.html#returns",
    "title": "vals.fmt_time",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nList[str]\nA list of formatted values is returned."
  },
  {
    "objectID": "reference/data.pizzaplace.html",
    "href": "reference/data.pizzaplace.html",
    "title": "data.pizzaplace",
    "section": "",
    "text": "data.pizzaplace\nA year of pizza sales from a pizza place.\nA synthetic dataset that describes pizza sales for a pizza place somewhere in the US. While the contents are artificial, the ingredients used to make the pizzas are far from it. There are 32 different pizzas that fall into 4 different categories: classic (classic pizzas: ‘You probably had one like it before, but never like this!’), chicken (pizzas with chicken as a major ingredient: ‘Try the Southwest Chicken Pizza! You’ll love it!’), supreme (pizzas that try a little harder: ‘My Soppressata pizza uses only the finest salami from my personal salumist!’), and, veggie (pizzas without any meats whatsoever: ‘My Five Cheese pizza has so many cheeses, I can only offer it in Large Size!’).\nEach pizza in the dataset is identified by a short name. The following listings provide the full names of each pizza and their main ingredients.\nClassic Pizzas\n\n\"classic_dlx\": The Classic Deluxe Pizza (Pepperoni, Mushrooms, Red Onions, Red Peppers, Bacon)\n\"big_meat\": The Big Meat Pizza (Bacon, Pepperoni, Italian Sausage, Chorizo Sausage)\n\"pepperoni\": The Pepperoni Pizza (Mozzarella Cheese, Pepperoni)\n\"hawaiian\": The Hawaiian Pizza (Sliced Ham, Pineapple, Mozzarella Cheese)\n\"pep_msh_pep\": The Pepperoni, Mushroom, and Peppers Pizza (Pepperoni, Mushrooms, and Green Peppers)\n\"ital_cpcllo\": The Italian Capocollo Pizza (Capocollo, Red Peppers, Tomatoes, Goat Cheese, Garlic, Oregano)\n\"napolitana\": The Napolitana Pizza (Tomatoes, Anchovies, Green Olives, Red Onions, Garlic)\n\"the_greek\": The Greek Pizza (Kalamata Olives, Feta Cheese, Tomatoes, Garlic, Beef Chuck Roast, Red Onions)\n\nChicken Pizzas\n\n\"thai_ckn\": The Thai Chicken Pizza (Chicken, Pineapple, Tomatoes, Red Peppers, Thai Sweet Chilli Sauce)\n\"bbq_ckn\": The Barbecue Chicken Pizza (Barbecued Chicken, Red Peppers, Green Peppers, Tomatoes, Red Onions, Barbecue Sauce)\n\"southw_ckn\": The Southwest Chicken Pizza (Chicken, Tomatoes, Red Peppers, Red Onions, Jalapeno Peppers, Corn, Cilantro, Chipotle Sauce)\n\"cali_ckn\": The California Chicken Pizza (Chicken, Artichoke, Spinach, Garlic, Jalapeno Peppers, Fontina Cheese, Gouda Cheese)\n\"ckn_pesto\": The Chicken Pesto Pizza (Chicken, Tomatoes, Red Peppers, Spinach, Garlic, Pesto Sauce)\n\"ckn_alfredo\": The Chicken Alfredo Pizza (Chicken, Red Onions, Red Peppers, Mushrooms, Asiago Cheese, Alfredo Sauce)\n\nSupreme Pizzas\n\n\"brie_carre\": The Brie Carre Pizza (Brie Carre Cheese, Prosciutto, Caramelized Onions, Pears, Thyme, Garlic)\n\"calabrese\": The Calabrese Pizza (’Nduja Salami, Pancetta, Tomatoes, Red Onions, Friggitello Peppers, Garlic)\n\"soppressata\": The Soppressata Pizza (Soppressata Salami, Fontina Cheese, Mozzarella Cheese, Mushrooms, Garlic)\n\"sicilian\": The Sicilian Pizza (Coarse Sicilian Salami, Tomatoes, Green Olives, Luganega Sausage, Onions, Garlic)\n\"ital_supr\": The Italian Supreme Pizza (Calabrese Salami, Capocollo, Tomatoes, Red Onions, Green Olives, Garlic)\n\"peppr_salami\": The Pepper Salami Pizza (Genoa Salami, Capocollo, Pepperoni, Tomatoes, Asiago Cheese, Garlic)\n\"prsc_argla\": The Prosciutto and Arugula Pizza (Prosciutto di San Daniele, Arugula, Mozzarella Cheese)\n\"spinach_supr\": The Spinach Supreme Pizza (Spinach, Red Onions, Pepperoni, Tomatoes, Artichokes, Kalamata Olives, Garlic, Asiago Cheese)\n\"spicy_ital\": The Spicy Italian Pizza (Capocollo, Tomatoes, Goat Cheese, Artichokes, Peperoncini verdi, Garlic)\n\nVegetable Pizzas\n\n\"mexicana\": The Mexicana Pizza (Tomatoes, Red Peppers, Jalapeno Peppers, Red Onions, Cilantro, Corn, Chipotle Sauce, Garlic)\n\"four_cheese\": The Four Cheese Pizza (Ricotta Cheese, Gorgonzola Piccante Cheese, Mozzarella Cheese, Parmigiano Reggiano Cheese, Garlic)\n\"five_cheese\": The Five Cheese Pizza (Mozzarella Cheese, Provolone Cheese, Smoked Gouda Cheese, Romano Cheese, Blue Cheese, Garlic)\n\"spin_pesto\": The Spinach Pesto Pizza (Spinach, Artichokes, Tomatoes, Sun-dried Tomatoes, Garlic, Pesto Sauce)\n\"veggie_veg\": The Vegetables + Vegetables Pizza (Mushrooms, Tomatoes, Red Peppers, Green Peppers, Red Onions, Zucchini, Spinach, Garlic)\n\"green_garden\": The Green Garden Pizza (Spinach, Mushrooms, Tomatoes, Green Olives, Feta Cheese)\n\"mediterraneo\": The Mediterranean Pizza (Spinach, Artichokes, Kalamata Olives, Sun-dried Tomatoes, Feta Cheese, Plum Tomatoes, Red Onions)\n\"spinach_fet\": The Spinach and Feta Pizza (Spinach, Mushrooms, Red Onions, Feta Cheese, Garlic)\n\"ital_veggie\": The Italian Vegetables Pizza (Eggplant, Artichokes, Tomatoes, Zucchini, Red Peppers, Garlic, Pesto Sauce)\n\n\n\nThis is a dataset with 49,574 rows and 7 columns.\n\nid: The ID for the order, which consists of one or more pizzas at a given date and time. date: A character representation of the order date, expressed in the ISO 8601 date format (‘YYYY-MM-DD’).\ntime: A character representation of the order time, expressed as a 24-hour time the ISO 8601 extended time format (‘hh:mm:ss’).\nname: The short name for the pizza.\nsize: The size of the pizza, which can either be \"S\", \"M\", \"L\", \"XL\" (rare!), or \"XXL\" (even rarer!); most pizzas are available in the \"S\", \"M\", and \"L\" sizes but exceptions apply.\ntype: The category or type of pizza, which can either be \"classic\", \"chicken\", \"supreme\", or \"veggie\".\nprice: The price of the pizza and the amount that it sold for (in USD)."
  },
  {
    "objectID": "reference/data.pizzaplace.html#details",
    "href": "reference/data.pizzaplace.html#details",
    "title": "data.pizzaplace",
    "section": "",
    "text": "This is a dataset with 49,574 rows and 7 columns.\n\nid: The ID for the order, which consists of one or more pizzas at a given date and time. date: A character representation of the order date, expressed in the ISO 8601 date format (‘YYYY-MM-DD’).\ntime: A character representation of the order time, expressed as a 24-hour time the ISO 8601 extended time format (‘hh:mm:ss’).\nname: The short name for the pizza.\nsize: The size of the pizza, which can either be \"S\", \"M\", \"L\", \"XL\" (rare!), or \"XXL\" (even rarer!); most pizzas are available in the \"S\", \"M\", and \"L\" sizes but exceptions apply.\ntype: The category or type of pizza, which can either be \"classic\", \"chicken\", \"supreme\", or \"veggie\".\nprice: The price of the pizza and the amount that it sold for (in USD)."
  },
  {
    "objectID": "reference/GT.tab_source_note.html",
    "href": "reference/GT.tab_source_note.html",
    "title": "GT.tab_source_note",
    "section": "",
    "text": "GT.tab_source_note(data, source_note)\nAdd a source note citation.\nAdd a source note to the footer part of the table. A source note is useful for citing the data included in the table. Several can be added to the footer, simply use the tab_source_note() method multiple times and they will be inserted in the order provided. We can use Markdown formatting for the note, or, if the table is intended for HTML output, we can include HTML formatting."
  },
  {
    "objectID": "reference/GT.tab_source_note.html#parameters",
    "href": "reference/GT.tab_source_note.html#parameters",
    "title": "GT.tab_source_note",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nsource_note\nUnion[str, Text]\nText to be used in the source note. We can optionally use the md() or html() helper functions to style the text as Markdown or to retain HTML elements in the text.\nrequired"
  },
  {
    "objectID": "reference/GT.tab_source_note.html#returns",
    "href": "reference/GT.tab_source_note.html#returns",
    "title": "GT.tab_source_note",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.tab_source_note.html#examples",
    "href": "reference/GT.tab_source_note.html#examples",
    "title": "GT.tab_source_note",
    "section": "Examples",
    "text": "Examples\nWith three columns from the gtcars dataset, let’s create a new table. We can use the tab_source_note() method to add a source note to the table footer. Here we are citing the data source but this method can be used for any text you’d prefer to display in the footer component of the table.\n\nfrom great_tables import GT\nfrom great_tables.data import gtcars\n\ngtcars_mini = gtcars[[\"mfr\", \"model\", \"msrp\"]].head(5)\n\n(\n    GT(gtcars_mini, rowname_col=\"model\")\n    .tab_source_note(source_note=\"From edmunds.com\")\n)\n\n\n\n\n\n\n  \n  mfr\n  msrp\n\n\n  \n    GT\n    Ford\n    447000.0\n  \n  \n    458 Speciale\n    Ferrari\n    291744.0\n  \n  \n    458 Spider\n    Ferrari\n    263553.0\n  \n  \n    458 Italia\n    Ferrari\n    233509.0\n  \n  \n    488 GTB\n    Ferrari\n    245400.0\n  \n\n  \n  \n  \n    From edmunds.com"
  },
  {
    "objectID": "reference/GT.tab_header.html",
    "href": "reference/GT.tab_header.html",
    "title": "GT.tab_header",
    "section": "",
    "text": "GT.tab_header(self, title, subtitle=None, preheader=None)\nAdd a table header.\nWe can add a table header to the output table that contains a title and even a subtitle with the tab_header() method. A table header is an optional table component that is positioned above the column labels. We have the flexibility to use Markdown or HTML formatting for the header’s title and subtitle with the md() and html() helper functions."
  },
  {
    "objectID": "reference/GT.tab_header.html#parameters",
    "href": "reference/GT.tab_header.html#parameters",
    "title": "GT.tab_header",
    "section": "Parameters",
    "text": "Parameters\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ntitle\nUnion[str, Text]\nText to be used in the table title. We can elect to use the md() and html() helper functions to style the text as Markdown or to retain HTML elements in the text.\nrequired\n\n\nsubtitle\nOptional[Union[str, Text]]\nText to be used in the table subtitle. We can elect to use the md() and html() helper functions to style the text as Markdown or to retain HTML elements in the text.\nNone\n\n\npreheader\nOptional[Union[str, List[str]]]\nOptional preheader content that is rendered above the table. Can be supplied as a list of strings.\nNone"
  },
  {
    "objectID": "reference/GT.tab_header.html#returns",
    "href": "reference/GT.tab_header.html#returns",
    "title": "GT.tab_header",
    "section": "Returns",
    "text": "Returns\n\n\n\nType\nDescription\n\n\n\n\nGT\nThe GT object is returned. This is the same object that the method is called on so that we can facilitate method chaining."
  },
  {
    "objectID": "reference/GT.tab_header.html#examples",
    "href": "reference/GT.tab_header.html#examples",
    "title": "GT.tab_header",
    "section": "Examples",
    "text": "Examples\nLet’s use a small portion of the gtcars dataset to create a table. A header part can be added to the table with the tab_header() method. We’ll add a title and the optional subtitle as well. With the md() helper function, we can make sure the Markdown formatting is interpreted and transformed.\n\nfrom great_tables import GT, md\nfrom great_tables.data import gtcars\n\ngtcars_mini = gtcars[[\"mfr\", \"model\", \"msrp\"]].head(5)\n\n(\n    GT(gtcars_mini)\n    .tab_header(\n        title=md(\"Data listing from **gtcars**\"),\n        subtitle=md(\"`gtcars` is an R dataset\")\n    )\n)\n\n\n\n\n\n  \n    Data listing from gtcars\n  \n  \n    gtcars is an R dataset\n  \n\n\n  mfr\n  model\n  msrp\n\n\n  \n    Ford\n    GT\n    447000.0\n  \n  \n    Ferrari\n    458 Speciale\n    291744.0\n  \n  \n    Ferrari\n    458 Spider\n    263553.0\n  \n  \n    Ferrari\n    458 Italia\n    233509.0\n  \n  \n    Ferrari\n    488 GTB\n    245400.0\n  \n\n\n\n\n\n\n        \n\n\nWe can alternatively use the html() helper function to retain HTML elements in the text.\n\nfrom great_tables import GT, md, html\nfrom great_tables.data import gtcars\n\ngtcars_mini = gtcars[[\"mfr\", \"model\", \"msrp\"]].head(5)\n\n(\n    GT(gtcars_mini)\n    .tab_header(\n        title=md(\"Data listing &lt;strong&gt;gtcars&lt;/strong&gt;\"),\n        subtitle=html(\"From &lt;span style='color:red;'&gt;gtcars&lt;/span&gt;\")\n    )\n)\n\n\n\n\n\n  \n    Data listing gtcars\n  \n  \n    From gtcars\n  \n\n\n  mfr\n  model\n  msrp\n\n\n  \n    Ford\n    GT\n    447000.0\n  \n  \n    Ferrari\n    458 Speciale\n    291744.0\n  \n  \n    Ferrari\n    458 Spider\n    263553.0\n  \n  \n    Ferrari\n    458 Italia\n    233509.0\n  \n  \n    Ferrari\n    488 GTB\n    245400.0"
  },
  {
    "objectID": "reference/style.text.html",
    "href": "reference/style.text.html",
    "title": "style.text",
    "section": "",
    "text": "style.text(color=None, font=None, size=None, align=None, v_align=None, style=None, weight=None, stretch=None, decorate=None, transform=None, whitespace=None)\nA style specification for cell text.\nThe style.text() class is to be used with the tab_style() method, which itself allows for the setting of custom styles to one or more cells. With it, you can specify the color of the text, the font family, the font size, and the horizontal and vertical alignment of the text and more.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ncolor\nstr | ColumnExpr | None\nThe text color can be modified through the color argument.\nNone\n\n\nfont\nstr | ColumnExpr | None\nThe font or collection of fonts (subsequent font names are) used as fallbacks.\nNone\n\n\nsize\nstr | ColumnExpr | None\nThe size of the font. Can be provided as a number that is assumed to represent px values (or could be wrapped in the px() helper function). We can also use one of the following absolute size keywords: \"xx-small\", \"x-small\", \"small\", \"medium\", \"large\", \"x-large\", or \"xx-large\".\nNone\n\n\nalign\nLiteral[‘center’, ‘left’, ‘right’, ‘justify’] | ColumnExpr | None\nThe text in a cell can be horizontally aligned though one of the following options: \"center\", \"left\", \"right\", or \"justify\".\nNone\n\n\nv_align\nLiteral[‘middle’, ‘top’, ‘bottom’] | ColumnExpr | None\nThe vertical alignment of the text in the cell can be modified through the options \"middle\", \"top\", or \"bottom\".\nNone\n\n\nstyle\nLiteral[‘normal’, ‘italic’, ‘oblique’] | ColumnExpr | None\nCan be one of either \"normal\", \"italic\", or \"oblique\".\nNone\n\n\nweight\nLiteral[‘normal’, ‘bold’, ‘bolder’, ‘lighter’] | ColumnExpr | None\nThe weight of the font can be modified thorough a text-based option such as \"normal\", \"bold\", \"lighter\", \"bolder\", or, a numeric value between 1 and 1000, inclusive. Note that only variable fonts may support the numeric mapping of weight.\nNone\n\n\nstretch\nLiteral[‘normal’, ‘condensed’, ‘ultra-condensed’, ‘extra-condensed’, ‘semi-condensed’, ‘semi-expanded’, ‘expanded’, ‘extra-expanded’, ‘ultra-expanded’] | ColumnExpr | None\nAllows for text to either be condensed or expanded. We can use one of the following text-based keywords to describe the degree of condensation/expansion: \"ultra-condensed\", \"extra-condensed\", \"condensed\", \"semi-condensed\", \"normal\", \"semi-expanded\", \"expanded\", \"extra-expanded\", or \"ultra-expanded\". Alternatively, we can supply percentage values from 0% to 200%, inclusive. Negative percentage values are not allowed.\nNone\n\n\ndecorate\nLiteral[‘overline’, ‘line-through’, ‘underline’, ‘underline overline’] | ColumnExpr | None\nAllows for text decoration effect to be applied. Here, we can use \"overline\", \"line-through\", or \"underline\".\nNone\n\n\ntransform\nLiteral[‘uppercase’, ‘lowercase’, ‘capitalize’] | ColumnExpr | None\nAllows for the transformation of text. Options are \"uppercase\", \"lowercase\", or \"capitalize\".\nNone\n\n\nwhitespace\nLiteral[‘normal’, ‘nowrap’, ‘pre’, ‘pre-wrap’, ‘pre-line’, ‘break-spaces’] | ColumnExpr | None\nA white-space preservation option. By default, runs of white-space will be collapsed into single spaces but several options exist to govern how white-space is collapsed and how lines might wrap at soft-wrap opportunities. The options are \"normal\", \"nowrap\", \"pre\", \"pre-wrap\", \"pre-line\", and \"break-spaces\".\nNone\n\n\n\n\n\n\n\n\n\nType\nDescription\n\n\n\n\nCellStyleText\nA CellStyleText object, which is used for a styles argument if specifying any cell text properties."
  },
  {
    "objectID": "reference/style.text.html#parameters",
    "href": "reference/style.text.html#parameters",
    "title": "style.text",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ncolor\nstr | ColumnExpr | None\nThe text color can be modified through the color argument.\nNone\n\n\nfont\nstr | ColumnExpr | None\nThe font or collection of fonts (subsequent font names are) used as fallbacks.\nNone\n\n\nsize\nstr | ColumnExpr | None\nThe size of the font. Can be provided as a number that is assumed to represent px values (or could be wrapped in the px() helper function). We can also use one of the following absolute size keywords: \"xx-small\", \"x-small\", \"small\", \"medium\", \"large\", \"x-large\", or \"xx-large\".\nNone\n\n\nalign\nLiteral[‘center’, ‘left’, ‘right’, ‘justify’] | ColumnExpr | None\nThe text in a cell can be horizontally aligned though one of the following options: \"center\", \"left\", \"right\", or \"justify\".\nNone\n\n\nv_align\nLiteral[‘middle’, ‘top’, ‘bottom’] | ColumnExpr | None\nThe vertical alignment of the text in the cell can be modified through the options \"middle\", \"top\", or \"bottom\".\nNone\n\n\nstyle\nLiteral[‘normal’, ‘italic’, ‘oblique’] | ColumnExpr | None\nCan be one of either \"normal\", \"italic\", or \"oblique\".\nNone\n\n\nweight\nLiteral[‘normal’, ‘bold’, ‘bolder’, ‘lighter’] | ColumnExpr | None\nThe weight of the font can be modified thorough a text-based option such as \"normal\", \"bold\", \"lighter\", \"bolder\", or, a numeric value between 1 and 1000, inclusive. Note that only variable fonts may support the numeric mapping of weight.\nNone\n\n\nstretch\nLiteral[‘normal’, ‘condensed’, ‘ultra-condensed’, ‘extra-condensed’, ‘semi-condensed’, ‘semi-expanded’, ‘expanded’, ‘extra-expanded’, ‘ultra-expanded’] | ColumnExpr | None\nAllows for text to either be condensed or expanded. We can use one of the following text-based keywords to describe the degree of condensation/expansion: \"ultra-condensed\", \"extra-condensed\", \"condensed\", \"semi-condensed\", \"normal\", \"semi-expanded\", \"expanded\", \"extra-expanded\", or \"ultra-expanded\". Alternatively, we can supply percentage values from 0% to 200%, inclusive. Negative percentage values are not allowed.\nNone\n\n\ndecorate\nLiteral[‘overline’, ‘line-through’, ‘underline’, ‘underline overline’] | ColumnExpr | None\nAllows for text decoration effect to be applied. Here, we can use \"overline\", \"line-through\", or \"underline\".\nNone\n\n\ntransform\nLiteral[‘uppercase’, ‘lowercase’, ‘capitalize’] | ColumnExpr | None\nAllows for the transformation of text. Options are \"uppercase\", \"lowercase\", or \"capitalize\".\nNone\n\n\nwhitespace\nLiteral[‘normal’, ‘nowrap’, ‘pre’, ‘pre-wrap’, ‘pre-line’, ‘break-spaces’] | ColumnExpr | None\nA white-space preservation option. By default, runs of white-space will be collapsed into single spaces but several options exist to govern how white-space is collapsed and how lines might wrap at soft-wrap opportunities. The options are \"normal\", \"nowrap\", \"pre\", \"pre-wrap\", \"pre-line\", and \"break-spaces\".\nNone"
  },
  {
    "objectID": "reference/style.text.html#returns",
    "href": "reference/style.text.html#returns",
    "title": "style.text",
    "section": "",
    "text": "Type\nDescription\n\n\n\n\nCellStyleText\nA CellStyleText object, which is used for a styles argument if specifying any cell text properties."
  }
]